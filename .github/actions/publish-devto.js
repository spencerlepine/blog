import { createRequire as __WEBPACK_EXTERNAL_createRequire } from "module"; var __webpack_modules__ = {
  7351: function (e, t, r) { var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) { if (n === undefined) n = r; Object.defineProperty(e, n, { enumerable: true, get: function () { return t[r] } }) } : function (e, t, r, n) { if (n === undefined) n = r; e[n] = t[r] }); var i = this && this.__setModuleDefault || (Object.create ? function (e, t) { Object.defineProperty(e, "default", { enumerable: true, value: t }) } : function (e, t) { e["default"] = t }); var s = this && this.__importStar || function (e) { if (e && e.__esModule) return e; var t = {}; if (e != null) for (var r in e) if (r !== "default" && Object.hasOwnProperty.call(e, r)) n(t, e, r); i(t, e); return t }; Object.defineProperty(t, "__esModule", { value: true }); t.issue = t.issueCommand = void 0; const o = s(r(2037)); const a = r(5278); function issueCommand(e, t, r) { const n = new Command(e, t, r); process.stdout.write(n.toString() + o.EOL) } t.issueCommand = issueCommand; function issue(e, t = "") { issueCommand(e, {}, t) } t.issue = issue; const u = "::"; class Command { constructor(e, t, r) { if (!e) { e = "missing.command" } this.command = e; this.properties = t; this.message = r } toString() { let e = u + this.command; if (this.properties && Object.keys(this.properties).length > 0) { e += " "; let t = true; for (const r in this.properties) { if (this.properties.hasOwnProperty(r)) { const n = this.properties[r]; if (n) { if (t) { t = false } else { e += "," } e += `${r}=${escapeProperty(n)}` } } } } e += `${u}${escapeData(this.message)}`; return e } } function escapeData(e) { return a.toCommandValue(e).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A") } function escapeProperty(e) { return a.toCommandValue(e).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/:/g, "%3A").replace(/,/g, "%2C") } }, 2186: function (e, t, r) { var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) { if (n === undefined) n = r; Object.defineProperty(e, n, { enumerable: true, get: function () { return t[r] } }) } : function (e, t, r, n) { if (n === undefined) n = r; e[n] = t[r] }); var i = this && this.__setModuleDefault || (Object.create ? function (e, t) { Object.defineProperty(e, "default", { enumerable: true, value: t }) } : function (e, t) { e["default"] = t }); var s = this && this.__importStar || function (e) { if (e && e.__esModule) return e; var t = {}; if (e != null) for (var r in e) if (r !== "default" && Object.hasOwnProperty.call(e, r)) n(t, e, r); i(t, e); return t }; var o = this && this.__awaiter || function (e, t, r, n) { function adopt(e) { return e instanceof r ? e : new r((function (t) { t(e) })) } return new (r || (r = Promise))((function (r, i) { function fulfilled(e) { try { step(n.next(e)) } catch (e) { i(e) } } function rejected(e) { try { step(n["throw"](e)) } catch (e) { i(e) } } function step(e) { e.done ? r(e.value) : adopt(e.value).then(fulfilled, rejected) } step((n = n.apply(e, t || [])).next()) })) }; Object.defineProperty(t, "__esModule", { value: true }); t.getIDToken = t.getState = t.saveState = t.group = t.endGroup = t.startGroup = t.info = t.notice = t.warning = t.error = t.debug = t.isDebug = t.setFailed = t.setCommandEcho = t.setOutput = t.getBooleanInput = t.getMultilineInput = t.getInput = t.addPath = t.setSecret = t.exportVariable = t.ExitCode = void 0; const a = r(7351); const u = r(717); const l = r(5278); const f = s(r(2037)); const d = s(r(1017)); const p = r(8041); var h; (function (e) { e[e["Success"] = 0] = "Success"; e[e["Failure"] = 1] = "Failure" })(h = t.ExitCode || (t.ExitCode = {})); function exportVariable(e, t) { const r = l.toCommandValue(t); process.env[e] = r; const n = process.env["GITHUB_ENV"] || ""; if (n) { return u.issueFileCommand("ENV", u.prepareKeyValueMessage(e, t)) } a.issueCommand("set-env", { name: e }, r) } t.exportVariable = exportVariable; function setSecret(e) { a.issueCommand("add-mask", {}, e) } t.setSecret = setSecret; function addPath(e) { const t = process.env["GITHUB_PATH"] || ""; if (t) { u.issueFileCommand("PATH", e) } else { a.issueCommand("add-path", {}, e) } process.env["PATH"] = `${e}${d.delimiter}${process.env["PATH"]}` } t.addPath = addPath; function getInput(e, t) { const r = process.env[`INPUT_${e.replace(/ /g, "_").toUpperCase()}`] || ""; if (t && t.required && !r) { throw new Error(`Input required and not supplied: ${e}`) } if (t && t.trimWhitespace === false) { return r } return r.trim() } t.getInput = getInput; function getMultilineInput(e, t) { const r = getInput(e, t).split("\n").filter((e => e !== "")); if (t && t.trimWhitespace === false) { return r } return r.map((e => e.trim())) } t.getMultilineInput = getMultilineInput; function getBooleanInput(e, t) { const r = ["true", "True", "TRUE"]; const n = ["false", "False", "FALSE"]; const i = getInput(e, t); if (r.includes(i)) return true; if (n.includes(i)) return false; throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${e}\n` + `Support boolean input list: \`true | True | TRUE | false | False | FALSE\``) } t.getBooleanInput = getBooleanInput; function setOutput(e, t) { const r = process.env["GITHUB_OUTPUT"] || ""; if (r) { return u.issueFileCommand("OUTPUT", u.prepareKeyValueMessage(e, t)) } process.stdout.write(f.EOL); a.issueCommand("set-output", { name: e }, l.toCommandValue(t)) } t.setOutput = setOutput; function setCommandEcho(e) { a.issue("echo", e ? "on" : "off") } t.setCommandEcho = setCommandEcho; function setFailed(e) { process.exitCode = h.Failure; error(e) } t.setFailed = setFailed; function isDebug() { return process.env["RUNNER_DEBUG"] === "1" } t.isDebug = isDebug; function debug(e) { a.issueCommand("debug", {}, e) } t.debug = debug; function error(e, t = {}) { a.issueCommand("error", l.toCommandProperties(t), e instanceof Error ? e.toString() : e) } t.error = error; function warning(e, t = {}) { a.issueCommand("warning", l.toCommandProperties(t), e instanceof Error ? e.toString() : e) } t.warning = warning; function notice(e, t = {}) { a.issueCommand("notice", l.toCommandProperties(t), e instanceof Error ? e.toString() : e) } t.notice = notice; function info(e) { process.stdout.write(e + f.EOL) } t.info = info; function startGroup(e) { a.issue("group", e) } t.startGroup = startGroup; function endGroup() { a.issue("endgroup") } t.endGroup = endGroup; function group(e, t) { return o(this, void 0, void 0, (function* () { startGroup(e); let r; try { r = yield t() } finally { endGroup() } return r })) } t.group = group; function saveState(e, t) { const r = process.env["GITHUB_STATE"] || ""; if (r) { return u.issueFileCommand("STATE", u.prepareKeyValueMessage(e, t)) } a.issueCommand("save-state", { name: e }, l.toCommandValue(t)) } t.saveState = saveState; function getState(e) { return process.env[`STATE_${e}`] || "" } t.getState = getState; function getIDToken(e) { return o(this, void 0, void 0, (function* () { return yield p.OidcClient.getIDToken(e) })) } t.getIDToken = getIDToken; var m = r(1327); Object.defineProperty(t, "summary", { enumerable: true, get: function () { return m.summary } }); var g = r(1327); Object.defineProperty(t, "markdownSummary", { enumerable: true, get: function () { return g.markdownSummary } }); var y = r(2981); Object.defineProperty(t, "toPosixPath", { enumerable: true, get: function () { return y.toPosixPath } }); Object.defineProperty(t, "toWin32Path", { enumerable: true, get: function () { return y.toWin32Path } }); Object.defineProperty(t, "toPlatformPath", { enumerable: true, get: function () { return y.toPlatformPath } }) }, 717: function (e, t, r) { var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) { if (n === undefined) n = r; Object.defineProperty(e, n, { enumerable: true, get: function () { return t[r] } }) } : function (e, t, r, n) { if (n === undefined) n = r; e[n] = t[r] }); var i = this && this.__setModuleDefault || (Object.create ? function (e, t) { Object.defineProperty(e, "default", { enumerable: true, value: t }) } : function (e, t) { e["default"] = t }); var s = this && this.__importStar || function (e) { if (e && e.__esModule) return e; var t = {}; if (e != null) for (var r in e) if (r !== "default" && Object.hasOwnProperty.call(e, r)) n(t, e, r); i(t, e); return t }; Object.defineProperty(t, "__esModule", { value: true }); t.prepareKeyValueMessage = t.issueFileCommand = void 0; const o = s(r(7147)); const a = s(r(2037)); const u = r(5840); const l = r(5278); function issueFileCommand(e, t) { const r = process.env[`GITHUB_${e}`]; if (!r) { throw new Error(`Unable to find environment variable for file command ${e}`) } if (!o.existsSync(r)) { throw new Error(`Missing file at path: ${r}`) } o.appendFileSync(r, `${l.toCommandValue(t)}${a.EOL}`, { encoding: "utf8" }) } t.issueFileCommand = issueFileCommand; function prepareKeyValueMessage(e, t) { const r = `ghadelimiter_${u.v4()}`; const n = l.toCommandValue(t); if (e.includes(r)) { throw new Error(`Unexpected input: name should not contain the delimiter "${r}"`) } if (n.includes(r)) { throw new Error(`Unexpected input: value should not contain the delimiter "${r}"`) } return `${e}<<${r}${a.EOL}${n}${a.EOL}${r}` } t.prepareKeyValueMessage = prepareKeyValueMessage }, 8041: function (e, t, r) { var n = this && this.__awaiter || function (e, t, r, n) { function adopt(e) { return e instanceof r ? e : new r((function (t) { t(e) })) } return new (r || (r = Promise))((function (r, i) { function fulfilled(e) { try { step(n.next(e)) } catch (e) { i(e) } } function rejected(e) { try { step(n["throw"](e)) } catch (e) { i(e) } } function step(e) { e.done ? r(e.value) : adopt(e.value).then(fulfilled, rejected) } step((n = n.apply(e, t || [])).next()) })) }; Object.defineProperty(t, "__esModule", { value: true }); t.OidcClient = void 0; const i = r(6255); const s = r(5526); const o = r(2186); class OidcClient { static createHttpClient(e = true, t = 10) { const r = { allowRetries: e, maxRetries: t }; return new i.HttpClient("actions/oidc-client", [new s.BearerCredentialHandler(OidcClient.getRequestToken())], r) } static getRequestToken() { const e = process.env["ACTIONS_ID_TOKEN_REQUEST_TOKEN"]; if (!e) { throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable") } return e } static getIDTokenUrl() { const e = process.env["ACTIONS_ID_TOKEN_REQUEST_URL"]; if (!e) { throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable") } return e } static getCall(e) { var t; return n(this, void 0, void 0, (function* () { const r = OidcClient.createHttpClient(); const n = yield r.getJson(e).catch((e => { throw new Error(`Failed to get ID Token. \n \n        Error Code : ${e.statusCode}\n \n        Error Message: ${e.result.message}`) })); const i = (t = n.result) === null || t === void 0 ? void 0 : t.value; if (!i) { throw new Error("Response json body do not have ID Token field") } return i })) } static getIDToken(e) { return n(this, void 0, void 0, (function* () { try { let t = OidcClient.getIDTokenUrl(); if (e) { const r = encodeURIComponent(e); t = `${t}&audience=${r}` } o.debug(`ID token url is ${t}`); const r = yield OidcClient.getCall(t); o.setSecret(r); return r } catch (e) { throw new Error(`Error message: ${e.message}`) } })) } } t.OidcClient = OidcClient }, 2981: function (e, t, r) { var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) { if (n === undefined) n = r; Object.defineProperty(e, n, { enumerable: true, get: function () { return t[r] } }) } : function (e, t, r, n) { if (n === undefined) n = r; e[n] = t[r] }); var i = this && this.__setModuleDefault || (Object.create ? function (e, t) { Object.defineProperty(e, "default", { enumerable: true, value: t }) } : function (e, t) { e["default"] = t }); var s = this && this.__importStar || function (e) { if (e && e.__esModule) return e; var t = {}; if (e != null) for (var r in e) if (r !== "default" && Object.hasOwnProperty.call(e, r)) n(t, e, r); i(t, e); return t }; Object.defineProperty(t, "__esModule", { value: true }); t.toPlatformPath = t.toWin32Path = t.toPosixPath = void 0; const o = s(r(1017)); function toPosixPath(e) { return e.replace(/[\\]/g, "/") } t.toPosixPath = toPosixPath; function toWin32Path(e) { return e.replace(/[/]/g, "\\") } t.toWin32Path = toWin32Path; function toPlatformPath(e) { return e.replace(/[/\\]/g, o.sep) } t.toPlatformPath = toPlatformPath }, 1327: function (e, t, r) { var n = this && this.__awaiter || function (e, t, r, n) { function adopt(e) { return e instanceof r ? e : new r((function (t) { t(e) })) } return new (r || (r = Promise))((function (r, i) { function fulfilled(e) { try { step(n.next(e)) } catch (e) { i(e) } } function rejected(e) { try { step(n["throw"](e)) } catch (e) { i(e) } } function step(e) { e.done ? r(e.value) : adopt(e.value).then(fulfilled, rejected) } step((n = n.apply(e, t || [])).next()) })) }; Object.defineProperty(t, "__esModule", { value: true }); t.summary = t.markdownSummary = t.SUMMARY_DOCS_URL = t.SUMMARY_ENV_VAR = void 0; const i = r(2037); const s = r(7147); const { access: o, appendFile: a, writeFile: u } = s.promises; t.SUMMARY_ENV_VAR = "GITHUB_STEP_SUMMARY"; t.SUMMARY_DOCS_URL = "https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary"; class Summary { constructor() { this._buffer = "" } filePath() { return n(this, void 0, void 0, (function* () { if (this._filePath) { return this._filePath } const e = process.env[t.SUMMARY_ENV_VAR]; if (!e) { throw new Error(`Unable to find environment variable for $${t.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`) } try { yield o(e, s.constants.R_OK | s.constants.W_OK) } catch (t) { throw new Error(`Unable to access summary file: '${e}'. Check if the file has correct read/write permissions.`) } this._filePath = e; return this._filePath })) } wrap(e, t, r = {}) { const n = Object.entries(r).map((([e, t]) => ` ${e}="${t}"`)).join(""); if (!t) { return `<${e}${n}>` } return `<${e}${n}>${t}</${e}>` } write(e) { return n(this, void 0, void 0, (function* () { const t = !!(e === null || e === void 0 ? void 0 : e.overwrite); const r = yield this.filePath(); const n = t ? u : a; yield n(r, this._buffer, { encoding: "utf8" }); return this.emptyBuffer() })) } clear() { return n(this, void 0, void 0, (function* () { return this.emptyBuffer().write({ overwrite: true }) })) } stringify() { return this._buffer } isEmptyBuffer() { return this._buffer.length === 0 } emptyBuffer() { this._buffer = ""; return this } addRaw(e, t = false) { this._buffer += e; return t ? this.addEOL() : this } addEOL() { return this.addRaw(i.EOL) } addCodeBlock(e, t) { const r = Object.assign({}, t && { lang: t }); const n = this.wrap("pre", this.wrap("code", e), r); return this.addRaw(n).addEOL() } addList(e, t = false) { const r = t ? "ol" : "ul"; const n = e.map((e => this.wrap("li", e))).join(""); const i = this.wrap(r, n); return this.addRaw(i).addEOL() } addTable(e) { const t = e.map((e => { const t = e.map((e => { if (typeof e === "string") { return this.wrap("td", e) } const { header: t, data: r, colspan: n, rowspan: i } = e; const s = t ? "th" : "td"; const o = Object.assign(Object.assign({}, n && { colspan: n }), i && { rowspan: i }); return this.wrap(s, r, o) })).join(""); return this.wrap("tr", t) })).join(""); const r = this.wrap("table", t); return this.addRaw(r).addEOL() } addDetails(e, t) { const r = this.wrap("details", this.wrap("summary", e) + t); return this.addRaw(r).addEOL() } addImage(e, t, r) { const { width: n, height: i } = r || {}; const s = Object.assign(Object.assign({}, n && { width: n }), i && { height: i }); const o = this.wrap("img", null, Object.assign({ src: e, alt: t }, s)); return this.addRaw(o).addEOL() } addHeading(e, t) { const r = `h${t}`; const n = ["h1", "h2", "h3", "h4", "h5", "h6"].includes(r) ? r : "h1"; const i = this.wrap(n, e); return this.addRaw(i).addEOL() } addSeparator() { const e = this.wrap("hr", null); return this.addRaw(e).addEOL() } addBreak() { const e = this.wrap("br", null); return this.addRaw(e).addEOL() } addQuote(e, t) { const r = Object.assign({}, t && { cite: t }); const n = this.wrap("blockquote", e, r); return this.addRaw(n).addEOL() } addLink(e, t) { const r = this.wrap("a", e, { href: t }); return this.addRaw(r).addEOL() } } const l = new Summary; t.markdownSummary = l; t.summary = l }, 5278: (e, t) => { Object.defineProperty(t, "__esModule", { value: true }); t.toCommandProperties = t.toCommandValue = void 0; function toCommandValue(e) { if (e === null || e === undefined) { return "" } else if (typeof e === "string" || e instanceof String) { return e } return JSON.stringify(e) } t.toCommandValue = toCommandValue; function toCommandProperties(e) { if (!Object.keys(e).length) { return {} } return { title: e.title, file: e.file, line: e.startLine, endLine: e.endLine, col: e.startColumn, endColumn: e.endColumn } } t.toCommandProperties = toCommandProperties }, 5526: function (e, t) { var r = this && this.__awaiter || function (e, t, r, n) { function adopt(e) { return e instanceof r ? e : new r((function (t) { t(e) })) } return new (r || (r = Promise))((function (r, i) { function fulfilled(e) { try { step(n.next(e)) } catch (e) { i(e) } } function rejected(e) { try { step(n["throw"](e)) } catch (e) { i(e) } } function step(e) { e.done ? r(e.value) : adopt(e.value).then(fulfilled, rejected) } step((n = n.apply(e, t || [])).next()) })) }; Object.defineProperty(t, "__esModule", { value: true }); t.PersonalAccessTokenCredentialHandler = t.BearerCredentialHandler = t.BasicCredentialHandler = void 0; class BasicCredentialHandler { constructor(e, t) { this.username = e; this.password = t } prepareRequest(e) { if (!e.headers) { throw Error("The request has no headers") } e.headers["Authorization"] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString("base64")}` } canHandleAuthentication() { return false } handleAuthentication() { return r(this, void 0, void 0, (function* () { throw new Error("not implemented") })) } } t.BasicCredentialHandler = BasicCredentialHandler; class BearerCredentialHandler { constructor(e) { this.token = e } prepareRequest(e) { if (!e.headers) { throw Error("The request has no headers") } e.headers["Authorization"] = `Bearer ${this.token}` } canHandleAuthentication() { return false } handleAuthentication() { return r(this, void 0, void 0, (function* () { throw new Error("not implemented") })) } } t.BearerCredentialHandler = BearerCredentialHandler; class PersonalAccessTokenCredentialHandler { constructor(e) { this.token = e } prepareRequest(e) { if (!e.headers) { throw Error("The request has no headers") } e.headers["Authorization"] = `Basic ${Buffer.from(`PAT:${this.token}`).toString("base64")}` } canHandleAuthentication() { return false } handleAuthentication() { return r(this, void 0, void 0, (function* () { throw new Error("not implemented") })) } } t.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler }, 6255: function (e, t, r) { var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) { if (n === undefined) n = r; Object.defineProperty(e, n, { enumerable: true, get: function () { return t[r] } }) } : function (e, t, r, n) { if (n === undefined) n = r; e[n] = t[r] }); var i = this && this.__setModuleDefault || (Object.create ? function (e, t) { Object.defineProperty(e, "default", { enumerable: true, value: t }) } : function (e, t) { e["default"] = t }); var s = this && this.__importStar || function (e) { if (e && e.__esModule) return e; var t = {}; if (e != null) for (var r in e) if (r !== "default" && Object.hasOwnProperty.call(e, r)) n(t, e, r); i(t, e); return t }; var o = this && this.__awaiter || function (e, t, r, n) { function adopt(e) { return e instanceof r ? e : new r((function (t) { t(e) })) } return new (r || (r = Promise))((function (r, i) { function fulfilled(e) { try { step(n.next(e)) } catch (e) { i(e) } } function rejected(e) { try { step(n["throw"](e)) } catch (e) { i(e) } } function step(e) { e.done ? r(e.value) : adopt(e.value).then(fulfilled, rejected) } step((n = n.apply(e, t || [])).next()) })) }; Object.defineProperty(t, "__esModule", { value: true }); t.HttpClient = t.isHttps = t.HttpClientResponse = t.HttpClientError = t.getProxyUrl = t.MediaTypes = t.Headers = t.HttpCodes = void 0; const a = s(r(3685)); const u = s(r(5687)); const l = s(r(9835)); const f = s(r(4294)); var d; (function (e) { e[e["OK"] = 200] = "OK"; e[e["MultipleChoices"] = 300] = "MultipleChoices"; e[e["MovedPermanently"] = 301] = "MovedPermanently"; e[e["ResourceMoved"] = 302] = "ResourceMoved"; e[e["SeeOther"] = 303] = "SeeOther"; e[e["NotModified"] = 304] = "NotModified"; e[e["UseProxy"] = 305] = "UseProxy"; e[e["SwitchProxy"] = 306] = "SwitchProxy"; e[e["TemporaryRedirect"] = 307] = "TemporaryRedirect"; e[e["PermanentRedirect"] = 308] = "PermanentRedirect"; e[e["BadRequest"] = 400] = "BadRequest"; e[e["Unauthorized"] = 401] = "Unauthorized"; e[e["PaymentRequired"] = 402] = "PaymentRequired"; e[e["Forbidden"] = 403] = "Forbidden"; e[e["NotFound"] = 404] = "NotFound"; e[e["MethodNotAllowed"] = 405] = "MethodNotAllowed"; e[e["NotAcceptable"] = 406] = "NotAcceptable"; e[e["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired"; e[e["RequestTimeout"] = 408] = "RequestTimeout"; e[e["Conflict"] = 409] = "Conflict"; e[e["Gone"] = 410] = "Gone"; e[e["TooManyRequests"] = 429] = "TooManyRequests"; e[e["InternalServerError"] = 500] = "InternalServerError"; e[e["NotImplemented"] = 501] = "NotImplemented"; e[e["BadGateway"] = 502] = "BadGateway"; e[e["ServiceUnavailable"] = 503] = "ServiceUnavailable"; e[e["GatewayTimeout"] = 504] = "GatewayTimeout" })(d = t.HttpCodes || (t.HttpCodes = {})); var p; (function (e) { e["Accept"] = "accept"; e["ContentType"] = "content-type" })(p = t.Headers || (t.Headers = {})); var h; (function (e) { e["ApplicationJson"] = "application/json" })(h = t.MediaTypes || (t.MediaTypes = {})); function getProxyUrl(e) { const t = l.getProxyUrl(new URL(e)); return t ? t.href : "" } t.getProxyUrl = getProxyUrl; const m = [d.MovedPermanently, d.ResourceMoved, d.SeeOther, d.TemporaryRedirect, d.PermanentRedirect]; const g = [d.BadGateway, d.ServiceUnavailable, d.GatewayTimeout]; const y = ["OPTIONS", "GET", "DELETE", "HEAD"]; const b = 10; const _ = 5; class HttpClientError extends Error { constructor(e, t) { super(e); this.name = "HttpClientError"; this.statusCode = t; Object.setPrototypeOf(this, HttpClientError.prototype) } } t.HttpClientError = HttpClientError; class HttpClientResponse { constructor(e) { this.message = e } readBody() { return o(this, void 0, void 0, (function* () { return new Promise((e => o(this, void 0, void 0, (function* () { let t = Buffer.alloc(0); this.message.on("data", (e => { t = Buffer.concat([t, e]) })); this.message.on("end", (() => { e(t.toString()) })) })))) })) } } t.HttpClientResponse = HttpClientResponse; function isHttps(e) { const t = new URL(e); return t.protocol === "https:" } t.isHttps = isHttps; class HttpClient { constructor(e, t, r) { this._ignoreSslError = false; this._allowRedirects = true; this._allowRedirectDowngrade = false; this._maxRedirects = 50; this._allowRetries = false; this._maxRetries = 1; this._keepAlive = false; this._disposed = false; this.userAgent = e; this.handlers = t || []; this.requestOptions = r; if (r) { if (r.ignoreSslError != null) { this._ignoreSslError = r.ignoreSslError } this._socketTimeout = r.socketTimeout; if (r.allowRedirects != null) { this._allowRedirects = r.allowRedirects } if (r.allowRedirectDowngrade != null) { this._allowRedirectDowngrade = r.allowRedirectDowngrade } if (r.maxRedirects != null) { this._maxRedirects = Math.max(r.maxRedirects, 0) } if (r.keepAlive != null) { this._keepAlive = r.keepAlive } if (r.allowRetries != null) { this._allowRetries = r.allowRetries } if (r.maxRetries != null) { this._maxRetries = r.maxRetries } } } options(e, t) { return o(this, void 0, void 0, (function* () { return this.request("OPTIONS", e, null, t || {}) })) } get(e, t) { return o(this, void 0, void 0, (function* () { return this.request("GET", e, null, t || {}) })) } del(e, t) { return o(this, void 0, void 0, (function* () { return this.request("DELETE", e, null, t || {}) })) } post(e, t, r) { return o(this, void 0, void 0, (function* () { return this.request("POST", e, t, r || {}) })) } patch(e, t, r) { return o(this, void 0, void 0, (function* () { return this.request("PATCH", e, t, r || {}) })) } put(e, t, r) { return o(this, void 0, void 0, (function* () { return this.request("PUT", e, t, r || {}) })) } head(e, t) { return o(this, void 0, void 0, (function* () { return this.request("HEAD", e, null, t || {}) })) } sendStream(e, t, r, n) { return o(this, void 0, void 0, (function* () { return this.request(e, t, r, n) })) } getJson(e, t = {}) { return o(this, void 0, void 0, (function* () { t[p.Accept] = this._getExistingOrDefaultHeader(t, p.Accept, h.ApplicationJson); const r = yield this.get(e, t); return this._processResponse(r, this.requestOptions) })) } postJson(e, t, r = {}) { return o(this, void 0, void 0, (function* () { const n = JSON.stringify(t, null, 2); r[p.Accept] = this._getExistingOrDefaultHeader(r, p.Accept, h.ApplicationJson); r[p.ContentType] = this._getExistingOrDefaultHeader(r, p.ContentType, h.ApplicationJson); const i = yield this.post(e, n, r); return this._processResponse(i, this.requestOptions) })) } putJson(e, t, r = {}) { return o(this, void 0, void 0, (function* () { const n = JSON.stringify(t, null, 2); r[p.Accept] = this._getExistingOrDefaultHeader(r, p.Accept, h.ApplicationJson); r[p.ContentType] = this._getExistingOrDefaultHeader(r, p.ContentType, h.ApplicationJson); const i = yield this.put(e, n, r); return this._processResponse(i, this.requestOptions) })) } patchJson(e, t, r = {}) { return o(this, void 0, void 0, (function* () { const n = JSON.stringify(t, null, 2); r[p.Accept] = this._getExistingOrDefaultHeader(r, p.Accept, h.ApplicationJson); r[p.ContentType] = this._getExistingOrDefaultHeader(r, p.ContentType, h.ApplicationJson); const i = yield this.patch(e, n, r); return this._processResponse(i, this.requestOptions) })) } request(e, t, r, n) { return o(this, void 0, void 0, (function* () { if (this._disposed) { throw new Error("Client has already been disposed.") } const i = new URL(t); let s = this._prepareRequest(e, i, n); const o = this._allowRetries && y.includes(e) ? this._maxRetries + 1 : 1; let a = 0; let u; do { u = yield this.requestRaw(s, r); if (u && u.message && u.message.statusCode === d.Unauthorized) { let e; for (const t of this.handlers) { if (t.canHandleAuthentication(u)) { e = t; break } } if (e) { return e.handleAuthentication(this, s, r) } else { return u } } let t = this._maxRedirects; while (u.message.statusCode && m.includes(u.message.statusCode) && this._allowRedirects && t > 0) { const o = u.message.headers["location"]; if (!o) { break } const a = new URL(o); if (i.protocol === "https:" && i.protocol !== a.protocol && !this._allowRedirectDowngrade) { throw new Error("Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.") } yield u.readBody(); if (a.hostname !== i.hostname) { for (const e in n) { if (e.toLowerCase() === "authorization") { delete n[e] } } } s = this._prepareRequest(e, a, n); u = yield this.requestRaw(s, r); t-- } if (!u.message.statusCode || !g.includes(u.message.statusCode)) { return u } a += 1; if (a < o) { yield u.readBody(); yield this._performExponentialBackoff(a) } } while (a < o); return u })) } dispose() { if (this._agent) { this._agent.destroy() } this._disposed = true } requestRaw(e, t) { return o(this, void 0, void 0, (function* () { return new Promise(((r, n) => { function callbackForResult(e, t) { if (e) { n(e) } else if (!t) { n(new Error("Unknown error")) } else { r(t) } } this.requestRawWithCallback(e, t, callbackForResult) })) })) } requestRawWithCallback(e, t, r) { if (typeof t === "string") { if (!e.options.headers) { e.options.headers = {} } e.options.headers["Content-Length"] = Buffer.byteLength(t, "utf8") } let n = false; function handleResult(e, t) { if (!n) { n = true; r(e, t) } } const i = e.httpModule.request(e.options, (e => { const t = new HttpClientResponse(e); handleResult(undefined, t) })); let s; i.on("socket", (e => { s = e })); i.setTimeout(this._socketTimeout || 3 * 6e4, (() => { if (s) { s.end() } handleResult(new Error(`Request timeout: ${e.options.path}`)) })); i.on("error", (function (e) { handleResult(e) })); if (t && typeof t === "string") { i.write(t, "utf8") } if (t && typeof t !== "string") { t.on("close", (function () { i.end() })); t.pipe(i) } else { i.end() } } getAgent(e) { const t = new URL(e); return this._getAgent(t) } _prepareRequest(e, t, r) { const n = {}; n.parsedUrl = t; const i = n.parsedUrl.protocol === "https:"; n.httpModule = i ? u : a; const s = i ? 443 : 80; n.options = {}; n.options.host = n.parsedUrl.hostname; n.options.port = n.parsedUrl.port ? parseInt(n.parsedUrl.port) : s; n.options.path = (n.parsedUrl.pathname || "") + (n.parsedUrl.search || ""); n.options.method = e; n.options.headers = this._mergeHeaders(r); if (this.userAgent != null) { n.options.headers["user-agent"] = this.userAgent } n.options.agent = this._getAgent(n.parsedUrl); if (this.handlers) { for (const e of this.handlers) { e.prepareRequest(n.options) } } return n } _mergeHeaders(e) { if (this.requestOptions && this.requestOptions.headers) { return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(e || {})) } return lowercaseKeys(e || {}) } _getExistingOrDefaultHeader(e, t, r) { let n; if (this.requestOptions && this.requestOptions.headers) { n = lowercaseKeys(this.requestOptions.headers)[t] } return e[t] || n || r } _getAgent(e) { let t; const r = l.getProxyUrl(e); const n = r && r.hostname; if (this._keepAlive && n) { t = this._proxyAgent } if (this._keepAlive && !n) { t = this._agent } if (t) { return t } const i = e.protocol === "https:"; let s = 100; if (this.requestOptions) { s = this.requestOptions.maxSockets || a.globalAgent.maxSockets } if (r && r.hostname) { const e = { maxSockets: s, keepAlive: this._keepAlive, proxy: Object.assign(Object.assign({}, (r.username || r.password) && { proxyAuth: `${r.username}:${r.password}` }), { host: r.hostname, port: r.port }) }; let n; const o = r.protocol === "https:"; if (i) { n = o ? f.httpsOverHttps : f.httpsOverHttp } else { n = o ? f.httpOverHttps : f.httpOverHttp } t = n(e); this._proxyAgent = t } if (this._keepAlive && !t) { const e = { keepAlive: this._keepAlive, maxSockets: s }; t = i ? new u.Agent(e) : new a.Agent(e); this._agent = t } if (!t) { t = i ? u.globalAgent : a.globalAgent } if (i && this._ignoreSslError) { t.options = Object.assign(t.options || {}, { rejectUnauthorized: false }) } return t } _performExponentialBackoff(e) { return o(this, void 0, void 0, (function* () { e = Math.min(b, e); const t = _ * Math.pow(2, e); return new Promise((e => setTimeout((() => e()), t))) })) } _processResponse(e, t) { return o(this, void 0, void 0, (function* () { return new Promise(((r, n) => o(this, void 0, void 0, (function* () { const i = e.message.statusCode || 0; const s = { statusCode: i, result: null, headers: {} }; if (i === d.NotFound) { r(s) } function dateTimeDeserializer(e, t) { if (typeof t === "string") { const e = new Date(t); if (!isNaN(e.valueOf())) { return e } } return t } let o; let a; try { a = yield e.readBody(); if (a && a.length > 0) { if (t && t.deserializeDates) { o = JSON.parse(a, dateTimeDeserializer) } else { o = JSON.parse(a) } s.result = o } s.headers = e.message.headers } catch (e) { } if (i > 299) { let e; if (o && o.message) { e = o.message } else if (a && a.length > 0) { e = a } else { e = `Failed request: (${i})` } const t = new HttpClientError(e, i); t.result = s.result; n(t) } else { r(s) } })))) })) } } t.HttpClient = HttpClient; const lowercaseKeys = e => Object.keys(e).reduce(((t, r) => (t[r.toLowerCase()] = e[r], t)), {}) }, 9835: (e, t) => { Object.defineProperty(t, "__esModule", { value: true }); t.checkBypass = t.getProxyUrl = void 0; function getProxyUrl(e) { const t = e.protocol === "https:"; if (checkBypass(e)) { return undefined } const r = (() => { if (t) { return process.env["https_proxy"] || process.env["HTTPS_PROXY"] } else { return process.env["http_proxy"] || process.env["HTTP_PROXY"] } })(); if (r) { return new URL(r) } else { return undefined } } t.getProxyUrl = getProxyUrl; function checkBypass(e) { if (!e.hostname) { return false } const t = e.hostname; if (isLoopbackAddress(t)) { return true } const r = process.env["no_proxy"] || process.env["NO_PROXY"] || ""; if (!r) { return false } let n; if (e.port) { n = Number(e.port) } else if (e.protocol === "http:") { n = 80 } else if (e.protocol === "https:") { n = 443 } const i = [e.hostname.toUpperCase()]; if (typeof n === "number") { i.push(`${i[0]}:${n}`) } for (const e of r.split(",").map((e => e.trim().toUpperCase())).filter((e => e))) { if (e === "*" || i.some((t => t === e || t.endsWith(`.${e}`) || e.startsWith(".") && t.endsWith(`${e}`)))) { return true } } return false } t.checkBypass = checkBypass; function isLoopbackAddress(e) { const t = e.toLowerCase(); return t === "localhost" || t.startsWith("127.") || t.startsWith("[::1]") || t.startsWith("[0:0:0:0:0:0:0:1]") } }, 3803: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t.createFileSystemAdapter = t.FILE_SYSTEM_ADAPTER = void 0; const n = r(7147); t.FILE_SYSTEM_ADAPTER = { lstat: n.lstat, stat: n.stat, lstatSync: n.lstatSync, statSync: n.statSync, readdir: n.readdir, readdirSync: n.readdirSync }; function createFileSystemAdapter(e) { if (e === undefined) { return t.FILE_SYSTEM_ADAPTER } return Object.assign(Object.assign({}, t.FILE_SYSTEM_ADAPTER), e) } t.createFileSystemAdapter = createFileSystemAdapter }, 8838: (e, t) => { Object.defineProperty(t, "__esModule", { value: true }); t.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0; const r = process.versions.node.split("."); if (r[0] === undefined || r[1] === undefined) { throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`) } const n = Number.parseInt(r[0], 10); const i = Number.parseInt(r[1], 10); const s = 10; const o = 10; const a = n > s; const u = n === s && i >= o; t.IS_SUPPORT_READDIR_WITH_FILE_TYPES = a || u }, 5667: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t.Settings = t.scandirSync = t.scandir = void 0; const n = r(4507); const i = r(9560); const s = r(8662); t.Settings = s.default; function scandir(e, t, r) { if (typeof t === "function") { n.read(e, getSettings(), t); return } n.read(e, getSettings(t), r) } t.scandir = scandir; function scandirSync(e, t) { const r = getSettings(t); return i.read(e, r) } t.scandirSync = scandirSync; function getSettings(e = {}) { if (e instanceof s.default) { return e } return new s.default(e) } }, 4507: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t.readdir = t.readdirWithFileTypes = t.read = void 0; const n = r(109); const i = r(5288); const s = r(8838); const o = r(6297); const a = r(3847); function read(e, t, r) { if (!t.stats && s.IS_SUPPORT_READDIR_WITH_FILE_TYPES) { readdirWithFileTypes(e, t, r); return } readdir(e, t, r) } t.read = read; function readdirWithFileTypes(e, t, r) { t.fs.readdir(e, { withFileTypes: true }, ((n, s) => { if (n !== null) { callFailureCallback(r, n); return } const o = s.map((r => ({ dirent: r, name: r.name, path: a.joinPathSegments(e, r.name, t.pathSegmentSeparator) }))); if (!t.followSymbolicLinks) { callSuccessCallback(r, o); return } const u = o.map((e => makeRplTaskEntry(e, t))); i(u, ((e, t) => { if (e !== null) { callFailureCallback(r, e); return } callSuccessCallback(r, t) })) })) } t.readdirWithFileTypes = readdirWithFileTypes; function makeRplTaskEntry(e, t) { return r => { if (!e.dirent.isSymbolicLink()) { r(null, e); return } t.fs.stat(e.path, ((n, i) => { if (n !== null) { if (t.throwErrorOnBrokenSymbolicLink) { r(n); return } r(null, e); return } e.dirent = o.fs.createDirentFromStats(e.name, i); r(null, e) })) } } function readdir(e, t, r) { t.fs.readdir(e, ((s, u) => { if (s !== null) { callFailureCallback(r, s); return } const l = u.map((r => { const i = a.joinPathSegments(e, r, t.pathSegmentSeparator); return e => { n.stat(i, t.fsStatSettings, ((n, s) => { if (n !== null) { e(n); return } const a = { name: r, path: i, dirent: o.fs.createDirentFromStats(r, s) }; if (t.stats) { a.stats = s } e(null, a) })) } })); i(l, ((e, t) => { if (e !== null) { callFailureCallback(r, e); return } callSuccessCallback(r, t) })) })) } t.readdir = readdir; function callFailureCallback(e, t) { e(t) } function callSuccessCallback(e, t) { e(null, t) } }, 3847: (e, t) => { Object.defineProperty(t, "__esModule", { value: true }); t.joinPathSegments = void 0; function joinPathSegments(e, t, r) { if (e.endsWith(r)) { return e + t } return e + r + t } t.joinPathSegments = joinPathSegments }, 9560: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t.readdir = t.readdirWithFileTypes = t.read = void 0; const n = r(109); const i = r(8838); const s = r(6297); const o = r(3847); function read(e, t) { if (!t.stats && i.IS_SUPPORT_READDIR_WITH_FILE_TYPES) { return readdirWithFileTypes(e, t) } return readdir(e, t) } t.read = read; function readdirWithFileTypes(e, t) { const r = t.fs.readdirSync(e, { withFileTypes: true }); return r.map((r => { const n = { dirent: r, name: r.name, path: o.joinPathSegments(e, r.name, t.pathSegmentSeparator) }; if (n.dirent.isSymbolicLink() && t.followSymbolicLinks) { try { const e = t.fs.statSync(n.path); n.dirent = s.fs.createDirentFromStats(n.name, e) } catch (e) { if (t.throwErrorOnBrokenSymbolicLink) { throw e } } } return n })) } t.readdirWithFileTypes = readdirWithFileTypes; function readdir(e, t) { const r = t.fs.readdirSync(e); return r.map((r => { const i = o.joinPathSegments(e, r, t.pathSegmentSeparator); const a = n.statSync(i, t.fsStatSettings); const u = { name: r, path: i, dirent: s.fs.createDirentFromStats(r, a) }; if (t.stats) { u.stats = a } return u })) } t.readdir = readdir }, 8662: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); const n = r(1017); const i = r(109); const s = r(3803); class Settings { constructor(e = {}) { this._options = e; this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false); this.fs = s.createFileSystemAdapter(this._options.fs); this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, n.sep); this.stats = this._getValue(this._options.stats, false); this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true); this.fsStatSettings = new i.Settings({ followSymbolicLink: this.followSymbolicLinks, fs: this.fs, throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink }) } _getValue(e, t) { return e !== null && e !== void 0 ? e : t } } t["default"] = Settings }, 883: (e, t) => { Object.defineProperty(t, "__esModule", { value: true }); t.createDirentFromStats = void 0; class DirentFromStats { constructor(e, t) { this.name = e; this.isBlockDevice = t.isBlockDevice.bind(t); this.isCharacterDevice = t.isCharacterDevice.bind(t); this.isDirectory = t.isDirectory.bind(t); this.isFIFO = t.isFIFO.bind(t); this.isFile = t.isFile.bind(t); this.isSocket = t.isSocket.bind(t); this.isSymbolicLink = t.isSymbolicLink.bind(t) } } function createDirentFromStats(e, t) { return new DirentFromStats(e, t) } t.createDirentFromStats = createDirentFromStats }, 6297: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t.fs = void 0; const n = r(883); t.fs = n }, 2987: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t.createFileSystemAdapter = t.FILE_SYSTEM_ADAPTER = void 0; const n = r(7147); t.FILE_SYSTEM_ADAPTER = { lstat: n.lstat, stat: n.stat, lstatSync: n.lstatSync, statSync: n.statSync }; function createFileSystemAdapter(e) { if (e === undefined) { return t.FILE_SYSTEM_ADAPTER } return Object.assign(Object.assign({}, t.FILE_SYSTEM_ADAPTER), e) } t.createFileSystemAdapter = createFileSystemAdapter }, 109: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t.statSync = t.stat = t.Settings = void 0; const n = r(4147); const i = r(4527); const s = r(2410); t.Settings = s.default; function stat(e, t, r) { if (typeof t === "function") { n.read(e, getSettings(), t); return } n.read(e, getSettings(t), r) } t.stat = stat; function statSync(e, t) { const r = getSettings(t); return i.read(e, r) } t.statSync = statSync; function getSettings(e = {}) { if (e instanceof s.default) { return e } return new s.default(e) } }, 4147: (e, t) => { Object.defineProperty(t, "__esModule", { value: true }); t.read = void 0; function read(e, t, r) { t.fs.lstat(e, ((n, i) => { if (n !== null) { callFailureCallback(r, n); return } if (!i.isSymbolicLink() || !t.followSymbolicLink) { callSuccessCallback(r, i); return } t.fs.stat(e, ((e, n) => { if (e !== null) { if (t.throwErrorOnBrokenSymbolicLink) { callFailureCallback(r, e); return } callSuccessCallback(r, i); return } if (t.markSymbolicLink) { n.isSymbolicLink = () => true } callSuccessCallback(r, n) })) })) } t.read = read; function callFailureCallback(e, t) { e(t) } function callSuccessCallback(e, t) { e(null, t) } }, 4527: (e, t) => { Object.defineProperty(t, "__esModule", { value: true }); t.read = void 0; function read(e, t) { const r = t.fs.lstatSync(e); if (!r.isSymbolicLink() || !t.followSymbolicLink) { return r } try { const r = t.fs.statSync(e); if (t.markSymbolicLink) { r.isSymbolicLink = () => true } return r } catch (e) { if (!t.throwErrorOnBrokenSymbolicLink) { return r } throw e } } t.read = read }, 2410: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); const n = r(2987); class Settings { constructor(e = {}) { this._options = e; this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true); this.fs = n.createFileSystemAdapter(this._options.fs); this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false); this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true) } _getValue(e, t) { return e !== null && e !== void 0 ? e : t } } t["default"] = Settings }, 6026: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t.Settings = t.walkStream = t.walkSync = t.walk = void 0; const n = r(7523); const i = r(6737); const s = r(3068); const o = r(141); t.Settings = o.default; function walk(e, t, r) { if (typeof t === "function") { new n.default(e, getSettings()).read(t); return } new n.default(e, getSettings(t)).read(r) } t.walk = walk; function walkSync(e, t) { const r = getSettings(t); const n = new s.default(e, r); return n.read() } t.walkSync = walkSync; function walkStream(e, t) { const r = getSettings(t); const n = new i.default(e, r); return n.read() } t.walkStream = walkStream; function getSettings(e = {}) { if (e instanceof o.default) { return e } return new o.default(e) } }, 7523: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); const n = r(5732); class AsyncProvider { constructor(e, t) { this._root = e; this._settings = t; this._reader = new n.default(this._root, this._settings); this._storage = [] } read(e) { this._reader.onError((t => { callFailureCallback(e, t) })); this._reader.onEntry((e => { this._storage.push(e) })); this._reader.onEnd((() => { callSuccessCallback(e, this._storage) })); this._reader.read() } } t["default"] = AsyncProvider; function callFailureCallback(e, t) { e(t) } function callSuccessCallback(e, t) { e(null, t) } }, 6737: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); const n = r(2781); const i = r(5732); class StreamProvider { constructor(e, t) { this._root = e; this._settings = t; this._reader = new i.default(this._root, this._settings); this._stream = new n.Readable({ objectMode: true, read: () => { }, destroy: () => { if (!this._reader.isDestroyed) { this._reader.destroy() } } }) } read() { this._reader.onError((e => { this._stream.emit("error", e) })); this._reader.onEntry((e => { this._stream.push(e) })); this._reader.onEnd((() => { this._stream.push(null) })); this._reader.read(); return this._stream } } t["default"] = StreamProvider }, 3068: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); const n = r(3595); class SyncProvider { constructor(e, t) { this._root = e; this._settings = t; this._reader = new n.default(this._root, this._settings) } read() { return this._reader.read() } } t["default"] = SyncProvider }, 5732: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); const n = r(2361); const i = r(5667); const s = r(7340); const o = r(7988); const a = r(8311); class AsyncReader extends a.default { constructor(e, t) { super(e, t); this._settings = t; this._scandir = i.scandir; this._emitter = new n.EventEmitter; this._queue = s(this._worker.bind(this), this._settings.concurrency); this._isFatalError = false; this._isDestroyed = false; this._queue.drain = () => { if (!this._isFatalError) { this._emitter.emit("end") } } } read() { this._isFatalError = false; this._isDestroyed = false; setImmediate((() => { this._pushToQueue(this._root, this._settings.basePath) })); return this._emitter } get isDestroyed() { return this._isDestroyed } destroy() { if (this._isDestroyed) { throw new Error("The reader is already destroyed") } this._isDestroyed = true; this._queue.killAndDrain() } onEntry(e) { this._emitter.on("entry", e) } onError(e) { this._emitter.once("error", e) } onEnd(e) { this._emitter.once("end", e) } _pushToQueue(e, t) { const r = { directory: e, base: t }; this._queue.push(r, (e => { if (e !== null) { this._handleError(e) } })) } _worker(e, t) { this._scandir(e.directory, this._settings.fsScandirSettings, ((r, n) => { if (r !== null) { t(r, undefined); return } for (const t of n) { this._handleEntry(t, e.base) } t(null, undefined) })) } _handleError(e) { if (this._isDestroyed || !o.isFatalError(this._settings, e)) { return } this._isFatalError = true; this._isDestroyed = true; this._emitter.emit("error", e) } _handleEntry(e, t) { if (this._isDestroyed || this._isFatalError) { return } const r = e.path; if (t !== undefined) { e.path = o.joinPathSegments(t, e.name, this._settings.pathSegmentSeparator) } if (o.isAppliedFilter(this._settings.entryFilter, e)) { this._emitEntry(e) } if (e.dirent.isDirectory() && o.isAppliedFilter(this._settings.deepFilter, e)) { this._pushToQueue(r, t === undefined ? undefined : e.path) } } _emitEntry(e) { this._emitter.emit("entry", e) } } t["default"] = AsyncReader }, 7988: (e, t) => { Object.defineProperty(t, "__esModule", { value: true }); t.joinPathSegments = t.replacePathSegmentSeparator = t.isAppliedFilter = t.isFatalError = void 0; function isFatalError(e, t) { if (e.errorFilter === null) { return true } return !e.errorFilter(t) } t.isFatalError = isFatalError; function isAppliedFilter(e, t) { return e === null || e(t) } t.isAppliedFilter = isAppliedFilter; function replacePathSegmentSeparator(e, t) { return e.split(/[/\\]/).join(t) } t.replacePathSegmentSeparator = replacePathSegmentSeparator; function joinPathSegments(e, t, r) { if (e === "") { return t } if (e.endsWith(r)) { return e + t } return e + r + t } t.joinPathSegments = joinPathSegments }, 8311: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); const n = r(7988); class Reader { constructor(e, t) { this._root = e; this._settings = t; this._root = n.replacePathSegmentSeparator(e, t.pathSegmentSeparator) } } t["default"] = Reader }, 3595: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); const n = r(5667); const i = r(7988); const s = r(8311); class SyncReader extends s.default { constructor() { super(...arguments); this._scandir = n.scandirSync; this._storage = []; this._queue = new Set } read() { this._pushToQueue(this._root, this._settings.basePath); this._handleQueue(); return this._storage } _pushToQueue(e, t) { this._queue.add({ directory: e, base: t }) } _handleQueue() { for (const e of this._queue.values()) { this._handleDirectory(e.directory, e.base) } } _handleDirectory(e, t) { try { const r = this._scandir(e, this._settings.fsScandirSettings); for (const e of r) { this._handleEntry(e, t) } } catch (e) { this._handleError(e) } } _handleError(e) { if (!i.isFatalError(this._settings, e)) { return } throw e } _handleEntry(e, t) { const r = e.path; if (t !== undefined) { e.path = i.joinPathSegments(t, e.name, this._settings.pathSegmentSeparator) } if (i.isAppliedFilter(this._settings.entryFilter, e)) { this._pushToStorage(e) } if (e.dirent.isDirectory() && i.isAppliedFilter(this._settings.deepFilter, e)) { this._pushToQueue(r, t === undefined ? undefined : e.path) } } _pushToStorage(e) { this._storage.push(e) } } t["default"] = SyncReader }, 141: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); const n = r(1017); const i = r(5667); class Settings { constructor(e = {}) { this._options = e; this.basePath = this._getValue(this._options.basePath, undefined); this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY); this.deepFilter = this._getValue(this._options.deepFilter, null); this.entryFilter = this._getValue(this._options.entryFilter, null); this.errorFilter = this._getValue(this._options.errorFilter, null); this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, n.sep); this.fsScandirSettings = new i.Settings({ followSymbolicLinks: this._options.followSymbolicLinks, fs: this._options.fs, pathSegmentSeparator: this._options.pathSegmentSeparator, stats: this._options.stats, throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink }) } _getValue(e, t) { return e !== null && e !== void 0 ? e : t } } t["default"] = Settings }, 3809: (e, t, r) => { var n; n = { value: true }; const i = r(8206); i.code = 'require("ajv/dist/runtime/equal").default'; t.Z = i }, 2068: (e, t, r) => { e = r.nmd(e); const wrapAnsi16 = (e, t) => (...r) => { const n = e(...r); return `[${n + t}m` }; const wrapAnsi256 = (e, t) => (...r) => { const n = e(...r); return `[${38 + t};5;${n}m` }; const wrapAnsi16m = (e, t) => (...r) => { const n = e(...r); return `[${38 + t};2;${n[0]};${n[1]};${n[2]}m` }; const ansi2ansi = e => e; const rgb2rgb = (e, t, r) => [e, t, r]; const setLazyProperty = (e, t, r) => { Object.defineProperty(e, t, { get: () => { const n = r(); Object.defineProperty(e, t, { value: n, enumerable: true, configurable: true }); return n }, enumerable: true, configurable: true }) }; let n; const makeDynamicStyles = (e, t, i, s) => { if (n === undefined) { n = r(6931) } const o = s ? 10 : 0; const a = {}; for (const [r, s] of Object.entries(n)) { const n = r === "ansi16" ? "ansi" : r; if (r === t) { a[n] = e(i, o) } else if (typeof s === "object") { a[n] = e(s[t], o) } } return a }; function assembleStyles() { const e = new Map; const t = { modifier: { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29] }, color: { black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], blackBright: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39] }, bgColor: { bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49] } }; t.color.gray = t.color.blackBright; t.bgColor.bgGray = t.bgColor.bgBlackBright; t.color.grey = t.color.blackBright; t.bgColor.bgGrey = t.bgColor.bgBlackBright; for (const [r, n] of Object.entries(t)) { for (const [r, i] of Object.entries(n)) { t[r] = { open: `[${i[0]}m`, close: `[${i[1]}m` }; n[r] = t[r]; e.set(i[0], i[1]) } Object.defineProperty(t, r, { value: n, enumerable: false }) } Object.defineProperty(t, "codes", { value: e, enumerable: false }); t.color.close = "[39m"; t.bgColor.close = "[49m"; setLazyProperty(t.color, "ansi", (() => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false))); setLazyProperty(t.color, "ansi256", (() => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false))); setLazyProperty(t.color, "ansi16m", (() => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false))); setLazyProperty(t.bgColor, "ansi", (() => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true))); setLazyProperty(t.bgColor, "ansi256", (() => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true))); setLazyProperty(t.bgColor, "ansi16m", (() => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true))); return t } Object.defineProperty(e, "exports", { enumerable: true, get: assembleStyles }) }, 8287: e => { const t = "[\ud800-\udbff][\udc00-\udfff]"; const astralRegex = e => e && e.exact ? new RegExp(`^${t}$`) : new RegExp(t, "g"); e.exports = astralRegex }, 8380: e => {
    /*!
     * async
     * https://github.com/caolan/async
     *
     * Copyright 2010-2014 Caolan McMahon
     * Released under the MIT license
     */
    (function () { var t = {}; function noop() { } function identity(e) { return e } function toBool(e) { return !!e } function notId(e) { return !e } var r; var n = typeof self === "object" && self.self === self && self || typeof global === "object" && global.global === global && global || this; if (n != null) { r = n.async } t.noConflict = function () { n.async = r; return t }; function only_once(e) { return function () { if (e === null) throw new Error("Callback was already called."); e.apply(this, arguments); e = null } } function _once(e) { return function () { if (e === null) return; e.apply(this, arguments); e = null } } var i = Object.prototype.toString; var s = Array.isArray || function (e) { return i.call(e) === "[object Array]" }; var _isObject = function (e) { var t = typeof e; return t === "function" || t === "object" && !!e }; function _isArrayLike(e) { return s(e) || typeof e.length === "number" && e.length >= 0 && e.length % 1 === 0 } function _arrayEach(e, t) { var r = -1, n = e.length; while (++r < n) { t(e[r], r, e) } } function _map(e, t) { var r = -1, n = e.length, i = Array(n); while (++r < n) { i[r] = t(e[r], r, e) } return i } function _range(e) { return _map(Array(e), (function (e, t) { return t })) } function _reduce(e, t, r) { _arrayEach(e, (function (e, n, i) { r = t(r, e, n, i) })); return r } function _forEachOf(e, t) { _arrayEach(o(e), (function (r) { t(e[r], r) })) } function _indexOf(e, t) { for (var r = 0; r < e.length; r++) { if (e[r] === t) return r } return -1 } var o = Object.keys || function (e) { var t = []; for (var r in e) { if (e.hasOwnProperty(r)) { t.push(r) } } return t }; function _keyIterator(e) { var t = -1; var r; var n; if (_isArrayLike(e)) { r = e.length; return function next() { t++; return t < r ? t : null } } else { n = o(e); r = n.length; return function next() { t++; return t < r ? n[t] : null } } } function _restParam(e, t) { t = t == null ? e.length - 1 : +t; return function () { var r = Math.max(arguments.length - t, 0); var n = Array(r); for (var i = 0; i < r; i++) { n[i] = arguments[i + t] } switch (t) { case 0: return e.call(this, n); case 1: return e.call(this, arguments[0], n) } } } function _withoutIndex(e) { return function (t, r, n) { return e(t, n) } } var a = typeof setImmediate === "function" && setImmediate; var u = a ? function (e) { a(e) } : function (e) { setTimeout(e, 0) }; if (typeof process === "object" && typeof process.nextTick === "function") { t.nextTick = process.nextTick } else { t.nextTick = u } t.setImmediate = a ? u : t.nextTick; t.forEach = t.each = function (e, r, n) { return t.eachOf(e, _withoutIndex(r), n) }; t.forEachSeries = t.eachSeries = function (e, r, n) { return t.eachOfSeries(e, _withoutIndex(r), n) }; t.forEachLimit = t.eachLimit = function (e, t, r, n) { return _eachOfLimit(t)(e, _withoutIndex(r), n) }; t.forEachOf = t.eachOf = function (e, t, r) { r = _once(r || noop); e = e || []; var n = _keyIterator(e); var i, s = 0; while ((i = n()) != null) { s += 1; t(e[i], i, only_once(done)) } if (s === 0) r(null); function done(e) { s--; if (e) { r(e) } else if (i === null && s <= 0) { r(null) } } }; t.forEachOfSeries = t.eachOfSeries = function (e, r, n) { n = _once(n || noop); e = e || []; var i = _keyIterator(e); var s = i(); function iterate() { var o = true; if (s === null) { return n(null) } r(e[s], s, only_once((function (e) { if (e) { n(e) } else { s = i(); if (s === null) { return n(null) } else { if (o) { t.setImmediate(iterate) } else { iterate() } } } }))); o = false } iterate() }; t.forEachOfLimit = t.eachOfLimit = function (e, t, r, n) { _eachOfLimit(t)(e, r, n) }; function _eachOfLimit(e) { return function (t, r, n) { n = _once(n || noop); t = t || []; var i = _keyIterator(t); if (e <= 0) { return n(null) } var s = false; var o = 0; var a = false; (function replenish() { if (s && o <= 0) { return n(null) } while (o < e && !a) { var u = i(); if (u === null) { s = true; if (o <= 0) { n(null) } return } o += 1; r(t[u], u, only_once((function (e) { o -= 1; if (e) { n(e); a = true } else { replenish() } }))) } })() } } function doParallel(e) { return function (r, n, i) { return e(t.eachOf, r, n, i) } } function doParallelLimit(e) { return function (t, r, n, i) { return e(_eachOfLimit(r), t, n, i) } } function doSeries(e) { return function (r, n, i) { return e(t.eachOfSeries, r, n, i) } } function _asyncMap(e, t, r, n) { n = _once(n || noop); t = t || []; var i = _isArrayLike(t) ? [] : {}; e(t, (function (e, t, n) { r(e, (function (e, r) { i[t] = r; n(e) })) }), (function (e) { n(e, i) })) } t.map = doParallel(_asyncMap); t.mapSeries = doSeries(_asyncMap); t.mapLimit = doParallelLimit(_asyncMap); t.inject = t.foldl = t.reduce = function (e, r, n, i) { t.eachOfSeries(e, (function (e, t, i) { n(r, e, (function (e, t) { r = t; i(e) })) }), (function (e) { i(e, r) })) }; t.foldr = t.reduceRight = function (e, r, n, i) { var s = _map(e, identity).reverse(); t.reduce(s, r, n, i) }; t.transform = function (e, r, n, i) { if (arguments.length === 3) { i = n; n = r; r = s(e) ? [] : {} } t.eachOf(e, (function (e, t, i) { n(r, e, t, i) }), (function (e) { i(e, r) })) }; function _filter(e, t, r, n) { var i = []; e(t, (function (e, t, n) { r(e, (function (r) { if (r) { i.push({ index: t, value: e }) } n() })) }), (function () { n(_map(i.sort((function (e, t) { return e.index - t.index })), (function (e) { return e.value }))) })) } t.select = t.filter = doParallel(_filter); t.selectLimit = t.filterLimit = doParallelLimit(_filter); t.selectSeries = t.filterSeries = doSeries(_filter); function _reject(e, t, r, n) { _filter(e, t, (function (e, t) { r(e, (function (e) { t(!e) })) }), n) } t.reject = doParallel(_reject); t.rejectLimit = doParallelLimit(_reject); t.rejectSeries = doSeries(_reject); function _createTester(e, t, r) { return function (n, i, s, o) { function done() { if (o) o(r(false, void 0)) } function iteratee(e, n, i) { if (!o) return i(); s(e, (function (n) { if (o && t(n)) { o(r(true, e)); o = s = false } i() })) } if (arguments.length > 3) { e(n, i, iteratee, done) } else { o = s; s = i; e(n, iteratee, done) } } } t.any = t.some = _createTester(t.eachOf, toBool, identity); t.someLimit = _createTester(t.eachOfLimit, toBool, identity); t.all = t.every = _createTester(t.eachOf, notId, notId); t.everyLimit = _createTester(t.eachOfLimit, notId, notId); function _findGetResult(e, t) { return t } t.detect = _createTester(t.eachOf, identity, _findGetResult); t.detectSeries = _createTester(t.eachOfSeries, identity, _findGetResult); t.detectLimit = _createTester(t.eachOfLimit, identity, _findGetResult); t.sortBy = function (e, r, n) { t.map(e, (function (e, t) { r(e, (function (r, n) { if (r) { t(r) } else { t(null, { value: e, criteria: n }) } })) }), (function (e, t) { if (e) { return n(e) } else { n(null, _map(t.sort(comparator), (function (e) { return e.value }))) } })); function comparator(e, t) { var r = e.criteria, n = t.criteria; return r < n ? -1 : r > n ? 1 : 0 } }; t.auto = function (e, r, n) { if (typeof arguments[1] === "function") { n = r; r = null } n = _once(n || noop); var i = o(e); var a = i.length; if (!a) { return n(null) } if (!r) { r = a } var u = {}; var l = 0; var f = false; var d = []; function addListener(e) { d.unshift(e) } function removeListener(e) { var t = _indexOf(d, e); if (t >= 0) d.splice(t, 1) } function taskComplete() { a--; _arrayEach(d.slice(0), (function (e) { e() })) } addListener((function () { if (!a) { n(null, u) } })); _arrayEach(i, (function (i) { if (f) return; var o = s(e[i]) ? e[i] : [e[i]]; var a = _restParam((function (e, r) { l--; if (r.length <= 1) { r = r[0] } if (e) { var s = {}; _forEachOf(u, (function (e, t) { s[t] = e })); s[i] = r; f = true; n(e, s) } else { u[i] = r; t.setImmediate(taskComplete) } })); var d = o.slice(0, o.length - 1); var p = d.length; var h; while (p--) { if (!(h = e[d[p]])) { throw new Error("Has nonexistent dependency in " + d.join(", ")) } if (s(h) && _indexOf(h, i) >= 0) { throw new Error("Has cyclic dependencies") } } function ready() { return l < r && _reduce(d, (function (e, t) { return e && u.hasOwnProperty(t) }), true) && !u.hasOwnProperty(i) } if (ready()) { l++; o[o.length - 1](a, u) } else { addListener(listener) } function listener() { if (ready()) { l++; removeListener(listener); o[o.length - 1](a, u) } } })) }; t.retry = function (e, r, n) { var i = 5; var s = 0; var o = []; var a = { times: i, interval: s }; function parseTimes(e, t) { if (typeof t === "number") { e.times = parseInt(t, 10) || i } else if (typeof t === "object") { e.times = parseInt(t.times, 10) || i; e.interval = parseInt(t.interval, 10) || s } else { throw new Error("Unsupported argument type for 'times': " + typeof t) } } var u = arguments.length; if (u < 1 || u > 3) { throw new Error("Invalid arguments - must be either (task), (task, callback), (times, task) or (times, task, callback)") } else if (u <= 2 && typeof e === "function") { n = r; r = e } if (typeof e !== "function") { parseTimes(a, e) } a.callback = n; a.task = r; function wrappedTask(e, r) { function retryAttempt(e, t) { return function (n) { e((function (e, r) { n(!e || t, { err: e, result: r }) }), r) } } function retryInterval(e) { return function (t) { setTimeout((function () { t(null) }), e) } } while (a.times) { var n = !(a.times -= 1); o.push(retryAttempt(a.task, n)); if (!n && a.interval > 0) { o.push(retryInterval(a.interval)) } } t.series(o, (function (t, r) { r = r[r.length - 1]; (e || a.callback)(r.err, r.result) })) } return a.callback ? wrappedTask() : wrappedTask }; t.waterfall = function (e, r) { r = _once(r || noop); if (!s(e)) { var n = new Error("First argument to waterfall must be an array of functions"); return r(n) } if (!e.length) { return r() } function wrapIterator(e) { return _restParam((function (t, n) { if (t) { r.apply(null, [t].concat(n)) } else { var i = e.next(); if (i) { n.push(wrapIterator(i)) } else { n.push(r) } ensureAsync(e).apply(null, n) } })) } wrapIterator(t.iterator(e))() }; function _parallel(e, t, r) { r = r || noop; var n = _isArrayLike(t) ? [] : {}; e(t, (function (e, t, r) { e(_restParam((function (e, i) { if (i.length <= 1) { i = i[0] } n[t] = i; r(e) }))) }), (function (e) { r(e, n) })) } t.parallel = function (e, r) { _parallel(t.eachOf, e, r) }; t.parallelLimit = function (e, t, r) { _parallel(_eachOfLimit(t), e, r) }; t.series = function (e, r) { _parallel(t.eachOfSeries, e, r) }; t.iterator = function (e) { function makeCallback(t) { function fn() { if (e.length) { e[t].apply(null, arguments) } return fn.next() } fn.next = function () { return t < e.length - 1 ? makeCallback(t + 1) : null }; return fn } return makeCallback(0) }; t.apply = _restParam((function (e, t) { return _restParam((function (r) { return e.apply(null, t.concat(r)) })) })); function _concat(e, t, r, n) { var i = []; e(t, (function (e, t, n) { r(e, (function (e, t) { i = i.concat(t || []); n(e) })) }), (function (e) { n(e, i) })) } t.concat = doParallel(_concat); t.concatSeries = doSeries(_concat); t.whilst = function (e, t, r) { r = r || noop; if (e()) { var n = _restParam((function (i, s) { if (i) { r(i) } else if (e.apply(this, s)) { t(n) } else { r.apply(null, [null].concat(s)) } })); t(n) } else { r(null) } }; t.doWhilst = function (e, r, n) { var i = 0; return t.whilst((function () { return ++i <= 1 || r.apply(this, arguments) }), e, n) }; t.until = function (e, r, n) { return t.whilst((function () { return !e.apply(this, arguments) }), r, n) }; t.doUntil = function (e, r, n) { return t.doWhilst(e, (function () { return !r.apply(this, arguments) }), n) }; t.during = function (e, t, r) { r = r || noop; var n = _restParam((function (t, n) { if (t) { r(t) } else { n.push(check); e.apply(this, n) } })); var check = function (e, i) { if (e) { r(e) } else if (i) { t(n) } else { r(null) } }; e(check) }; t.doDuring = function (e, r, n) { var i = 0; t.during((function (e) { if (i++ < 1) { e(null, true) } else { r.apply(this, arguments) } }), e, n) }; function _queue(e, r, n) { if (r == null) { r = 1 } else if (r === 0) { throw new Error("Concurrency must not be zero") } function _insert(e, r, n, i) { if (i != null && typeof i !== "function") { throw new Error("task callback must be a function") } e.started = true; if (!s(r)) { r = [r] } if (r.length === 0 && e.idle()) { return t.setImmediate((function () { e.drain() })) } _arrayEach(r, (function (t) { var r = { data: t, callback: i || noop }; if (n) { e.tasks.unshift(r) } else { e.tasks.push(r) } if (e.tasks.length === e.concurrency) { e.saturated() } })); t.setImmediate(e.process) } function _next(e, t) { return function () { i -= 1; var r = false; var n = arguments; _arrayEach(t, (function (e) { _arrayEach(o, (function (t, n) { if (t === e && !r) { o.splice(n, 1); r = true } })); e.callback.apply(e, n) })); if (e.tasks.length + i === 0) { e.drain() } e.process() } } var i = 0; var o = []; var a = { tasks: [], concurrency: r, payload: n, saturated: noop, empty: noop, drain: noop, started: false, paused: false, push: function (e, t) { _insert(a, e, false, t) }, kill: function () { a.drain = noop; a.tasks = [] }, unshift: function (e, t) { _insert(a, e, true, t) }, process: function () { while (!a.paused && i < a.concurrency && a.tasks.length) { var t = a.payload ? a.tasks.splice(0, a.payload) : a.tasks.splice(0, a.tasks.length); var r = _map(t, (function (e) { return e.data })); if (a.tasks.length === 0) { a.empty() } i += 1; o.push(t[0]); var n = only_once(_next(a, t)); e(r, n) } }, length: function () { return a.tasks.length }, running: function () { return i }, workersList: function () { return o }, idle: function () { return a.tasks.length + i === 0 }, pause: function () { a.paused = true }, resume: function () { if (a.paused === false) { return } a.paused = false; var e = Math.min(a.concurrency, a.tasks.length); for (var r = 1; r <= e; r++) { t.setImmediate(a.process) } } }; return a } t.queue = function (e, t) { var r = _queue((function (t, r) { e(t[0], r) }), t, 1); return r }; t.priorityQueue = function (e, r) { function _compareTasks(e, t) { return e.priority - t.priority } function _binarySearch(e, t, r) { var n = -1, i = e.length - 1; while (n < i) { var s = n + (i - n + 1 >>> 1); if (r(t, e[s]) >= 0) { n = s } else { i = s - 1 } } return n } function _insert(e, r, n, i) { if (i != null && typeof i !== "function") { throw new Error("task callback must be a function") } e.started = true; if (!s(r)) { r = [r] } if (r.length === 0) { return t.setImmediate((function () { e.drain() })) } _arrayEach(r, (function (r) { var s = { data: r, priority: n, callback: typeof i === "function" ? i : noop }; e.tasks.splice(_binarySearch(e.tasks, s, _compareTasks) + 1, 0, s); if (e.tasks.length === e.concurrency) { e.saturated() } t.setImmediate(e.process) })) } var n = t.queue(e, r); n.push = function (e, t, r) { _insert(n, e, t, r) }; delete n.unshift; return n }; t.cargo = function (e, t) { return _queue(e, 1, t) }; function _console_fn(e) { return _restParam((function (t, r) { t.apply(null, r.concat([_restParam((function (t, r) { if (typeof console === "object") { if (t) { if (console.error) { console.error(t) } } else if (console[e]) { _arrayEach(r, (function (t) { console[e](t) })) } } }))])) })) } t.log = _console_fn("log"); t.dir = _console_fn("dir"); t.memoize = function (e, r) { var n = {}; var i = {}; var s = Object.prototype.hasOwnProperty; r = r || identity; var o = _restParam((function memoized(o) { var a = o.pop(); var u = r.apply(null, o); if (s.call(n, u)) { t.setImmediate((function () { a.apply(null, n[u]) })) } else if (s.call(i, u)) { i[u].push(a) } else { i[u] = [a]; e.apply(null, o.concat([_restParam((function (e) { n[u] = e; var t = i[u]; delete i[u]; for (var r = 0, s = t.length; r < s; r++) { t[r].apply(null, e) } }))])) } })); o.memo = n; o.unmemoized = e; return o }; t.unmemoize = function (e) { return function () { return (e.unmemoized || e).apply(null, arguments) } }; function _times(e) { return function (t, r, n) { e(_range(t), r, n) } } t.times = _times(t.map); t.timesSeries = _times(t.mapSeries); t.timesLimit = function (e, r, n, i) { return t.mapLimit(_range(e), r, n, i) }; t.seq = function () { var e = arguments; return _restParam((function (r) { var n = this; var i = r[r.length - 1]; if (typeof i == "function") { r.pop() } else { i = noop } t.reduce(e, r, (function (e, t, r) { t.apply(n, e.concat([_restParam((function (e, t) { r(e, t) }))])) }), (function (e, t) { i.apply(n, [e].concat(t)) })) })) }; t.compose = function () { return t.seq.apply(null, Array.prototype.reverse.call(arguments)) }; function _applyEach(e) { return _restParam((function (t, r) { var n = _restParam((function (r) { var n = this; var i = r.pop(); return e(t, (function (e, t, i) { e.apply(n, r.concat([i])) }), i) })); if (r.length) { return n.apply(this, r) } else { return n } })) } t.applyEach = _applyEach(t.eachOf); t.applyEachSeries = _applyEach(t.eachOfSeries); t.forever = function (e, t) { var r = only_once(t || noop); var n = ensureAsync(e); function next(e) { if (e) { return r(e) } n(next) } next() }; function ensureAsync(e) { return _restParam((function (r) { var n = r.pop(); r.push((function () { var e = arguments; if (i) { t.setImmediate((function () { n.apply(null, e) })) } else { n.apply(null, e) } })); var i = true; e.apply(this, r); i = false })) } t.ensureAsync = ensureAsync; t.constant = _restParam((function (e) { var t = [null].concat(e); return function (e) { return e.apply(this, t) } })); t.wrapSync = t.asyncify = function asyncify(e) { return _restParam((function (t) { var r = t.pop(); var n; try { n = e.apply(this, t) } catch (e) { return r(e) } if (_isObject(n) && typeof n.then === "function") { n.then((function (e) { r(null, e) }))["catch"]((function (e) { r(e.message ? e : new Error(e)) })) } else { r(null, n) } })) }; if (true && e.exports) { e.exports = t } else if (typeof define === "function" && define.amd) { define([], (function () { return t })) } else { n.async = t } })()
  }, 2344: (e, t, r) => { const { Buffer: n } = r(4300); const i = Symbol.for("BufferList"); function BufferList(e) { if (!(this instanceof BufferList)) { return new BufferList(e) } BufferList._init.call(this, e) } BufferList._init = function _init(e) { Object.defineProperty(this, i, { value: true }); this._bufs = []; this.length = 0; if (e) { this.append(e) } }; BufferList.prototype._new = function _new(e) { return new BufferList(e) }; BufferList.prototype._offset = function _offset(e) { if (e === 0) { return [0, 0] } let t = 0; for (let r = 0; r < this._bufs.length; r++) { const n = t + this._bufs[r].length; if (e < n || r === this._bufs.length - 1) { return [r, e - t] } t = n } }; BufferList.prototype._reverseOffset = function (e) { const t = e[0]; let r = e[1]; for (let e = 0; e < t; e++) { r += this._bufs[e].length } return r }; BufferList.prototype.get = function get(e) { if (e > this.length || e < 0) { return undefined } const t = this._offset(e); return this._bufs[t[0]][t[1]] }; BufferList.prototype.slice = function slice(e, t) { if (typeof e === "number" && e < 0) { e += this.length } if (typeof t === "number" && t < 0) { t += this.length } return this.copy(null, 0, e, t) }; BufferList.prototype.copy = function copy(e, t, r, i) { if (typeof r !== "number" || r < 0) { r = 0 } if (typeof i !== "number" || i > this.length) { i = this.length } if (r >= this.length) { return e || n.alloc(0) } if (i <= 0) { return e || n.alloc(0) } const copy = !!e; const s = this._offset(r); const o = i - r; let a = o; let u = copy && t || 0; let l = s[1]; if (r === 0 && i === this.length) { if (!copy) { return this._bufs.length === 1 ? this._bufs[0] : n.concat(this._bufs, this.length) } for (let t = 0; t < this._bufs.length; t++) { this._bufs[t].copy(e, u); u += this._bufs[t].length } return e } if (a <= this._bufs[s[0]].length - l) { return copy ? this._bufs[s[0]].copy(e, t, l, l + a) : this._bufs[s[0]].slice(l, l + a) } if (!copy) { e = n.allocUnsafe(o) } for (let t = s[0]; t < this._bufs.length; t++) { const r = this._bufs[t].length - l; if (a > r) { this._bufs[t].copy(e, u, l); u += r } else { this._bufs[t].copy(e, u, l, l + a); u += r; break } a -= r; if (l) { l = 0 } } if (e.length > u) return e.slice(0, u); return e }; BufferList.prototype.shallowSlice = function shallowSlice(e, t) { e = e || 0; t = typeof t !== "number" ? this.length : t; if (e < 0) { e += this.length } if (t < 0) { t += this.length } if (e === t) { return this._new() } const r = this._offset(e); const n = this._offset(t); const i = this._bufs.slice(r[0], n[0] + 1); if (n[1] === 0) { i.pop() } else { i[i.length - 1] = i[i.length - 1].slice(0, n[1]) } if (r[1] !== 0) { i[0] = i[0].slice(r[1]) } return this._new(i) }; BufferList.prototype.toString = function toString(e, t, r) { return this.slice(t, r).toString(e) }; BufferList.prototype.consume = function consume(e) { e = Math.trunc(e); if (Number.isNaN(e) || e <= 0) return this; while (this._bufs.length) { if (e >= this._bufs[0].length) { e -= this._bufs[0].length; this.length -= this._bufs[0].length; this._bufs.shift() } else { this._bufs[0] = this._bufs[0].slice(e); this.length -= e; break } } return this }; BufferList.prototype.duplicate = function duplicate() { const e = this._new(); for (let t = 0; t < this._bufs.length; t++) { e.append(this._bufs[t]) } return e }; BufferList.prototype.append = function append(e) { if (e == null) { return this } if (e.buffer) { this._appendBuffer(n.from(e.buffer, e.byteOffset, e.byteLength)) } else if (Array.isArray(e)) { for (let t = 0; t < e.length; t++) { this.append(e[t]) } } else if (this._isBufferList(e)) { for (let t = 0; t < e._bufs.length; t++) { this.append(e._bufs[t]) } } else { if (typeof e === "number") { e = e.toString() } this._appendBuffer(n.from(e)) } return this }; BufferList.prototype._appendBuffer = function appendBuffer(e) { this._bufs.push(e); this.length += e.length }; BufferList.prototype.indexOf = function (e, t, r) { if (r === undefined && typeof t === "string") { r = t; t = undefined } if (typeof e === "function" || Array.isArray(e)) { throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.') } else if (typeof e === "number") { e = n.from([e]) } else if (typeof e === "string") { e = n.from(e, r) } else if (this._isBufferList(e)) { e = e.slice() } else if (Array.isArray(e.buffer)) { e = n.from(e.buffer, e.byteOffset, e.byteLength) } else if (!n.isBuffer(e)) { e = n.from(e) } t = Number(t || 0); if (isNaN(t)) { t = 0 } if (t < 0) { t = this.length + t } if (t < 0) { t = 0 } if (e.length === 0) { return t > this.length ? this.length : t } const i = this._offset(t); let s = i[0]; let o = i[1]; for (; s < this._bufs.length; s++) { const t = this._bufs[s]; while (o < t.length) { const r = t.length - o; if (r >= e.length) { const r = t.indexOf(e, o); if (r !== -1) { return this._reverseOffset([s, r]) } o = t.length - e.length + 1 } else { const t = this._reverseOffset([s, o]); if (this._match(t, e)) { return t } o++ } } o = 0 } return -1 }; BufferList.prototype._match = function (e, t) { if (this.length - e < t.length) { return false } for (let r = 0; r < t.length; r++) { if (this.get(e + r) !== t[r]) { return false } } return true }; (function () { const e = { readDoubleBE: 8, readDoubleLE: 8, readFloatBE: 4, readFloatLE: 4, readInt32BE: 4, readInt32LE: 4, readUInt32BE: 4, readUInt32LE: 4, readInt16BE: 2, readInt16LE: 2, readUInt16BE: 2, readUInt16LE: 2, readInt8: 1, readUInt8: 1, readIntBE: null, readIntLE: null, readUIntBE: null, readUIntLE: null }; for (const t in e) { (function (t) { if (e[t] === null) { BufferList.prototype[t] = function (e, r) { return this.slice(e, e + r)[t](0, r) } } else { BufferList.prototype[t] = function (r = 0) { return this.slice(r, r + e[t])[t](0) } } })(t) } })(); BufferList.prototype._isBufferList = function _isBufferList(e) { return e instanceof BufferList || BufferList.isBufferList(e) }; BufferList.isBufferList = function isBufferList(e) { return e != null && e[i] }; e.exports = BufferList }, 336: (e, t, r) => { const n = r(1642).Duplex; const i = r(4124); const s = r(2344); function BufferListStream(e) { if (!(this instanceof BufferListStream)) { return new BufferListStream(e) } if (typeof e === "function") { this._callback = e; const t = function piper(e) { if (this._callback) { this._callback(e); this._callback = null } }.bind(this); this.on("pipe", (function onPipe(e) { e.on("error", t) })); this.on("unpipe", (function onUnpipe(e) { e.removeListener("error", t) })); e = null } s._init.call(this, e); n.call(this) } i(BufferListStream, n); Object.assign(BufferListStream.prototype, s.prototype); BufferListStream.prototype._new = function _new(e) { return new BufferListStream(e) }; BufferListStream.prototype._write = function _write(e, t, r) { this._appendBuffer(e); if (typeof r === "function") { r() } }; BufferListStream.prototype._read = function _read(e) { if (!this.length) { return this.push(null) } e = Math.min(e, this.length); this.push(this.slice(0, e)); this.consume(e) }; BufferListStream.prototype.end = function end(e) { n.prototype.end.call(this, e); if (this._callback) { this._callback(null, this.slice()); this._callback = null } }; BufferListStream.prototype._destroy = function _destroy(e, t) { this._bufs.length = 0; this.length = 0; t(e) }; BufferListStream.prototype._isBufferList = function _isBufferList(e) { return e instanceof BufferListStream || e instanceof s || BufferListStream.isBufferList(e) }; BufferListStream.isBufferList = s.isBufferList; e.exports = BufferListStream; e.exports.BufferListStream = BufferListStream; e.exports.BufferList = s }, 610: (e, t, r) => { const n = r(8750); const i = r(9434); const s = r(5873); const o = r(6477); const braces = (e, t = {}) => { let r = []; if (Array.isArray(e)) { for (let n of e) { let e = braces.create(n, t); if (Array.isArray(e)) { r.push(...e) } else { r.push(e) } } } else { r = [].concat(braces.create(e, t)) } if (t && t.expand === true && t.nodupes === true) { r = [...new Set(r)] } return r }; braces.parse = (e, t = {}) => o(e, t); braces.stringify = (e, t = {}) => { if (typeof e === "string") { return n(braces.parse(e, t), t) } return n(e, t) }; braces.compile = (e, t = {}) => { if (typeof e === "string") { e = braces.parse(e, t) } return i(e, t) }; braces.expand = (e, t = {}) => { if (typeof e === "string") { e = braces.parse(e, t) } let r = s(e, t); if (t.noempty === true) { r = r.filter(Boolean) } if (t.nodupes === true) { r = [...new Set(r)] } return r }; braces.create = (e, t = {}) => { if (e === "" || e.length < 3) { return [e] } return t.expand !== true ? braces.compile(e, t) : braces.expand(e, t) }; e.exports = braces }, 9434: (e, t, r) => { const n = r(6330); const i = r(5207); const compile = (e, t = {}) => { let walk = (e, r = {}) => { let s = i.isInvalidBrace(r); let o = e.invalid === true && t.escapeInvalid === true; let a = s === true || o === true; let u = t.escapeInvalid === true ? "\\" : ""; let l = ""; if (e.isOpen === true) { return u + e.value } if (e.isClose === true) { return u + e.value } if (e.type === "open") { return a ? u + e.value : "(" } if (e.type === "close") { return a ? u + e.value : ")" } if (e.type === "comma") { return e.prev.type === "comma" ? "" : a ? e.value : "|" } if (e.value) { return e.value } if (e.nodes && e.ranges > 0) { let r = i.reduce(e.nodes); let s = n(...r, { ...t, wrap: false, toRegex: true }); if (s.length !== 0) { return r.length > 1 && s.length > 1 ? `(${s})` : s } } if (e.nodes) { for (let t of e.nodes) { l += walk(t, e) } } return l }; return walk(e) }; e.exports = compile }, 8774: e => { e.exports = { MAX_LENGTH: 1024 * 64, CHAR_0: "0", CHAR_9: "9", CHAR_UPPERCASE_A: "A", CHAR_LOWERCASE_A: "a", CHAR_UPPERCASE_Z: "Z", CHAR_LOWERCASE_Z: "z", CHAR_LEFT_PARENTHESES: "(", CHAR_RIGHT_PARENTHESES: ")", CHAR_ASTERISK: "*", CHAR_AMPERSAND: "&", CHAR_AT: "@", CHAR_BACKSLASH: "\\", CHAR_BACKTICK: "`", CHAR_CARRIAGE_RETURN: "\r", CHAR_CIRCUMFLEX_ACCENT: "^", CHAR_COLON: ":", CHAR_COMMA: ",", CHAR_DOLLAR: "$", CHAR_DOT: ".", CHAR_DOUBLE_QUOTE: '"', CHAR_EQUAL: "=", CHAR_EXCLAMATION_MARK: "!", CHAR_FORM_FEED: "\f", CHAR_FORWARD_SLASH: "/", CHAR_HASH: "#", CHAR_HYPHEN_MINUS: "-", CHAR_LEFT_ANGLE_BRACKET: "<", CHAR_LEFT_CURLY_BRACE: "{", CHAR_LEFT_SQUARE_BRACKET: "[", CHAR_LINE_FEED: "\n", CHAR_NO_BREAK_SPACE: " ", CHAR_PERCENT: "%", CHAR_PLUS: "+", CHAR_QUESTION_MARK: "?", CHAR_RIGHT_ANGLE_BRACKET: ">", CHAR_RIGHT_CURLY_BRACE: "}", CHAR_RIGHT_SQUARE_BRACKET: "]", CHAR_SEMICOLON: ";", CHAR_SINGLE_QUOTE: "'", CHAR_SPACE: " ", CHAR_TAB: "\t", CHAR_UNDERSCORE: "_", CHAR_VERTICAL_LINE: "|", CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\ufeff" } }, 5873: (e, t, r) => { const n = r(6330); const i = r(8750); const s = r(5207); const append = (e = "", t = "", r = false) => { let n = []; e = [].concat(e); t = [].concat(t); if (!t.length) return e; if (!e.length) { return r ? s.flatten(t).map((e => `{${e}}`)) : t } for (let i of e) { if (Array.isArray(i)) { for (let e of i) { n.push(append(e, t, r)) } } else { for (let e of t) { if (r === true && typeof e === "string") e = `{${e}}`; n.push(Array.isArray(e) ? append(i, e, r) : i + e) } } } return s.flatten(n) }; const expand = (e, t = {}) => { let r = t.rangeLimit === void 0 ? 1e3 : t.rangeLimit; let walk = (e, o = {}) => { e.queue = []; let a = o; let u = o.queue; while (a.type !== "brace" && a.type !== "root" && a.parent) { a = a.parent; u = a.queue } if (e.invalid || e.dollar) { u.push(append(u.pop(), i(e, t))); return } if (e.type === "brace" && e.invalid !== true && e.nodes.length === 2) { u.push(append(u.pop(), ["{}"])); return } if (e.nodes && e.ranges > 0) { let o = s.reduce(e.nodes); if (s.exceedsLimit(...o, t.step, r)) { throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.") } let a = n(...o, t); if (a.length === 0) { a = i(e, t) } u.push(append(u.pop(), a)); e.nodes = []; return } let l = s.encloseBrace(e); let f = e.queue; let d = e; while (d.type !== "brace" && d.type !== "root" && d.parent) { d = d.parent; f = d.queue } for (let t = 0; t < e.nodes.length; t++) { let r = e.nodes[t]; if (r.type === "comma" && e.type === "brace") { if (t === 1) f.push(""); f.push(""); continue } if (r.type === "close") { u.push(append(u.pop(), f, l)); continue } if (r.value && r.type !== "open") { f.push(append(f.pop(), r.value)); continue } if (r.nodes) { walk(r, e) } } return f }; return s.flatten(walk(e)) }; e.exports = expand }, 6477: (e, t, r) => { const n = r(8750); const { MAX_LENGTH: i, CHAR_BACKSLASH: s, CHAR_BACKTICK: o, CHAR_COMMA: a, CHAR_DOT: u, CHAR_LEFT_PARENTHESES: l, CHAR_RIGHT_PARENTHESES: f, CHAR_LEFT_CURLY_BRACE: d, CHAR_RIGHT_CURLY_BRACE: p, CHAR_LEFT_SQUARE_BRACKET: h, CHAR_RIGHT_SQUARE_BRACKET: m, CHAR_DOUBLE_QUOTE: g, CHAR_SINGLE_QUOTE: y, CHAR_NO_BREAK_SPACE: b, CHAR_ZERO_WIDTH_NOBREAK_SPACE: _ } = r(8774); const parse = (e, t = {}) => { if (typeof e !== "string") { throw new TypeError("Expected a string") } let r = t || {}; let v = typeof r.maxLength === "number" ? Math.min(i, r.maxLength) : i; if (e.length > v) { throw new SyntaxError(`Input length (${e.length}), exceeds max characters (${v})`) } let w = { type: "root", input: e, nodes: [] }; let D = [w]; let E = w; let S = w; let C = 0; let x = e.length; let A = 0; let P = 0; let R; let k = {}; const advance = () => e[A++]; const push = e => { if (e.type === "text" && S.type === "dot") { S.type = "text" } if (S && S.type === "text" && e.type === "text") { S.value += e.value; return } E.nodes.push(e); e.parent = E; e.prev = S; S = e; return e }; push({ type: "bos" }); while (A < x) { E = D[D.length - 1]; R = advance(); if (R === _ || R === b) { continue } if (R === s) { push({ type: "text", value: (t.keepEscaping ? R : "") + advance() }); continue } if (R === m) { push({ type: "text", value: "\\" + R }); continue } if (R === h) { C++; let e = true; let t; while (A < x && (t = advance())) { R += t; if (t === h) { C++; continue } if (t === s) { R += advance(); continue } if (t === m) { C--; if (C === 0) { break } } } push({ type: "text", value: R }); continue } if (R === l) { E = push({ type: "paren", nodes: [] }); D.push(E); push({ type: "text", value: R }); continue } if (R === f) { if (E.type !== "paren") { push({ type: "text", value: R }); continue } E = D.pop(); push({ type: "text", value: R }); E = D[D.length - 1]; continue } if (R === g || R === y || R === o) { let e = R; let r; if (t.keepQuotes !== true) { R = "" } while (A < x && (r = advance())) { if (r === s) { R += r + advance(); continue } if (r === e) { if (t.keepQuotes === true) R += r; break } R += r } push({ type: "text", value: R }); continue } if (R === d) { P++; let e = S.value && S.value.slice(-1) === "$" || E.dollar === true; let t = { type: "brace", open: true, close: false, dollar: e, depth: P, commas: 0, ranges: 0, nodes: [] }; E = push(t); D.push(E); push({ type: "open", value: R }); continue } if (R === p) { if (E.type !== "brace") { push({ type: "text", value: R }); continue } let e = "close"; E = D.pop(); E.close = true; push({ type: e, value: R }); P--; E = D[D.length - 1]; continue } if (R === a && P > 0) { if (E.ranges > 0) { E.ranges = 0; let e = E.nodes.shift(); E.nodes = [e, { type: "text", value: n(E) }] } push({ type: "comma", value: R }); E.commas++; continue } if (R === u && P > 0 && E.commas === 0) { let e = E.nodes; if (P === 0 || e.length === 0) { push({ type: "text", value: R }); continue } if (S.type === "dot") { E.range = []; S.value += R; S.type = "range"; if (E.nodes.length !== 3 && E.nodes.length !== 5) { E.invalid = true; E.ranges = 0; S.type = "text"; continue } E.ranges++; E.args = []; continue } if (S.type === "range") { e.pop(); let t = e[e.length - 1]; t.value += S.value + R; S = t; E.ranges--; continue } push({ type: "dot", value: R }); continue } push({ type: "text", value: R }) } do { E = D.pop(); if (E.type !== "root") { E.nodes.forEach((e => { if (!e.nodes) { if (e.type === "open") e.isOpen = true; if (e.type === "close") e.isClose = true; if (!e.nodes) e.type = "text"; e.invalid = true } })); let e = D[D.length - 1]; let t = e.nodes.indexOf(E); e.nodes.splice(t, 1, ...E.nodes) } } while (D.length > 0); push({ type: "eos" }); return w }; e.exports = parse }, 8750: (e, t, r) => { const n = r(5207); e.exports = (e, t = {}) => { let stringify = (e, r = {}) => { let i = t.escapeInvalid && n.isInvalidBrace(r); let s = e.invalid === true && t.escapeInvalid === true; let o = ""; if (e.value) { if ((i || s) && n.isOpenOrClose(e)) { return "\\" + e.value } return e.value } if (e.value) { return e.value } if (e.nodes) { for (let t of e.nodes) { o += stringify(t) } } return o }; return stringify(e) } }, 5207: (e, t) => { t.isInteger = e => { if (typeof e === "number") { return Number.isInteger(e) } if (typeof e === "string" && e.trim() !== "") { return Number.isInteger(Number(e)) } return false }; t.find = (e, t) => e.nodes.find((e => e.type === t)); t.exceedsLimit = (e, r, n = 1, i) => { if (i === false) return false; if (!t.isInteger(e) || !t.isInteger(r)) return false; return (Number(r) - Number(e)) / Number(n) >= i }; t.escapeNode = (e, t = 0, r) => { let n = e.nodes[t]; if (!n) return; if (r && n.type === r || n.type === "open" || n.type === "close") { if (n.escaped !== true) { n.value = "\\" + n.value; n.escaped = true } } }; t.encloseBrace = e => { if (e.type !== "brace") return false; if (e.commas >> 0 + e.ranges >> 0 === 0) { e.invalid = true; return true } return false }; t.isInvalidBrace = e => { if (e.type !== "brace") return false; if (e.invalid === true || e.dollar) return true; if (e.commas >> 0 + e.ranges >> 0 === 0) { e.invalid = true; return true } if (e.open !== true || e.close !== true) { e.invalid = true; return true } return false }; t.isOpenOrClose = e => { if (e.type === "open" || e.type === "close") { return true } return e.open === true || e.close === true }; t.reduce = e => e.reduce(((e, t) => { if (t.type === "text") e.push(t.value); if (t.type === "range") t.type = "text"; return e }), []); t.flatten = (...e) => { const t = []; const flat = e => { for (let r = 0; r < e.length; r++) { let n = e[r]; Array.isArray(n) ? flat(n, t) : n !== void 0 && t.push(n) } return t }; flat(e); return t } }, 2031: (e, t, r) => { const n = Object.assign({}, r(6374)); const i = Object.keys(n); Object.defineProperty(n, "random", { get() { const e = Math.floor(Math.random() * i.length); const t = i[e]; return n[t] } }); e.exports = n }, 8606: e => { var t = function () { "use strict"; function clone(e, t, r, n) { var i; if (typeof t === "object") { r = t.depth; n = t.prototype; i = t.filter; t = t.circular } var s = []; var o = []; var a = typeof Buffer != "undefined"; if (typeof t == "undefined") t = true; if (typeof r == "undefined") r = Infinity; function _clone(e, r) { if (e === null) return null; if (r == 0) return e; var i; var u; if (typeof e != "object") { return e } if (clone.__isArray(e)) { i = [] } else if (clone.__isRegExp(e)) { i = new RegExp(e.source, __getRegExpFlags(e)); if (e.lastIndex) i.lastIndex = e.lastIndex } else if (clone.__isDate(e)) { i = new Date(e.getTime()) } else if (a && Buffer.isBuffer(e)) { if (Buffer.allocUnsafe) { i = Buffer.allocUnsafe(e.length) } else { i = new Buffer(e.length) } e.copy(i); return i } else { if (typeof n == "undefined") { u = Object.getPrototypeOf(e); i = Object.create(u) } else { i = Object.create(n); u = n } } if (t) { var l = s.indexOf(e); if (l != -1) { return o[l] } s.push(e); o.push(i) } for (var f in e) { var d; if (u) { d = Object.getOwnPropertyDescriptor(u, f) } if (d && d.set == null) { continue } i[f] = _clone(e[f], r - 1) } return i } return _clone(e, r) } clone.clonePrototype = function clonePrototype(e) { if (e === null) return null; var c = function () { }; c.prototype = e; return new c }; function __objToStr(e) { return Object.prototype.toString.call(e) } clone.__objToStr = __objToStr; function __isDate(e) { return typeof e === "object" && __objToStr(e) === "[object Date]" } clone.__isDate = __isDate; function __isArray(e) { return typeof e === "object" && __objToStr(e) === "[object Array]" } clone.__isArray = __isArray; function __isRegExp(e) { return typeof e === "object" && __objToStr(e) === "[object RegExp]" } clone.__isRegExp = __isRegExp; function __getRegExpFlags(e) { var t = ""; if (e.global) t += "g"; if (e.ignoreCase) t += "i"; if (e.multiline) t += "m"; return t } clone.__getRegExpFlags = __getRegExpFlags; return clone }(); if (true && e.exports) { e.exports = t } }, 7391: (e, t, r) => { const n = r(8510); const i = {}; for (const e of Object.keys(n)) { i[n[e]] = e } const s = { rgb: { channels: 3, labels: "rgb" }, hsl: { channels: 3, labels: "hsl" }, hsv: { channels: 3, labels: "hsv" }, hwb: { channels: 3, labels: "hwb" }, cmyk: { channels: 4, labels: "cmyk" }, xyz: { channels: 3, labels: "xyz" }, lab: { channels: 3, labels: "lab" }, lch: { channels: 3, labels: "lch" }, hex: { channels: 1, labels: ["hex"] }, keyword: { channels: 1, labels: ["keyword"] }, ansi16: { channels: 1, labels: ["ansi16"] }, ansi256: { channels: 1, labels: ["ansi256"] }, hcg: { channels: 3, labels: ["h", "c", "g"] }, apple: { channels: 3, labels: ["r16", "g16", "b16"] }, gray: { channels: 1, labels: ["gray"] } }; e.exports = s; for (const e of Object.keys(s)) { if (!("channels" in s[e])) { throw new Error("missing channels property: " + e) } if (!("labels" in s[e])) { throw new Error("missing channel labels property: " + e) } if (s[e].labels.length !== s[e].channels) { throw new Error("channel and label counts mismatch: " + e) } const { channels: t, labels: r } = s[e]; delete s[e].channels; delete s[e].labels; Object.defineProperty(s[e], "channels", { value: t }); Object.defineProperty(s[e], "labels", { value: r }) } s.rgb.hsl = function (e) { const t = e[0] / 255; const r = e[1] / 255; const n = e[2] / 255; const i = Math.min(t, r, n); const s = Math.max(t, r, n); const o = s - i; let a; let u; if (s === i) { a = 0 } else if (t === s) { a = (r - n) / o } else if (r === s) { a = 2 + (n - t) / o } else if (n === s) { a = 4 + (t - r) / o } a = Math.min(a * 60, 360); if (a < 0) { a += 360 } const l = (i + s) / 2; if (s === i) { u = 0 } else if (l <= .5) { u = o / (s + i) } else { u = o / (2 - s - i) } return [a, u * 100, l * 100] }; s.rgb.hsv = function (e) { let t; let r; let n; let i; let s; const o = e[0] / 255; const a = e[1] / 255; const u = e[2] / 255; const l = Math.max(o, a, u); const f = l - Math.min(o, a, u); const diffc = function (e) { return (l - e) / 6 / f + 1 / 2 }; if (f === 0) { i = 0; s = 0 } else { s = f / l; t = diffc(o); r = diffc(a); n = diffc(u); if (o === l) { i = n - r } else if (a === l) { i = 1 / 3 + t - n } else if (u === l) { i = 2 / 3 + r - t } if (i < 0) { i += 1 } else if (i > 1) { i -= 1 } } return [i * 360, s * 100, l * 100] }; s.rgb.hwb = function (e) { const t = e[0]; const r = e[1]; let n = e[2]; const i = s.rgb.hsl(e)[0]; const o = 1 / 255 * Math.min(t, Math.min(r, n)); n = 1 - 1 / 255 * Math.max(t, Math.max(r, n)); return [i, o * 100, n * 100] }; s.rgb.cmyk = function (e) { const t = e[0] / 255; const r = e[1] / 255; const n = e[2] / 255; const i = Math.min(1 - t, 1 - r, 1 - n); const s = (1 - t - i) / (1 - i) || 0; const o = (1 - r - i) / (1 - i) || 0; const a = (1 - n - i) / (1 - i) || 0; return [s * 100, o * 100, a * 100, i * 100] }; function comparativeDistance(e, t) { return (e[0] - t[0]) ** 2 + (e[1] - t[1]) ** 2 + (e[2] - t[2]) ** 2 } s.rgb.keyword = function (e) { const t = i[e]; if (t) { return t } let r = Infinity; let s; for (const t of Object.keys(n)) { const i = n[t]; const o = comparativeDistance(e, i); if (o < r) { r = o; s = t } } return s }; s.keyword.rgb = function (e) { return n[e] }; s.rgb.xyz = function (e) { let t = e[0] / 255; let r = e[1] / 255; let n = e[2] / 255; t = t > .04045 ? ((t + .055) / 1.055) ** 2.4 : t / 12.92; r = r > .04045 ? ((r + .055) / 1.055) ** 2.4 : r / 12.92; n = n > .04045 ? ((n + .055) / 1.055) ** 2.4 : n / 12.92; const i = t * .4124 + r * .3576 + n * .1805; const s = t * .2126 + r * .7152 + n * .0722; const o = t * .0193 + r * .1192 + n * .9505; return [i * 100, s * 100, o * 100] }; s.rgb.lab = function (e) { const t = s.rgb.xyz(e); let r = t[0]; let n = t[1]; let i = t[2]; r /= 95.047; n /= 100; i /= 108.883; r = r > .008856 ? r ** (1 / 3) : 7.787 * r + 16 / 116; n = n > .008856 ? n ** (1 / 3) : 7.787 * n + 16 / 116; i = i > .008856 ? i ** (1 / 3) : 7.787 * i + 16 / 116; const o = 116 * n - 16; const a = 500 * (r - n); const u = 200 * (n - i); return [o, a, u] }; s.hsl.rgb = function (e) { const t = e[0] / 360; const r = e[1] / 100; const n = e[2] / 100; let i; let s; let o; if (r === 0) { o = n * 255; return [o, o, o] } if (n < .5) { i = n * (1 + r) } else { i = n + r - n * r } const a = 2 * n - i; const u = [0, 0, 0]; for (let e = 0; e < 3; e++) { s = t + 1 / 3 * -(e - 1); if (s < 0) { s++ } if (s > 1) { s-- } if (6 * s < 1) { o = a + (i - a) * 6 * s } else if (2 * s < 1) { o = i } else if (3 * s < 2) { o = a + (i - a) * (2 / 3 - s) * 6 } else { o = a } u[e] = o * 255 } return u }; s.hsl.hsv = function (e) { const t = e[0]; let r = e[1] / 100; let n = e[2] / 100; let i = r; const s = Math.max(n, .01); n *= 2; r *= n <= 1 ? n : 2 - n; i *= s <= 1 ? s : 2 - s; const o = (n + r) / 2; const a = n === 0 ? 2 * i / (s + i) : 2 * r / (n + r); return [t, a * 100, o * 100] }; s.hsv.rgb = function (e) { const t = e[0] / 60; const r = e[1] / 100; let n = e[2] / 100; const i = Math.floor(t) % 6; const s = t - Math.floor(t); const o = 255 * n * (1 - r); const a = 255 * n * (1 - r * s); const u = 255 * n * (1 - r * (1 - s)); n *= 255; switch (i) { case 0: return [n, u, o]; case 1: return [a, n, o]; case 2: return [o, n, u]; case 3: return [o, a, n]; case 4: return [u, o, n]; case 5: return [n, o, a] } }; s.hsv.hsl = function (e) { const t = e[0]; const r = e[1] / 100; const n = e[2] / 100; const i = Math.max(n, .01); let s; let o; o = (2 - r) * n; const a = (2 - r) * i; s = r * i; s /= a <= 1 ? a : 2 - a; s = s || 0; o /= 2; return [t, s * 100, o * 100] }; s.hwb.rgb = function (e) { const t = e[0] / 360; let r = e[1] / 100; let n = e[2] / 100; const i = r + n; let s; if (i > 1) { r /= i; n /= i } const o = Math.floor(6 * t); const a = 1 - n; s = 6 * t - o; if ((o & 1) !== 0) { s = 1 - s } const u = r + s * (a - r); let l; let f; let d; switch (o) { default: case 6: case 0: l = a; f = u; d = r; break; case 1: l = u; f = a; d = r; break; case 2: l = r; f = a; d = u; break; case 3: l = r; f = u; d = a; break; case 4: l = u; f = r; d = a; break; case 5: l = a; f = r; d = u; break }return [l * 255, f * 255, d * 255] }; s.cmyk.rgb = function (e) { const t = e[0] / 100; const r = e[1] / 100; const n = e[2] / 100; const i = e[3] / 100; const s = 1 - Math.min(1, t * (1 - i) + i); const o = 1 - Math.min(1, r * (1 - i) + i); const a = 1 - Math.min(1, n * (1 - i) + i); return [s * 255, o * 255, a * 255] }; s.xyz.rgb = function (e) { const t = e[0] / 100; const r = e[1] / 100; const n = e[2] / 100; let i; let s; let o; i = t * 3.2406 + r * -1.5372 + n * -.4986; s = t * -.9689 + r * 1.8758 + n * .0415; o = t * .0557 + r * -.204 + n * 1.057; i = i > .0031308 ? 1.055 * i ** (1 / 2.4) - .055 : i * 12.92; s = s > .0031308 ? 1.055 * s ** (1 / 2.4) - .055 : s * 12.92; o = o > .0031308 ? 1.055 * o ** (1 / 2.4) - .055 : o * 12.92; i = Math.min(Math.max(0, i), 1); s = Math.min(Math.max(0, s), 1); o = Math.min(Math.max(0, o), 1); return [i * 255, s * 255, o * 255] }; s.xyz.lab = function (e) { let t = e[0]; let r = e[1]; let n = e[2]; t /= 95.047; r /= 100; n /= 108.883; t = t > .008856 ? t ** (1 / 3) : 7.787 * t + 16 / 116; r = r > .008856 ? r ** (1 / 3) : 7.787 * r + 16 / 116; n = n > .008856 ? n ** (1 / 3) : 7.787 * n + 16 / 116; const i = 116 * r - 16; const s = 500 * (t - r); const o = 200 * (r - n); return [i, s, o] }; s.lab.xyz = function (e) { const t = e[0]; const r = e[1]; const n = e[2]; let i; let s; let o; s = (t + 16) / 116; i = r / 500 + s; o = s - n / 200; const a = s ** 3; const u = i ** 3; const l = o ** 3; s = a > .008856 ? a : (s - 16 / 116) / 7.787; i = u > .008856 ? u : (i - 16 / 116) / 7.787; o = l > .008856 ? l : (o - 16 / 116) / 7.787; i *= 95.047; s *= 100; o *= 108.883; return [i, s, o] }; s.lab.lch = function (e) { const t = e[0]; const r = e[1]; const n = e[2]; let i; const s = Math.atan2(n, r); i = s * 360 / 2 / Math.PI; if (i < 0) { i += 360 } const o = Math.sqrt(r * r + n * n); return [t, o, i] }; s.lch.lab = function (e) { const t = e[0]; const r = e[1]; const n = e[2]; const i = n / 360 * 2 * Math.PI; const s = r * Math.cos(i); const o = r * Math.sin(i); return [t, s, o] }; s.rgb.ansi16 = function (e, t = null) { const [r, n, i] = e; let o = t === null ? s.rgb.hsv(e)[2] : t; o = Math.round(o / 50); if (o === 0) { return 30 } let a = 30 + (Math.round(i / 255) << 2 | Math.round(n / 255) << 1 | Math.round(r / 255)); if (o === 2) { a += 60 } return a }; s.hsv.ansi16 = function (e) { return s.rgb.ansi16(s.hsv.rgb(e), e[2]) }; s.rgb.ansi256 = function (e) { const t = e[0]; const r = e[1]; const n = e[2]; if (t === r && r === n) { if (t < 8) { return 16 } if (t > 248) { return 231 } return Math.round((t - 8) / 247 * 24) + 232 } const i = 16 + 36 * Math.round(t / 255 * 5) + 6 * Math.round(r / 255 * 5) + Math.round(n / 255 * 5); return i }; s.ansi16.rgb = function (e) { let t = e % 10; if (t === 0 || t === 7) { if (e > 50) { t += 3.5 } t = t / 10.5 * 255; return [t, t, t] } const r = (~~(e > 50) + 1) * .5; const n = (t & 1) * r * 255; const i = (t >> 1 & 1) * r * 255; const s = (t >> 2 & 1) * r * 255; return [n, i, s] }; s.ansi256.rgb = function (e) { if (e >= 232) { const t = (e - 232) * 10 + 8; return [t, t, t] } e -= 16; let t; const r = Math.floor(e / 36) / 5 * 255; const n = Math.floor((t = e % 36) / 6) / 5 * 255; const i = t % 6 / 5 * 255; return [r, n, i] }; s.rgb.hex = function (e) { const t = ((Math.round(e[0]) & 255) << 16) + ((Math.round(e[1]) & 255) << 8) + (Math.round(e[2]) & 255); const r = t.toString(16).toUpperCase(); return "000000".substring(r.length) + r }; s.hex.rgb = function (e) { const t = e.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i); if (!t) { return [0, 0, 0] } let r = t[0]; if (t[0].length === 3) { r = r.split("").map((e => e + e)).join("") } const n = parseInt(r, 16); const i = n >> 16 & 255; const s = n >> 8 & 255; const o = n & 255; return [i, s, o] }; s.rgb.hcg = function (e) { const t = e[0] / 255; const r = e[1] / 255; const n = e[2] / 255; const i = Math.max(Math.max(t, r), n); const s = Math.min(Math.min(t, r), n); const o = i - s; let a; let u; if (o < 1) { a = s / (1 - o) } else { a = 0 } if (o <= 0) { u = 0 } else if (i === t) { u = (r - n) / o % 6 } else if (i === r) { u = 2 + (n - t) / o } else { u = 4 + (t - r) / o } u /= 6; u %= 1; return [u * 360, o * 100, a * 100] }; s.hsl.hcg = function (e) { const t = e[1] / 100; const r = e[2] / 100; const n = r < .5 ? 2 * t * r : 2 * t * (1 - r); let i = 0; if (n < 1) { i = (r - .5 * n) / (1 - n) } return [e[0], n * 100, i * 100] }; s.hsv.hcg = function (e) { const t = e[1] / 100; const r = e[2] / 100; const n = t * r; let i = 0; if (n < 1) { i = (r - n) / (1 - n) } return [e[0], n * 100, i * 100] }; s.hcg.rgb = function (e) { const t = e[0] / 360; const r = e[1] / 100; const n = e[2] / 100; if (r === 0) { return [n * 255, n * 255, n * 255] } const i = [0, 0, 0]; const s = t % 1 * 6; const o = s % 1; const a = 1 - o; let u = 0; switch (Math.floor(s)) { case 0: i[0] = 1; i[1] = o; i[2] = 0; break; case 1: i[0] = a; i[1] = 1; i[2] = 0; break; case 2: i[0] = 0; i[1] = 1; i[2] = o; break; case 3: i[0] = 0; i[1] = a; i[2] = 1; break; case 4: i[0] = o; i[1] = 0; i[2] = 1; break; default: i[0] = 1; i[1] = 0; i[2] = a }u = (1 - r) * n; return [(r * i[0] + u) * 255, (r * i[1] + u) * 255, (r * i[2] + u) * 255] }; s.hcg.hsv = function (e) { const t = e[1] / 100; const r = e[2] / 100; const n = t + r * (1 - t); let i = 0; if (n > 0) { i = t / n } return [e[0], i * 100, n * 100] }; s.hcg.hsl = function (e) { const t = e[1] / 100; const r = e[2] / 100; const n = r * (1 - t) + .5 * t; let i = 0; if (n > 0 && n < .5) { i = t / (2 * n) } else if (n >= .5 && n < 1) { i = t / (2 * (1 - n)) } return [e[0], i * 100, n * 100] }; s.hcg.hwb = function (e) { const t = e[1] / 100; const r = e[2] / 100; const n = t + r * (1 - t); return [e[0], (n - t) * 100, (1 - n) * 100] }; s.hwb.hcg = function (e) { const t = e[1] / 100; const r = e[2] / 100; const n = 1 - r; const i = n - t; let s = 0; if (i < 1) { s = (n - i) / (1 - i) } return [e[0], i * 100, s * 100] }; s.apple.rgb = function (e) { return [e[0] / 65535 * 255, e[1] / 65535 * 255, e[2] / 65535 * 255] }; s.rgb.apple = function (e) { return [e[0] / 255 * 65535, e[1] / 255 * 65535, e[2] / 255 * 65535] }; s.gray.rgb = function (e) { return [e[0] / 100 * 255, e[0] / 100 * 255, e[0] / 100 * 255] }; s.gray.hsl = function (e) { return [0, 0, e[0]] }; s.gray.hsv = s.gray.hsl; s.gray.hwb = function (e) { return [0, 100, e[0]] }; s.gray.cmyk = function (e) { return [0, 0, 0, e[0]] }; s.gray.lab = function (e) { return [e[0], 0, 0] }; s.gray.hex = function (e) { const t = Math.round(e[0] / 100 * 255) & 255; const r = (t << 16) + (t << 8) + t; const n = r.toString(16).toUpperCase(); return "000000".substring(n.length) + n }; s.rgb.gray = function (e) { const t = (e[0] + e[1] + e[2]) / 3; return [t / 255 * 100] } }, 6931: (e, t, r) => { const n = r(7391); const i = r(880); const s = {}; const o = Object.keys(n); function wrapRaw(e) { const wrappedFn = function (...t) { const r = t[0]; if (r === undefined || r === null) { return r } if (r.length > 1) { t = r } return e(t) }; if ("conversion" in e) { wrappedFn.conversion = e.conversion } return wrappedFn } function wrapRounded(e) { const wrappedFn = function (...t) { const r = t[0]; if (r === undefined || r === null) { return r } if (r.length > 1) { t = r } const n = e(t); if (typeof n === "object") { for (let e = n.length, t = 0; t < e; t++) { n[t] = Math.round(n[t]) } } return n }; if ("conversion" in e) { wrappedFn.conversion = e.conversion } return wrappedFn } o.forEach((e => { s[e] = {}; Object.defineProperty(s[e], "channels", { value: n[e].channels }); Object.defineProperty(s[e], "labels", { value: n[e].labels }); const t = i(e); const r = Object.keys(t); r.forEach((r => { const n = t[r]; s[e][r] = wrapRounded(n); s[e][r].raw = wrapRaw(n) })) })); e.exports = s }, 880: (e, t, r) => { const n = r(7391); function buildGraph() { const e = {}; const t = Object.keys(n); for (let r = t.length, n = 0; n < r; n++) { e[t[n]] = { distance: -1, parent: null } } return e } function deriveBFS(e) { const t = buildGraph(); const r = [e]; t[e].distance = 0; while (r.length) { const e = r.pop(); const i = Object.keys(n[e]); for (let n = i.length, s = 0; s < n; s++) { const n = i[s]; const o = t[n]; if (o.distance === -1) { o.distance = t[e].distance + 1; o.parent = e; r.unshift(n) } } } return t } function link(e, t) { return function (r) { return t(e(r)) } } function wrapConversion(e, t) { const r = [t[e].parent, e]; let i = n[t[e].parent][e]; let s = t[e].parent; while (t[s].parent) { r.unshift(t[s].parent); i = link(n[t[s].parent][s], i); s = t[s].parent } i.conversion = r; return i } e.exports = function (e) { const t = deriveBFS(e); const r = {}; const n = Object.keys(t); for (let e = n.length, i = 0; i < e; i++) { const e = n[i]; const s = t[e]; if (s.parent === null) { continue } r[e] = wrapConversion(e, t) } return r } }, 8510: e => { e.exports = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] } }, 7881: (e, t, r) => { const n = r(2081); const i = r(6855); const s = r(4101); function spawn(e, t, r) { const o = i(e, t, r); const a = n.spawn(o.command, o.args, o.options); s.hookChildProcess(a, o); return a } function spawnSync(e, t, r) { const o = i(e, t, r); const a = n.spawnSync(o.command, o.args, o.options); a.error = a.error || s.verifyENOENTSync(a.status, o); return a } e.exports = spawn; e.exports.spawn = spawn; e.exports.sync = spawnSync; e.exports._parse = i; e.exports._enoent = s }, 4101: e => { const t = process.platform === "win32"; function notFoundError(e, t) { return Object.assign(new Error(`${t} ${e.command} ENOENT`), { code: "ENOENT", errno: "ENOENT", syscall: `${t} ${e.command}`, path: e.command, spawnargs: e.args }) } function hookChildProcess(e, r) { if (!t) { return } const n = e.emit; e.emit = function (t, i) { if (t === "exit") { const t = verifyENOENT(i, r, "spawn"); if (t) { return n.call(e, "error", t) } } return n.apply(e, arguments) } } function verifyENOENT(e, r) { if (t && e === 1 && !r.file) { return notFoundError(r.original, "spawn") } return null } function verifyENOENTSync(e, r) { if (t && e === 1 && !r.file) { return notFoundError(r.original, "spawnSync") } return null } e.exports = { hookChildProcess: hookChildProcess, verifyENOENT: verifyENOENT, verifyENOENTSync: verifyENOENTSync, notFoundError: notFoundError } }, 6855: (e, t, r) => { const n = r(1017); const i = r(7274); const s = r(4274); const o = r(1252); const a = process.platform === "win32"; const u = /\.(?:com|exe)$/i; const l = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i; function detectShebang(e) { e.file = i(e); const t = e.file && o(e.file); if (t) { e.args.unshift(e.file); e.command = t; return i(e) } return e.file } function parseNonShell(e) { if (!a) { return e } const t = detectShebang(e); const r = !u.test(t); if (e.options.forceShell || r) { const r = l.test(t); e.command = n.normalize(e.command); e.command = s.command(e.command); e.args = e.args.map((e => s.argument(e, r))); const i = [e.command].concat(e.args).join(" "); e.args = ["/d", "/s", "/c", `"${i}"`]; e.command = process.env.comspec || "cmd.exe"; e.options.windowsVerbatimArguments = true } return e } function parse(e, t, r) { if (t && !Array.isArray(t)) { r = t; t = null } t = t ? t.slice(0) : []; r = Object.assign({}, r); const n = { command: e, args: t, options: r, file: undefined, original: { command: e, args: t } }; return r.shell ? n : parseNonShell(n) } e.exports = parse }, 4274: e => { const t = /([()\][%!^"`<>&|;, *?])/g; function escapeCommand(e) { e = e.replace(t, "^$1"); return e } function escapeArgument(e, r) { e = `${e}`; e = e.replace(/(\\*)"/g, '$1$1\\"'); e = e.replace(/(\\*)$/, "$1$1"); e = `"${e}"`; e = e.replace(t, "^$1"); if (r) { e = e.replace(t, "^$1") } return e } e.exports.command = escapeCommand; e.exports.argument = escapeArgument }, 1252: (e, t, r) => { const n = r(7147); const i = r(7032); function readShebang(e) { const t = 150; const r = Buffer.alloc(t); let s; try { s = n.openSync(e, "r"); n.readSync(s, r, 0, t, 0); n.closeSync(s) } catch (e) { } return i(r.toString()) } e.exports = readShebang }, 7274: (e, t, r) => { const n = r(1017); const i = r(4207); const s = r(539); function resolveCommandAttempt(e, t) { const r = e.options.env || process.env; const o = process.cwd(); const a = e.options.cwd != null; const u = a && process.chdir !== undefined && !process.chdir.disabled; if (u) { try { process.chdir(e.options.cwd) } catch (e) { } } let l; try { l = i.sync(e.command, { path: r[s({ env: r })], pathExt: t ? n.delimiter : undefined }) } catch (e) { } finally { if (u) { process.chdir(o) } } if (l) { l = n.resolve(a ? e.options.cwd : "", l) } return l } function resolveCommand(e) { return resolveCommandAttempt(e) || resolveCommandAttempt(e, true) } e.exports = resolveCommand }, 8222: (e, t, r) => { t.formatArgs = formatArgs; t.save = save; t.load = load; t.useColors = useColors; t.storage = localstorage(); t.destroy = (() => { let e = false; return () => { if (!e) { e = true; console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.") } } })(); t.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"]; function useColors() { if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) { return true } if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) { return false } return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/) } function formatArgs(t) { t[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + t[0] + (this.useColors ? "%c " : " ") + "+" + e.exports.humanize(this.diff); if (!this.useColors) { return } const r = "color: " + this.color; t.splice(1, 0, r, "color: inherit"); let n = 0; let i = 0; t[0].replace(/%[a-zA-Z%]/g, (e => { if (e === "%%") { return } n++; if (e === "%c") { i = n } })); t.splice(i, 0, r) } t.log = console.debug || console.log || (() => { }); function save(e) { try { if (e) { t.storage.setItem("debug", e) } else { t.storage.removeItem("debug") } } catch (e) { } } function load() { let e; try { e = t.storage.getItem("debug") } catch (e) { } if (!e && typeof process !== "undefined" && "env" in process) { e = process.env.DEBUG } return e } function localstorage() { try { return localStorage } catch (e) { } } e.exports = r(6243)(t); const { formatters: n } = e.exports; n.j = function (e) { try { return JSON.stringify(e) } catch (e) { return "[UnexpectedJSONParseError]: " + e.message } } }, 6243: (e, t, r) => { function setup(e) { createDebug.debug = createDebug; createDebug.default = createDebug; createDebug.coerce = coerce; createDebug.disable = disable; createDebug.enable = enable; createDebug.enabled = enabled; createDebug.humanize = r(900); createDebug.destroy = destroy; Object.keys(e).forEach((t => { createDebug[t] = e[t] })); createDebug.names = []; createDebug.skips = []; createDebug.formatters = {}; function selectColor(e) { let t = 0; for (let r = 0; r < e.length; r++) { t = (t << 5) - t + e.charCodeAt(r); t |= 0 } return createDebug.colors[Math.abs(t) % createDebug.colors.length] } createDebug.selectColor = selectColor; function createDebug(e) { let t; let r = null; let n; let i; function debug(...e) { if (!debug.enabled) { return } const r = debug; const n = Number(new Date); const i = n - (t || n); r.diff = i; r.prev = t; r.curr = n; t = n; e[0] = createDebug.coerce(e[0]); if (typeof e[0] !== "string") { e.unshift("%O") } let s = 0; e[0] = e[0].replace(/%([a-zA-Z%])/g, ((t, n) => { if (t === "%%") { return "%" } s++; const i = createDebug.formatters[n]; if (typeof i === "function") { const n = e[s]; t = i.call(r, n); e.splice(s, 1); s-- } return t })); createDebug.formatArgs.call(r, e); const o = r.log || createDebug.log; o.apply(r, e) } debug.namespace = e; debug.useColors = createDebug.useColors(); debug.color = createDebug.selectColor(e); debug.extend = extend; debug.destroy = createDebug.destroy; Object.defineProperty(debug, "enabled", { enumerable: true, configurable: false, get: () => { if (r !== null) { return r } if (n !== createDebug.namespaces) { n = createDebug.namespaces; i = createDebug.enabled(e) } return i }, set: e => { r = e } }); if (typeof createDebug.init === "function") { createDebug.init(debug) } return debug } function extend(e, t) { const r = createDebug(this.namespace + (typeof t === "undefined" ? ":" : t) + e); r.log = this.log; return r } function enable(e) { createDebug.save(e); createDebug.namespaces = e; createDebug.names = []; createDebug.skips = []; let t; const r = (typeof e === "string" ? e : "").split(/[\s,]+/); const n = r.length; for (t = 0; t < n; t++) { if (!r[t]) { continue } e = r[t].replace(/\*/g, ".*?"); if (e[0] === "-") { createDebug.skips.push(new RegExp("^" + e.slice(1) + "$")) } else { createDebug.names.push(new RegExp("^" + e + "$")) } } } function disable() { const e = [...createDebug.names.map(toNamespace), ...createDebug.skips.map(toNamespace).map((e => "-" + e))].join(","); createDebug.enable(""); return e } function enabled(e) { if (e[e.length - 1] === "*") { return true } let t; let r; for (t = 0, r = createDebug.skips.length; t < r; t++) { if (createDebug.skips[t].test(e)) { return false } } for (t = 0, r = createDebug.names.length; t < r; t++) { if (createDebug.names[t].test(e)) { return true } } return false } function toNamespace(e) { return e.toString().substring(2, e.toString().length - 2).replace(/\.\*\?$/, "*") } function coerce(e) { if (e instanceof Error) { return e.stack || e.message } return e } function destroy() { console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.") } createDebug.enable(createDebug.load()); return createDebug } e.exports = setup }, 8237: (e, t, r) => { if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) { e.exports = r(8222) } else { e.exports = r(4874) } }, 4874: (e, t, r) => { const n = r(6224); const i = r(3837); t.init = init; t.log = log; t.formatArgs = formatArgs; t.save = save; t.load = load; t.useColors = useColors; t.destroy = i.deprecate((() => { }), "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."); t.colors = [6, 2, 3, 4, 5, 1]; try { const e = r(9318); if (e && (e.stderr || e).level >= 2) { t.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221] } } catch (e) { } t.inspectOpts = Object.keys(process.env).filter((e => /^debug_/i.test(e))).reduce(((e, t) => { const r = t.substring(6).toLowerCase().replace(/_([a-z])/g, ((e, t) => t.toUpperCase())); let n = process.env[t]; if (/^(yes|on|true|enabled)$/i.test(n)) { n = true } else if (/^(no|off|false|disabled)$/i.test(n)) { n = false } else if (n === "null") { n = null } else { n = Number(n) } e[r] = n; return e }), {}); function useColors() { return "colors" in t.inspectOpts ? Boolean(t.inspectOpts.colors) : n.isatty(process.stderr.fd) } function formatArgs(t) { const { namespace: r, useColors: n } = this; if (n) { const n = this.color; const i = "[3" + (n < 8 ? n : "8;5;" + n); const s = `  ${i};1m${r} [0m`; t[0] = s + t[0].split("\n").join("\n" + s); t.push(i + "m+" + e.exports.humanize(this.diff) + "[0m") } else { t[0] = getDate() + r + " " + t[0] } } function getDate() { if (t.inspectOpts.hideDate) { return "" } return (new Date).toISOString() + " " } function log(...e) { return process.stderr.write(i.format(...e) + "\n") } function save(e) { if (e) { process.env.DEBUG = e } else { delete process.env.DEBUG } } function load() { return process.env.DEBUG } function init(e) { e.inspectOpts = {}; const r = Object.keys(t.inspectOpts); for (let n = 0; n < r.length; n++) { e.inspectOpts[r[n]] = t.inspectOpts[r[n]] } } e.exports = r(6243)(t); const { formatters: s } = e.exports; s.o = function (e) { this.inspectOpts.colors = this.useColors; return i.inspect(e, this.inspectOpts).split("\n").map((e => e.trim())).join(" ") }; s.O = function (e) { this.inspectOpts.colors = this.useColors; return i.inspect(e, this.inspectOpts) } }, 2391: (e, t, r) => { const { Transform: n, PassThrough: i } = r(2781); const s = r(9796); const o = r(3877); e.exports = e => { const t = (e.headers["content-encoding"] || "").toLowerCase(); if (!["gzip", "deflate", "br"].includes(t)) { return e } const r = t === "br"; if (r && typeof s.createBrotliDecompress !== "function") { e.destroy(new Error("Brotli is not supported on Node.js < 12")); return e } let a = true; const u = new n({ transform(e, t, r) { a = false; r(null, e) }, flush(e) { e() } }); const l = new i({ autoDestroy: false, destroy(t, r) { e.destroy(); r(t) } }); const f = r ? s.createBrotliDecompress() : s.createUnzip(); f.once("error", (t => { if (a && !e.readable) { l.end(); return } l.destroy(t) })); o(e, l); e.pipe(u).pipe(f).pipe(l); return l } }, 3877: e => { const t = ["aborted", "complete", "headers", "httpVersion", "httpVersionMinor", "httpVersionMajor", "method", "rawHeaders", "rawTrailers", "setTimeout", "socket", "statusCode", "statusMessage", "trailers", "url"]; e.exports = (e, r) => { if (r._readableState.autoDestroy) { throw new Error("The second stream must have the `autoDestroy` option set to `false`") } const n = new Set(Object.keys(e).concat(t)); const i = {}; for (const t of n) { if (t in r) { continue } i[t] = { get() { const r = e[t]; const n = typeof r === "function"; return n ? r.bind(e) : r }, set(r) { e[t] = r }, enumerable: true, configurable: false } } Object.defineProperties(r, i); e.once("aborted", (() => { r.destroy(); r.emit("aborted") })); e.once("close", (() => { if (e.complete) { if (r.readable) { r.once("end", (() => { r.emit("close") })) } else { r.emit("close") } } else { r.emit("close") } })); return r } }, 732: (e, t, r) => { var n = r(8606); e.exports = function (e, t) { e = e || {}; Object.keys(t).forEach((function (r) { if (typeof e[r] === "undefined") { e[r] = n(t[r]) } })); return e } }, 6214: (e, t) => { Object.defineProperty(t, "__esModule", { value: true }); function isTLSSocket(e) { return e.encrypted } const deferToConnect = (e, t) => { let r; if (typeof t === "function") { const e = t; r = { connect: e } } else { r = t } const n = typeof r.connect === "function"; const i = typeof r.secureConnect === "function"; const s = typeof r.close === "function"; const onConnect = () => { if (n) { r.connect() } if (isTLSSocket(e) && i) { if (e.authorized) { r.secureConnect() } else if (!e.authorizationError) { e.once("secureConnect", r.secureConnect) } } if (s) { e.once("close", r.close) } }; if (e.writable && !e.connecting) { onConnect() } else if (e.connecting) { e.once("connect", onConnect) } else if (e.destroyed && s) { r.close(e._hadError) } }; t["default"] = deferToConnect; e.exports = deferToConnect; e.exports["default"] = deferToConnect }, 2738: (e, t, r) => { const n = r(1017); const i = r(3433); const getExtensions = e => e.length > 1 ? `{${e.join(",")}}` : e[0]; const getPath = (e, t) => { const r = e[0] === "!" ? e.slice(1) : e; return n.isAbsolute(r) ? r : n.join(t, r) }; const addExtensions = (e, t) => { if (n.extname(e)) { return `**/${e}` } return `**/${e}.${getExtensions(t)}` }; const getGlob = (e, t) => { if (t.files && !Array.isArray(t.files)) { throw new TypeError(`Expected \`files\` to be of type \`Array\` but received type \`${typeof t.files}\``) } if (t.extensions && !Array.isArray(t.extensions)) { throw new TypeError(`Expected \`extensions\` to be of type \`Array\` but received type \`${typeof t.extensions}\``) } if (t.files && t.extensions) { return t.files.map((r => n.posix.join(e, addExtensions(r, t.extensions)))) } if (t.files) { return t.files.map((t => n.posix.join(e, `**/${t}`))) } if (t.extensions) { return [n.posix.join(e, `**/*.${getExtensions(t.extensions)}`)] } return [n.posix.join(e, "**")] }; e.exports = async (e, t) => { t = { cwd: process.cwd(), ...t }; if (typeof t.cwd !== "string") { throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof t.cwd}\``) } const r = await Promise.all([].concat(e).map((async e => { const r = await i.isDirectory(getPath(e, t.cwd)); return r ? getGlob(e, t) : e }))); return [].concat.apply([], r) }; e.exports.sync = (e, t) => { t = { cwd: process.cwd(), ...t }; if (typeof t.cwd !== "string") { throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof t.cwd}\``) } const r = [].concat(e).map((e => i.isDirectorySync(getPath(e, t.cwd)) ? getGlob(e, t) : e)); return [].concat.apply([], r) } }, 2437: (e, t, r) => { const n = r(7147); const i = r(1017); const s = r(2037); const o = r(9968); const a = o.version; const u = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/gm; function parse(e) { const t = {}; let r = e.toString(); r = r.replace(/\r\n?/gm, "\n"); let n; while ((n = u.exec(r)) != null) { const e = n[1]; let r = n[2] || ""; r = r.trim(); const i = r[0]; r = r.replace(/^(['"`])([\s\S]*)\1$/gm, "$2"); if (i === '"') { r = r.replace(/\\n/g, "\n"); r = r.replace(/\\r/g, "\r") } t[e] = r } return t } function _log(e) { console.log(`[dotenv@${a}][DEBUG] ${e}`) } function _resolveHome(e) { return e[0] === "~" ? i.join(s.homedir(), e.slice(1)) : e } function config(e) { let t = i.resolve(process.cwd(), ".env"); let r = "utf8"; const s = Boolean(e && e.debug); const o = Boolean(e && e.override); if (e) { if (e.path != null) { t = _resolveHome(e.path) } if (e.encoding != null) { r = e.encoding } } try { const e = l.parse(n.readFileSync(t, { encoding: r })); Object.keys(e).forEach((function (t) { if (!Object.prototype.hasOwnProperty.call(process.env, t)) { process.env[t] = e[t] } else { if (o === true) { process.env[t] = e[t] } if (s) { if (o === true) { _log(`"${t}" is already defined in \`process.env\` and WAS overwritten`) } else { _log(`"${t}" is already defined in \`process.env\` and was NOT overwritten`) } } } })); return { parsed: e } } catch (e) { if (s) { _log(`Failed to load ${t} ${e.message}`) } return { error: e } } } const l = { config: config, parse: parse }; e.exports.config = l.config; e.exports.parse = l.parse; e.exports = l }, 8212: e => { e.exports = function () { return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g } }, 7512: (e, t, r) => { var n = r(429); e.exports = function extend(e) { if (!n(e)) { e = {} } var t = arguments.length; for (var r = 1; r < t; r++) { var i = arguments[r]; if (n(i)) { assign(e, i) } } return e }; function assign(e, t) { for (var r in t) { if (hasOwn(t, r)) { e[r] = t[r] } } } function hasOwn(e, t) { return Object.prototype.hasOwnProperty.call(e, t) } }, 8206: e => { e.exports = function equal(e, t) { if (e === t) return true; if (e && t && typeof e == "object" && typeof t == "object") { if (e.constructor !== t.constructor) return false; var r, n, i; if (Array.isArray(e)) { r = e.length; if (r != t.length) return false; for (n = r; n-- !== 0;)if (!equal(e[n], t[n])) return false; return true } if (e.constructor === RegExp) return e.source === t.source && e.flags === t.flags; if (e.valueOf !== Object.prototype.valueOf) return e.valueOf() === t.valueOf(); if (e.toString !== Object.prototype.toString) return e.toString() === t.toString(); i = Object.keys(e); r = i.length; if (r !== Object.keys(t).length) return false; for (n = r; n-- !== 0;)if (!Object.prototype.hasOwnProperty.call(t, i[n])) return false; for (n = r; n-- !== 0;) { var s = i[n]; if (!equal(e[s], t[s])) return false } return true } return e !== e && t !== t } }, 3664: (e, t, r) => { const n = r(2708); const i = r(8306); const s = r(5679); const o = r(4630); const a = r(2405); const u = r(952); const l = r(5444); async function FastGlob(e, t) { assertPatternsInput(e); const r = getWorks(e, s.default, t); const n = await Promise.all(r); return l.array.flatten(n) } (function (e) { function sync(e, t) { assertPatternsInput(e); const r = getWorks(e, a.default, t); return l.array.flatten(r) } e.sync = sync; function stream(e, t) { assertPatternsInput(e); const r = getWorks(e, o.default, t); return l.stream.merge(r) } e.stream = stream; function generateTasks(e, t) { assertPatternsInput(e); const r = i.transform([].concat(e)); const s = new u.default(t); return n.generate(r, s) } e.generateTasks = generateTasks; function isDynamicPattern(e, t) { assertPatternsInput(e); const r = new u.default(t); return l.pattern.isDynamicPattern(e, r) } e.isDynamicPattern = isDynamicPattern; function escapePath(e) { assertPatternsInput(e); return l.path.escape(e) } e.escapePath = escapePath })(FastGlob || (FastGlob = {})); function getWorks(e, t, r) { const s = i.transform([].concat(e)); const o = new u.default(r); const a = n.generate(s, o); const l = new t(o); return a.map(l.read, l) } function assertPatternsInput(e) { const t = [].concat(e); const r = t.every((e => l.string.isString(e) && !l.string.isEmpty(e))); if (!r) { throw new TypeError("Patterns must be a string (non empty) or an array of strings") } } e.exports = FastGlob }, 8306: (e, t) => { Object.defineProperty(t, "__esModule", { value: true }); t.removeDuplicateSlashes = t.transform = void 0; const r = /(?!^)\/{2,}/g; function transform(e) { return e.map((e => removeDuplicateSlashes(e))) } t.transform = transform; function removeDuplicateSlashes(e) { return e.replace(r, "/") } t.removeDuplicateSlashes = removeDuplicateSlashes }, 2708: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t.convertPatternGroupToTask = t.convertPatternGroupsToTasks = t.groupPatternsByBaseDirectory = t.getNegativePatternsAsPositive = t.getPositivePatterns = t.convertPatternsToTasks = t.generate = void 0; const n = r(5444); function generate(e, t) { const r = getPositivePatterns(e); const i = getNegativePatternsAsPositive(e, t.ignore); const s = r.filter((e => n.pattern.isStaticPattern(e, t))); const o = r.filter((e => n.pattern.isDynamicPattern(e, t))); const a = convertPatternsToTasks(s, i, false); const u = convertPatternsToTasks(o, i, true); return a.concat(u) } t.generate = generate; function convertPatternsToTasks(e, t, r) { const i = []; const s = n.pattern.getPatternsOutsideCurrentDirectory(e); const o = n.pattern.getPatternsInsideCurrentDirectory(e); const a = groupPatternsByBaseDirectory(s); const u = groupPatternsByBaseDirectory(o); i.push(...convertPatternGroupsToTasks(a, t, r)); if ("." in u) { i.push(convertPatternGroupToTask(".", o, t, r)) } else { i.push(...convertPatternGroupsToTasks(u, t, r)) } return i } t.convertPatternsToTasks = convertPatternsToTasks; function getPositivePatterns(e) { return n.pattern.getPositivePatterns(e) } t.getPositivePatterns = getPositivePatterns; function getNegativePatternsAsPositive(e, t) { const r = n.pattern.getNegativePatterns(e).concat(t); const i = r.map(n.pattern.convertToPositivePattern); return i } t.getNegativePatternsAsPositive = getNegativePatternsAsPositive; function groupPatternsByBaseDirectory(e) { const t = {}; return e.reduce(((e, t) => { const r = n.pattern.getBaseDirectory(t); if (r in e) { e[r].push(t) } else { e[r] = [t] } return e }), t) } t.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory; function convertPatternGroupsToTasks(e, t, r) { return Object.keys(e).map((n => convertPatternGroupToTask(n, e[n], t, r))) } t.convertPatternGroupsToTasks = convertPatternGroupsToTasks; function convertPatternGroupToTask(e, t, r, i) { return { dynamic: i, positive: t, negative: r, base: e, patterns: [].concat(t, r.map(n.pattern.convertToNegativePattern)) } } t.convertPatternGroupToTask = convertPatternGroupToTask }, 5679: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); const n = r(7747); const i = r(257); class ProviderAsync extends i.default { constructor() { super(...arguments); this._reader = new n.default(this._settings) } async read(e) { const t = this._getRootDirectory(e); const r = this._getReaderOptions(e); const n = await this.api(t, e, r); return n.map((e => r.transform(e))) } api(e, t, r) { if (t.dynamic) { return this._reader.dynamic(e, r) } return this._reader.static(t.patterns, r) } } t["default"] = ProviderAsync }, 6983: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); const n = r(5444); const i = r(5295); class DeepFilter { constructor(e, t) { this._settings = e; this._micromatchOptions = t } getFilter(e, t, r) { const n = this._getMatcher(t); const i = this._getNegativePatternsRe(r); return t => this._filter(e, t, n, i) } _getMatcher(e) { return new i.default(e, this._settings, this._micromatchOptions) } _getNegativePatternsRe(e) { const t = e.filter(n.pattern.isAffectDepthOfReadingPattern); return n.pattern.convertPatternsToRe(t, this._micromatchOptions) } _filter(e, t, r, i) { if (this._isSkippedByDeep(e, t.path)) { return false } if (this._isSkippedSymbolicLink(t)) { return false } const s = n.path.removeLeadingDotSegment(t.path); if (this._isSkippedByPositivePatterns(s, r)) { return false } return this._isSkippedByNegativePatterns(s, i) } _isSkippedByDeep(e, t) { if (this._settings.deep === Infinity) { return false } return this._getEntryLevel(e, t) >= this._settings.deep } _getEntryLevel(e, t) { const r = t.split("/").length; if (e === "") { return r } const n = e.split("/").length; return r - n } _isSkippedSymbolicLink(e) { return !this._settings.followSymbolicLinks && e.dirent.isSymbolicLink() } _isSkippedByPositivePatterns(e, t) { return !this._settings.baseNameMatch && !t.match(e) } _isSkippedByNegativePatterns(e, t) { return !n.pattern.matchAny(e, t) } } t["default"] = DeepFilter }, 1343: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); const n = r(5444); class EntryFilter { constructor(e, t) { this._settings = e; this._micromatchOptions = t; this.index = new Map } getFilter(e, t) { const r = n.pattern.convertPatternsToRe(e, this._micromatchOptions); const i = n.pattern.convertPatternsToRe(t, this._micromatchOptions); return e => this._filter(e, r, i) } _filter(e, t, r) { if (this._settings.unique && this._isDuplicateEntry(e)) { return false } if (this._onlyFileFilter(e) || this._onlyDirectoryFilter(e)) { return false } if (this._isSkippedByAbsoluteNegativePatterns(e.path, r)) { return false } const n = this._settings.baseNameMatch ? e.name : e.path; const i = e.dirent.isDirectory(); const s = this._isMatchToPatterns(n, t, i) && !this._isMatchToPatterns(e.path, r, i); if (this._settings.unique && s) { this._createIndexRecord(e) } return s } _isDuplicateEntry(e) { return this.index.has(e.path) } _createIndexRecord(e) { this.index.set(e.path, undefined) } _onlyFileFilter(e) { return this._settings.onlyFiles && !e.dirent.isFile() } _onlyDirectoryFilter(e) { return this._settings.onlyDirectories && !e.dirent.isDirectory() } _isSkippedByAbsoluteNegativePatterns(e, t) { if (!this._settings.absolute) { return false } const r = n.path.makeAbsolute(this._settings.cwd, e); return n.pattern.matchAny(r, t) } _isMatchToPatterns(e, t, r) { const i = n.path.removeLeadingDotSegment(e); const s = n.pattern.matchAny(i, t); if (!s && r) { return n.pattern.matchAny(i + "/", t) } return s } } t["default"] = EntryFilter }, 6654: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); const n = r(5444); class ErrorFilter { constructor(e) { this._settings = e } getFilter() { return e => this._isNonFatalError(e) } _isNonFatalError(e) { return n.errno.isEnoentCodeError(e) || this._settings.suppressErrors } } t["default"] = ErrorFilter }, 2576: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); const n = r(5444); class Matcher { constructor(e, t, r) { this._patterns = e; this._settings = t; this._micromatchOptions = r; this._storage = []; this._fillStorage() } _fillStorage() { const e = n.pattern.expandPatternsWithBraceExpansion(this._patterns); for (const t of e) { const e = this._getPatternSegments(t); const r = this._splitSegmentsIntoSections(e); this._storage.push({ complete: r.length <= 1, pattern: t, segments: e, sections: r }) } } _getPatternSegments(e) { const t = n.pattern.getPatternParts(e, this._micromatchOptions); return t.map((e => { const t = n.pattern.isDynamicPattern(e, this._settings); if (!t) { return { dynamic: false, pattern: e } } return { dynamic: true, pattern: e, patternRe: n.pattern.makeRe(e, this._micromatchOptions) } })) } _splitSegmentsIntoSections(e) { return n.array.splitWhen(e, (e => e.dynamic && n.pattern.hasGlobStar(e.pattern))) } } t["default"] = Matcher }, 5295: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); const n = r(2576); class PartialMatcher extends n.default { match(e) { const t = e.split("/"); const r = t.length; const n = this._storage.filter((e => !e.complete || e.segments.length > r)); for (const e of n) { const n = e.sections[0]; if (!e.complete && r > n.length) { return true } const i = t.every(((t, r) => { const n = e.segments[r]; if (n.dynamic && n.patternRe.test(t)) { return true } if (!n.dynamic && n.pattern === t) { return true } return false })); if (i) { return true } } return false } } t["default"] = PartialMatcher }, 257: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); const n = r(1017); const i = r(6983); const s = r(1343); const o = r(6654); const a = r(4029); class Provider { constructor(e) { this._settings = e; this.errorFilter = new o.default(this._settings); this.entryFilter = new s.default(this._settings, this._getMicromatchOptions()); this.deepFilter = new i.default(this._settings, this._getMicromatchOptions()); this.entryTransformer = new a.default(this._settings) } _getRootDirectory(e) { return n.resolve(this._settings.cwd, e.base) } _getReaderOptions(e) { const t = e.base === "." ? "" : e.base; return { basePath: t, pathSegmentSeparator: "/", concurrency: this._settings.concurrency, deepFilter: this.deepFilter.getFilter(t, e.positive, e.negative), entryFilter: this.entryFilter.getFilter(e.positive, e.negative), errorFilter: this.errorFilter.getFilter(), followSymbolicLinks: this._settings.followSymbolicLinks, fs: this._settings.fs, stats: this._settings.stats, throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink, transform: this.entryTransformer.getTransformer() } } _getMicromatchOptions() { return { dot: this._settings.dot, matchBase: this._settings.baseNameMatch, nobrace: !this._settings.braceExpansion, nocase: !this._settings.caseSensitiveMatch, noext: !this._settings.extglob, noglobstar: !this._settings.globstar, posix: true, strictSlashes: false } } } t["default"] = Provider }, 4630: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); const n = r(2781); const i = r(2083); const s = r(257); class ProviderStream extends s.default { constructor() { super(...arguments); this._reader = new i.default(this._settings) } read(e) { const t = this._getRootDirectory(e); const r = this._getReaderOptions(e); const i = this.api(t, e, r); const s = new n.Readable({ objectMode: true, read: () => { } }); i.once("error", (e => s.emit("error", e))).on("data", (e => s.emit("data", r.transform(e)))).once("end", (() => s.emit("end"))); s.once("close", (() => i.destroy())); return s } api(e, t, r) { if (t.dynamic) { return this._reader.dynamic(e, r) } return this._reader.static(t.patterns, r) } } t["default"] = ProviderStream }, 2405: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); const n = r(6234); const i = r(257); class ProviderSync extends i.default { constructor() { super(...arguments); this._reader = new n.default(this._settings) } read(e) { const t = this._getRootDirectory(e); const r = this._getReaderOptions(e); const n = this.api(t, e, r); return n.map(r.transform) } api(e, t, r) { if (t.dynamic) { return this._reader.dynamic(e, r) } return this._reader.static(t.patterns, r) } } t["default"] = ProviderSync }, 4029: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); const n = r(5444); class EntryTransformer { constructor(e) { this._settings = e } getTransformer() { return e => this._transform(e) } _transform(e) { let t = e.path; if (this._settings.absolute) { t = n.path.makeAbsolute(this._settings.cwd, t); t = n.path.unixify(t) } if (this._settings.markDirectories && e.dirent.isDirectory()) { t += "/" } if (!this._settings.objectMode) { return t } return Object.assign(Object.assign({}, e), { path: t }) } } t["default"] = EntryTransformer }, 7747: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); const n = r(6026); const i = r(5582); const s = r(2083); class ReaderAsync extends i.default { constructor() { super(...arguments); this._walkAsync = n.walk; this._readerStream = new s.default(this._settings) } dynamic(e, t) { return new Promise(((r, n) => { this._walkAsync(e, t, ((e, t) => { if (e === null) { r(t) } else { n(e) } })) })) } async static(e, t) { const r = []; const n = this._readerStream.static(e, t); return new Promise(((e, t) => { n.once("error", t); n.on("data", (e => r.push(e))); n.once("end", (() => e(r))) })) } } t["default"] = ReaderAsync }, 5582: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); const n = r(1017); const i = r(109); const s = r(5444); class Reader { constructor(e) { this._settings = e; this._fsStatSettings = new i.Settings({ followSymbolicLink: this._settings.followSymbolicLinks, fs: this._settings.fs, throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks }) } _getFullEntryPath(e) { return n.resolve(this._settings.cwd, e) } _makeEntry(e, t) { const r = { name: t, path: t, dirent: s.fs.createDirentFromStats(t, e) }; if (this._settings.stats) { r.stats = e } return r } _isFatalError(e) { return !s.errno.isEnoentCodeError(e) && !this._settings.suppressErrors } } t["default"] = Reader }, 2083: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); const n = r(2781); const i = r(109); const s = r(6026); const o = r(5582); class ReaderStream extends o.default { constructor() { super(...arguments); this._walkStream = s.walkStream; this._stat = i.stat } dynamic(e, t) { return this._walkStream(e, t) } static(e, t) { const r = e.map(this._getFullEntryPath, this); const i = new n.PassThrough({ objectMode: true }); i._write = (n, s, o) => this._getEntry(r[n], e[n], t).then((e => { if (e !== null && t.entryFilter(e)) { i.push(e) } if (n === r.length - 1) { i.end() } o() })).catch(o); for (let e = 0; e < r.length; e++) { i.write(e) } return i } _getEntry(e, t, r) { return this._getStat(e).then((e => this._makeEntry(e, t))).catch((e => { if (r.errorFilter(e)) { return null } throw e })) } _getStat(e) { return new Promise(((t, r) => { this._stat(e, this._fsStatSettings, ((e, n) => e === null ? t(n) : r(e))) })) } } t["default"] = ReaderStream }, 6234: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); const n = r(109); const i = r(6026); const s = r(5582); class ReaderSync extends s.default { constructor() { super(...arguments); this._walkSync = i.walkSync; this._statSync = n.statSync } dynamic(e, t) { return this._walkSync(e, t) } static(e, t) { const r = []; for (const n of e) { const e = this._getFullEntryPath(n); const i = this._getEntry(e, n, t); if (i === null || !t.entryFilter(i)) { continue } r.push(i) } return r } _getEntry(e, t, r) { try { const r = this._getStat(e); return this._makeEntry(r, t) } catch (e) { if (r.errorFilter(e)) { return null } throw e } } _getStat(e) { return this._statSync(e, this._fsStatSettings) } } t["default"] = ReaderSync }, 952: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t.DEFAULT_FILE_SYSTEM_ADAPTER = void 0; const n = r(7147); const i = r(2037); const s = Math.max(i.cpus().length, 1); t.DEFAULT_FILE_SYSTEM_ADAPTER = { lstat: n.lstat, lstatSync: n.lstatSync, stat: n.stat, statSync: n.statSync, readdir: n.readdir, readdirSync: n.readdirSync }; class Settings { constructor(e = {}) { this._options = e; this.absolute = this._getValue(this._options.absolute, false); this.baseNameMatch = this._getValue(this._options.baseNameMatch, false); this.braceExpansion = this._getValue(this._options.braceExpansion, true); this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true); this.concurrency = this._getValue(this._options.concurrency, s); this.cwd = this._getValue(this._options.cwd, process.cwd()); this.deep = this._getValue(this._options.deep, Infinity); this.dot = this._getValue(this._options.dot, false); this.extglob = this._getValue(this._options.extglob, true); this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true); this.fs = this._getFileSystemMethods(this._options.fs); this.globstar = this._getValue(this._options.globstar, true); this.ignore = this._getValue(this._options.ignore, []); this.markDirectories = this._getValue(this._options.markDirectories, false); this.objectMode = this._getValue(this._options.objectMode, false); this.onlyDirectories = this._getValue(this._options.onlyDirectories, false); this.onlyFiles = this._getValue(this._options.onlyFiles, true); this.stats = this._getValue(this._options.stats, false); this.suppressErrors = this._getValue(this._options.suppressErrors, false); this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false); this.unique = this._getValue(this._options.unique, true); if (this.onlyDirectories) { this.onlyFiles = false } if (this.stats) { this.objectMode = true } } _getValue(e, t) { return e === undefined ? t : e } _getFileSystemMethods(e = {}) { return Object.assign(Object.assign({}, t.DEFAULT_FILE_SYSTEM_ADAPTER), e) } } t["default"] = Settings }, 5325: (e, t) => { Object.defineProperty(t, "__esModule", { value: true }); t.splitWhen = t.flatten = void 0; function flatten(e) { return e.reduce(((e, t) => [].concat(e, t)), []) } t.flatten = flatten; function splitWhen(e, t) { const r = [[]]; let n = 0; for (const i of e) { if (t(i)) { n++; r[n] = [] } else { r[n].push(i) } } return r } t.splitWhen = splitWhen }, 1230: (e, t) => { Object.defineProperty(t, "__esModule", { value: true }); t.isEnoentCodeError = void 0; function isEnoentCodeError(e) { return e.code === "ENOENT" } t.isEnoentCodeError = isEnoentCodeError }, 7543: (e, t) => { Object.defineProperty(t, "__esModule", { value: true }); t.createDirentFromStats = void 0; class DirentFromStats { constructor(e, t) { this.name = e; this.isBlockDevice = t.isBlockDevice.bind(t); this.isCharacterDevice = t.isCharacterDevice.bind(t); this.isDirectory = t.isDirectory.bind(t); this.isFIFO = t.isFIFO.bind(t); this.isFile = t.isFile.bind(t); this.isSocket = t.isSocket.bind(t); this.isSymbolicLink = t.isSymbolicLink.bind(t) } } function createDirentFromStats(e, t) { return new DirentFromStats(e, t) } t.createDirentFromStats = createDirentFromStats }, 5444: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t.string = t.stream = t.pattern = t.path = t.fs = t.errno = t.array = void 0; const n = r(5325); t.array = n; const i = r(1230); t.errno = i; const s = r(7543); t.fs = s; const o = r(3873); t.path = o; const a = r(1221); t.pattern = a; const u = r(8382); t.stream = u; const l = r(2203); t.string = l }, 3873: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t.removeLeadingDotSegment = t.escape = t.makeAbsolute = t.unixify = void 0; const n = r(1017); const i = 2; const s = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\())/g; function unixify(e) { return e.replace(/\\/g, "/") } t.unixify = unixify; function makeAbsolute(e, t) { return n.resolve(e, t) } t.makeAbsolute = makeAbsolute; function escape(e) { return e.replace(s, "\\$2") } t.escape = escape; function removeLeadingDotSegment(e) { if (e.charAt(0) === ".") { const t = e.charAt(1); if (t === "/" || t === "\\") { return e.slice(i) } } return e } t.removeLeadingDotSegment = removeLeadingDotSegment }, 1221: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t.matchAny = t.convertPatternsToRe = t.makeRe = t.getPatternParts = t.expandBraceExpansion = t.expandPatternsWithBraceExpansion = t.isAffectDepthOfReadingPattern = t.endsWithSlashGlobStar = t.hasGlobStar = t.getBaseDirectory = t.isPatternRelatedToParentDirectory = t.getPatternsOutsideCurrentDirectory = t.getPatternsInsideCurrentDirectory = t.getPositivePatterns = t.getNegativePatterns = t.isPositivePattern = t.isNegativePattern = t.convertToNegativePattern = t.convertToPositivePattern = t.isDynamicPattern = t.isStaticPattern = void 0; const n = r(1017); const i = r(4655); const s = r(6228); const o = "**"; const a = "\\"; const u = /[*?]|^!/; const l = /\[[^[]*]/; const f = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/; const d = /[!*+?@]\([^(]*\)/; const p = /,|\.\./; function isStaticPattern(e, t = {}) { return !isDynamicPattern(e, t) } t.isStaticPattern = isStaticPattern; function isDynamicPattern(e, t = {}) { if (e === "") { return false } if (t.caseSensitiveMatch === false || e.includes(a)) { return true } if (u.test(e) || l.test(e) || f.test(e)) { return true } if (t.extglob !== false && d.test(e)) { return true } if (t.braceExpansion !== false && hasBraceExpansion(e)) { return true } return false } t.isDynamicPattern = isDynamicPattern; function hasBraceExpansion(e) { const t = e.indexOf("{"); if (t === -1) { return false } const r = e.indexOf("}", t + 1); if (r === -1) { return false } const n = e.slice(t, r); return p.test(n) } function convertToPositivePattern(e) { return isNegativePattern(e) ? e.slice(1) : e } t.convertToPositivePattern = convertToPositivePattern; function convertToNegativePattern(e) { return "!" + e } t.convertToNegativePattern = convertToNegativePattern; function isNegativePattern(e) { return e.startsWith("!") && e[1] !== "(" } t.isNegativePattern = isNegativePattern; function isPositivePattern(e) { return !isNegativePattern(e) } t.isPositivePattern = isPositivePattern; function getNegativePatterns(e) { return e.filter(isNegativePattern) } t.getNegativePatterns = getNegativePatterns; function getPositivePatterns(e) { return e.filter(isPositivePattern) } t.getPositivePatterns = getPositivePatterns; function getPatternsInsideCurrentDirectory(e) { return e.filter((e => !isPatternRelatedToParentDirectory(e))) } t.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory; function getPatternsOutsideCurrentDirectory(e) { return e.filter(isPatternRelatedToParentDirectory) } t.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory; function isPatternRelatedToParentDirectory(e) { return e.startsWith("..") || e.startsWith("./..") } t.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory; function getBaseDirectory(e) { return i(e, { flipBackslashes: false }) } t.getBaseDirectory = getBaseDirectory; function hasGlobStar(e) { return e.includes(o) } t.hasGlobStar = hasGlobStar; function endsWithSlashGlobStar(e) { return e.endsWith("/" + o) } t.endsWithSlashGlobStar = endsWithSlashGlobStar; function isAffectDepthOfReadingPattern(e) { const t = n.basename(e); return endsWithSlashGlobStar(e) || isStaticPattern(t) } t.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern; function expandPatternsWithBraceExpansion(e) { return e.reduce(((e, t) => e.concat(expandBraceExpansion(t))), []) } t.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion; function expandBraceExpansion(e) { return s.braces(e, { expand: true, nodupes: true }) } t.expandBraceExpansion = expandBraceExpansion; function getPatternParts(e, t) { let { parts: r } = s.scan(e, Object.assign(Object.assign({}, t), { parts: true })); if (r.length === 0) { r = [e] } if (r[0].startsWith("/")) { r[0] = r[0].slice(1); r.unshift("") } return r } t.getPatternParts = getPatternParts; function makeRe(e, t) { return s.makeRe(e, t) } t.makeRe = makeRe; function convertPatternsToRe(e, t) { return e.map((e => makeRe(e, t))) } t.convertPatternsToRe = convertPatternsToRe; function matchAny(e, t) { return t.some((t => t.test(e))) } t.matchAny = matchAny }, 8382: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t.merge = void 0; const n = r(2578); function merge(e) { const t = n(e); e.forEach((e => { e.once("error", (e => t.emit("error", e))) })); t.once("close", (() => propagateCloseEventToSources(e))); t.once("end", (() => propagateCloseEventToSources(e))); return t } t.merge = merge; function propagateCloseEventToSources(e) { e.forEach((e => e.emit("close"))) } }, 2203: (e, t) => { Object.defineProperty(t, "__esModule", { value: true }); t.isEmpty = t.isString = void 0; function isString(e) { return typeof e === "string" } t.isString = isString; function isEmpty(e) { return e === "" } t.isEmpty = isEmpty }, 7340: (e, t, r) => { var n = r(2113); function fastqueue(e, t, r) { if (typeof e === "function") { r = t; t = e; e = null } if (r < 1) { throw new Error("fastqueue concurrency must be greater than 1") } var i = n(Task); var s = null; var o = null; var a = 0; var u = null; var l = { push: push, drain: noop, saturated: noop, pause: pause, paused: false, concurrency: r, running: running, resume: resume, idle: idle, length: length, getQueue: getQueue, unshift: unshift, empty: noop, kill: kill, killAndDrain: killAndDrain, error: error }; return l; function running() { return a } function pause() { l.paused = true } function length() { var e = s; var t = 0; while (e) { e = e.next; t++ } return t } function getQueue() { var e = s; var t = []; while (e) { t.push(e.value); e = e.next } return t } function resume() { if (!l.paused) return; l.paused = false; for (var e = 0; e < l.concurrency; e++) { a++; release() } } function idle() { return a === 0 && l.length() === 0 } function push(r, n) { var f = i.get(); f.context = e; f.release = release; f.value = r; f.callback = n || noop; f.errorHandler = u; if (a === l.concurrency || l.paused) { if (o) { o.next = f; o = f } else { s = f; o = f; l.saturated() } } else { a++; t.call(e, f.value, f.worked) } } function unshift(r, n) { var u = i.get(); u.context = e; u.release = release; u.value = r; u.callback = n || noop; if (a === l.concurrency || l.paused) { if (s) { u.next = s; s = u } else { s = u; o = u; l.saturated() } } else { a++; t.call(e, u.value, u.worked) } } function release(r) { if (r) { i.release(r) } var n = s; if (n) { if (!l.paused) { if (o === s) { o = null } s = n.next; n.next = null; t.call(e, n.value, n.worked); if (o === null) { l.empty() } } else { a-- } } else if (--a === 0) { l.drain() } } function kill() { s = null; o = null; l.drain = noop } function killAndDrain() { s = null; o = null; l.drain(); l.drain = noop } function error(e) { u = e } } function noop() { } function Task() { this.value = null; this.callback = noop; this.next = null; this.release = noop; this.context = null; this.errorHandler = null; var e = this; this.worked = function worked(t, r) { var n = e.callback; var i = e.errorHandler; var s = e.value; e.value = null; e.callback = noop; if (e.errorHandler) { i(t, s) } n.call(e.context, t, r); e.release(e) } } function queueAsPromised(e, t, r) { if (typeof e === "function") { r = t; t = e; e = null } function asyncWrapper(e, r) { t.call(this, e).then((function (e) { r(null, e) }), r) } var n = fastqueue(e, asyncWrapper, r); var i = n.push; var s = n.unshift; n.push = push; n.unshift = unshift; n.drained = drained; return n; function push(e) { var t = new Promise((function (t, r) { i(e, (function (e, n) { if (e) { r(e); return } t(n) })) })); t.catch(noop); return t } function unshift(e) { var t = new Promise((function (t, r) { s(e, (function (e, n) { if (e) { r(e); return } t(n) })) })); t.catch(noop); return t } function drained() { if (n.idle()) { return new Promise((function (e) { e() })) } var e = n.drain; var t = new Promise((function (t) { n.drain = function () { e(); t() } })); return t } } e.exports = fastqueue; e.exports.promise = queueAsPromised }, 6330: (e, t, r) => {
    /*!
     * fill-range <https://github.com/jonschlinkert/fill-range>
     *
     * Copyright (c) 2014-present, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    const n = r(3837); const i = r(1861); const isObject = e => e !== null && typeof e === "object" && !Array.isArray(e); const transform = e => t => e === true ? Number(t) : String(t); const isValidValue = e => typeof e === "number" || typeof e === "string" && e !== ""; const isNumber = e => Number.isInteger(+e); const zeros = e => { let t = `${e}`; let r = -1; if (t[0] === "-") t = t.slice(1); if (t === "0") return false; while (t[++r] === "0"); return r > 0 }; const stringify = (e, t, r) => { if (typeof e === "string" || typeof t === "string") { return true } return r.stringify === true }; const pad = (e, t, r) => { if (t > 0) { let r = e[0] === "-" ? "-" : ""; if (r) e = e.slice(1); e = r + e.padStart(r ? t - 1 : t, "0") } if (r === false) { return String(e) } return e }; const toMaxLen = (e, t) => { let r = e[0] === "-" ? "-" : ""; if (r) { e = e.slice(1); t-- } while (e.length < t) e = "0" + e; return r ? "-" + e : e }; const toSequence = (e, t) => { e.negatives.sort(((e, t) => e < t ? -1 : e > t ? 1 : 0)); e.positives.sort(((e, t) => e < t ? -1 : e > t ? 1 : 0)); let r = t.capture ? "" : "?:"; let n = ""; let i = ""; let s; if (e.positives.length) { n = e.positives.join("|") } if (e.negatives.length) { i = `-(${r}${e.negatives.join("|")})` } if (n && i) { s = `${n}|${i}` } else { s = n || i } if (t.wrap) { return `(${r}${s})` } return s }; const toRange = (e, t, r, n) => { if (r) { return i(e, t, { wrap: false, ...n }) } let s = String.fromCharCode(e); if (e === t) return s; let o = String.fromCharCode(t); return `[${s}-${o}]` }; const toRegex = (e, t, r) => { if (Array.isArray(e)) { let t = r.wrap === true; let n = r.capture ? "" : "?:"; return t ? `(${n}${e.join("|")})` : e.join("|") } return i(e, t, r) }; const rangeError = (...e) => new RangeError("Invalid range arguments: " + n.inspect(...e)); const invalidRange = (e, t, r) => { if (r.strictRanges === true) throw rangeError([e, t]); return [] }; const invalidStep = (e, t) => { if (t.strictRanges === true) { throw new TypeError(`Expected step "${e}" to be a number`) } return [] }; const fillNumbers = (e, t, r = 1, n = {}) => { let i = Number(e); let s = Number(t); if (!Number.isInteger(i) || !Number.isInteger(s)) { if (n.strictRanges === true) throw rangeError([e, t]); return [] } if (i === 0) i = 0; if (s === 0) s = 0; let o = i > s; let a = String(e); let u = String(t); let l = String(r); r = Math.max(Math.abs(r), 1); let f = zeros(a) || zeros(u) || zeros(l); let d = f ? Math.max(a.length, u.length, l.length) : 0; let p = f === false && stringify(e, t, n) === false; let h = n.transform || transform(p); if (n.toRegex && r === 1) { return toRange(toMaxLen(e, d), toMaxLen(t, d), true, n) } let m = { negatives: [], positives: [] }; let push = e => m[e < 0 ? "negatives" : "positives"].push(Math.abs(e)); let g = []; let y = 0; while (o ? i >= s : i <= s) { if (n.toRegex === true && r > 1) { push(i) } else { g.push(pad(h(i, y), d, p)) } i = o ? i - r : i + r; y++ } if (n.toRegex === true) { return r > 1 ? toSequence(m, n) : toRegex(g, null, { wrap: false, ...n }) } return g }; const fillLetters = (e, t, r = 1, n = {}) => { if (!isNumber(e) && e.length > 1 || !isNumber(t) && t.length > 1) { return invalidRange(e, t, n) } let i = n.transform || (e => String.fromCharCode(e)); let s = `${e}`.charCodeAt(0); let o = `${t}`.charCodeAt(0); let a = s > o; let u = Math.min(s, o); let l = Math.max(s, o); if (n.toRegex && r === 1) { return toRange(u, l, false, n) } let f = []; let d = 0; while (a ? s >= o : s <= o) { f.push(i(s, d)); s = a ? s - r : s + r; d++ } if (n.toRegex === true) { return toRegex(f, null, { wrap: false, options: n }) } return f }; const fill = (e, t, r, n = {}) => { if (t == null && isValidValue(e)) { return [e] } if (!isValidValue(e) || !isValidValue(t)) { return invalidRange(e, t, n) } if (typeof r === "function") { return fill(e, t, 1, { transform: r }) } if (isObject(r)) { return fill(e, t, 0, r) } let i = { ...n }; if (i.capture === true) i.wrap = true; r = r || i.step || 1; if (!isNumber(r)) { if (r != null && !isObject(r)) return invalidStep(r, i); return fill(e, t, 1, r) } if (isNumber(e) && isNumber(t)) { return fillNumbers(e, t, r, i) } return fillLetters(e, t, Math.max(Math.abs(r), 1), i) }; e.exports = fill
  }, 9618: (e, t, r) => { const n = r(7758); const i = r(1017); const s = r(8605).mkdirsSync; const o = r(2548).utimesMillisSync; const a = r(3901); function copySync(e, t, r) { if (typeof r === "function") { r = { filter: r } } r = r || {}; r.clobber = "clobber" in r ? !!r.clobber : true; r.overwrite = "overwrite" in r ? !!r.overwrite : r.clobber; if (r.preserveTimestamps && process.arch === "ia32") { process.emitWarning("Using the preserveTimestamps option in 32-bit node is not recommended;\n\n" + "\tsee https://github.com/jprichardson/node-fs-extra/issues/269", "Warning", "fs-extra-WARN0002") } const { srcStat: o, destStat: u } = a.checkPathsSync(e, t, "copy", r); a.checkParentPathsSync(e, o, t, "copy"); if (r.filter && !r.filter(e, t)) return; const l = i.dirname(t); if (!n.existsSync(l)) s(l); return getStats(u, e, t, r) } function getStats(e, t, r, i) { const s = i.dereference ? n.statSync : n.lstatSync; const o = s(t); if (o.isDirectory()) return onDir(o, e, t, r, i); else if (o.isFile() || o.isCharacterDevice() || o.isBlockDevice()) return onFile(o, e, t, r, i); else if (o.isSymbolicLink()) return onLink(e, t, r, i); else if (o.isSocket()) throw new Error(`Cannot copy a socket file: ${t}`); else if (o.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${t}`); throw new Error(`Unknown file: ${t}`) } function onFile(e, t, r, n, i) { if (!t) return copyFile(e, r, n, i); return mayCopyFile(e, r, n, i) } function mayCopyFile(e, t, r, i) { if (i.overwrite) { n.unlinkSync(r); return copyFile(e, t, r, i) } else if (i.errorOnExist) { throw new Error(`'${r}' already exists`) } } function copyFile(e, t, r, i) { n.copyFileSync(t, r); if (i.preserveTimestamps) handleTimestamps(e.mode, t, r); return setDestMode(r, e.mode) } function handleTimestamps(e, t, r) { if (fileIsNotWritable(e)) makeFileWritable(r, e); return setDestTimestamps(t, r) } function fileIsNotWritable(e) { return (e & 128) === 0 } function makeFileWritable(e, t) { return setDestMode(e, t | 128) } function setDestMode(e, t) { return n.chmodSync(e, t) } function setDestTimestamps(e, t) { const r = n.statSync(e); return o(t, r.atime, r.mtime) } function onDir(e, t, r, n, i) { if (!t) return mkDirAndCopy(e.mode, r, n, i); return copyDir(r, n, i) } function mkDirAndCopy(e, t, r, i) { n.mkdirSync(r); copyDir(t, r, i); return setDestMode(r, e) } function copyDir(e, t, r) { n.readdirSync(e).forEach((n => copyDirItem(n, e, t, r))) } function copyDirItem(e, t, r, n) { const s = i.join(t, e); const o = i.join(r, e); if (n.filter && !n.filter(s, o)) return; const { destStat: u } = a.checkPathsSync(s, o, "copy", n); return getStats(u, s, o, n) } function onLink(e, t, r, s) { let o = n.readlinkSync(t); if (s.dereference) { o = i.resolve(process.cwd(), o) } if (!e) { return n.symlinkSync(o, r) } else { let e; try { e = n.readlinkSync(r) } catch (e) { if (e.code === "EINVAL" || e.code === "UNKNOWN") return n.symlinkSync(o, r); throw e } if (s.dereference) { e = i.resolve(process.cwd(), e) } if (a.isSrcSubdir(o, e)) { throw new Error(`Cannot copy '${o}' to a subdirectory of itself, '${e}'.`) } if (a.isSrcSubdir(e, o)) { throw new Error(`Cannot overwrite '${e}' with '${o}'.`) } return copyLink(o, r) } } function copyLink(e, t) { n.unlinkSync(t); return n.symlinkSync(e, t) } e.exports = copySync }, 8834: (e, t, r) => { const n = r(7758); const i = r(1017); const s = r(8605).mkdirs; const o = r(3835).pathExists; const a = r(2548).utimesMillis; const u = r(3901); function copy(e, t, r, n) { if (typeof r === "function" && !n) { n = r; r = {} } else if (typeof r === "function") { r = { filter: r } } n = n || function () { }; r = r || {}; r.clobber = "clobber" in r ? !!r.clobber : true; r.overwrite = "overwrite" in r ? !!r.overwrite : r.clobber; if (r.preserveTimestamps && process.arch === "ia32") { process.emitWarning("Using the preserveTimestamps option in 32-bit node is not recommended;\n\n" + "\tsee https://github.com/jprichardson/node-fs-extra/issues/269", "Warning", "fs-extra-WARN0001") } u.checkPaths(e, t, "copy", r, ((i, s) => { if (i) return n(i); const { srcStat: o, destStat: a } = s; u.checkParentPaths(e, o, t, "copy", (i => { if (i) return n(i); runFilter(e, t, r, ((i, s) => { if (i) return n(i); if (!s) return n(); checkParentDir(a, e, t, r, n) })) })) })) } function checkParentDir(e, t, r, n, a) { const u = i.dirname(r); o(u, ((i, o) => { if (i) return a(i); if (o) return getStats(e, t, r, n, a); s(u, (i => { if (i) return a(i); return getStats(e, t, r, n, a) })) })) } function runFilter(e, t, r, n) { if (!r.filter) return n(null, true); Promise.resolve(r.filter(e, t)).then((e => n(null, e)), (e => n(e))) } function getStats(e, t, r, i, s) { const o = i.dereference ? n.stat : n.lstat; o(t, ((n, o) => { if (n) return s(n); if (o.isDirectory()) return onDir(o, e, t, r, i, s); else if (o.isFile() || o.isCharacterDevice() || o.isBlockDevice()) return onFile(o, e, t, r, i, s); else if (o.isSymbolicLink()) return onLink(e, t, r, i, s); else if (o.isSocket()) return s(new Error(`Cannot copy a socket file: ${t}`)); else if (o.isFIFO()) return s(new Error(`Cannot copy a FIFO pipe: ${t}`)); return s(new Error(`Unknown file: ${t}`)) })) } function onFile(e, t, r, n, i, s) { if (!t) return copyFile(e, r, n, i, s); return mayCopyFile(e, r, n, i, s) } function mayCopyFile(e, t, r, i, s) { if (i.overwrite) { n.unlink(r, (n => { if (n) return s(n); return copyFile(e, t, r, i, s) })) } else if (i.errorOnExist) { return s(new Error(`'${r}' already exists`)) } else return s() } function copyFile(e, t, r, i, s) { n.copyFile(t, r, (n => { if (n) return s(n); if (i.preserveTimestamps) return handleTimestampsAndMode(e.mode, t, r, s); return setDestMode(r, e.mode, s) })) } function handleTimestampsAndMode(e, t, r, n) { if (fileIsNotWritable(e)) { return makeFileWritable(r, e, (i => { if (i) return n(i); return setDestTimestampsAndMode(e, t, r, n) })) } return setDestTimestampsAndMode(e, t, r, n) } function fileIsNotWritable(e) { return (e & 128) === 0 } function makeFileWritable(e, t, r) { return setDestMode(e, t | 128, r) } function setDestTimestampsAndMode(e, t, r, n) { setDestTimestamps(t, r, (t => { if (t) return n(t); return setDestMode(r, e, n) })) } function setDestMode(e, t, r) { return n.chmod(e, t, r) } function setDestTimestamps(e, t, r) { n.stat(e, ((e, n) => { if (e) return r(e); return a(t, n.atime, n.mtime, r) })) } function onDir(e, t, r, n, i, s) { if (!t) return mkDirAndCopy(e.mode, r, n, i, s); return copyDir(r, n, i, s) } function mkDirAndCopy(e, t, r, i, s) { n.mkdir(r, (n => { if (n) return s(n); copyDir(t, r, i, (t => { if (t) return s(t); return setDestMode(r, e, s) })) })) } function copyDir(e, t, r, i) { n.readdir(e, ((n, s) => { if (n) return i(n); return copyDirItems(s, e, t, r, i) })) } function copyDirItems(e, t, r, n, i) { const s = e.pop(); if (!s) return i(); return copyDirItem(e, s, t, r, n, i) } function copyDirItem(e, t, r, n, s, o) { const a = i.join(r, t); const l = i.join(n, t); runFilter(a, l, s, ((t, i) => { if (t) return o(t); if (!i) return copyDirItems(e, r, n, s, o); u.checkPaths(a, l, "copy", s, ((t, i) => { if (t) return o(t); const { destStat: u } = i; getStats(u, a, l, s, (t => { if (t) return o(t); return copyDirItems(e, r, n, s, o) })) })) })) } function onLink(e, t, r, s, o) { n.readlink(t, ((t, a) => { if (t) return o(t); if (s.dereference) { a = i.resolve(process.cwd(), a) } if (!e) { return n.symlink(a, r, o) } else { n.readlink(r, ((e, t) => { if (e) { if (e.code === "EINVAL" || e.code === "UNKNOWN") return n.symlink(a, r, o); return o(e) } if (s.dereference) { t = i.resolve(process.cwd(), t) } if (u.isSrcSubdir(a, t)) { return o(new Error(`Cannot copy '${a}' to a subdirectory of itself, '${t}'.`)) } if (u.isSrcSubdir(t, a)) { return o(new Error(`Cannot overwrite '${t}' with '${a}'.`)) } return copyLink(a, r, o) })) } })) } function copyLink(e, t, r) { n.unlink(t, (i => { if (i) return r(i); return n.symlink(e, t, r) })) } e.exports = copy }, 1335: (e, t, r) => { const n = r(9046).fromCallback; e.exports = { copy: n(r(8834)), copySync: r(9618) } }, 6970: (e, t, r) => { const n = r(9046).fromPromise; const i = r(1176); const s = r(1017); const o = r(8605); const a = r(7357); const u = n((async function emptyDir(e) { let t; try { t = await i.readdir(e) } catch { return o.mkdirs(e) } return Promise.all(t.map((t => a.remove(s.join(e, t))))) })); function emptyDirSync(e) { let t; try { t = i.readdirSync(e) } catch { return o.mkdirsSync(e) } t.forEach((t => { t = s.join(e, t); a.removeSync(t) })) } e.exports = { emptyDirSync: emptyDirSync, emptydirSync: emptyDirSync, emptyDir: u, emptydir: u } }, 2164: (e, t, r) => { const n = r(9046).fromCallback; const i = r(1017); const s = r(7758); const o = r(8605); function createFile(e, t) { function makeFile() { s.writeFile(e, "", (e => { if (e) return t(e); t() })) } s.stat(e, ((r, n) => { if (!r && n.isFile()) return t(); const a = i.dirname(e); s.stat(a, ((e, r) => { if (e) { if (e.code === "ENOENT") { return o.mkdirs(a, (e => { if (e) return t(e); makeFile() })) } return t(e) } if (r.isDirectory()) makeFile(); else { s.readdir(a, (e => { if (e) return t(e) })) } })) })) } function createFileSync(e) { let t; try { t = s.statSync(e) } catch { } if (t && t.isFile()) return; const r = i.dirname(e); try { if (!s.statSync(r).isDirectory()) { s.readdirSync(r) } } catch (e) { if (e && e.code === "ENOENT") o.mkdirsSync(r); else throw e } s.writeFileSync(e, "") } e.exports = { createFile: n(createFile), createFileSync: createFileSync } }, 55: (e, t, r) => { const { createFile: n, createFileSync: i } = r(2164); const { createLink: s, createLinkSync: o } = r(3797); const { createSymlink: a, createSymlinkSync: u } = r(2549); e.exports = { createFile: n, createFileSync: i, ensureFile: n, ensureFileSync: i, createLink: s, createLinkSync: o, ensureLink: s, ensureLinkSync: o, createSymlink: a, createSymlinkSync: u, ensureSymlink: a, ensureSymlinkSync: u } }, 3797: (e, t, r) => { const n = r(9046).fromCallback; const i = r(1017); const s = r(7758); const o = r(8605); const a = r(3835).pathExists; const { areIdentical: u } = r(3901); function createLink(e, t, r) { function makeLink(e, t) { s.link(e, t, (e => { if (e) return r(e); r(null) })) } s.lstat(t, ((n, l) => { s.lstat(e, ((n, s) => { if (n) { n.message = n.message.replace("lstat", "ensureLink"); return r(n) } if (l && u(s, l)) return r(null); const f = i.dirname(t); a(f, ((n, i) => { if (n) return r(n); if (i) return makeLink(e, t); o.mkdirs(f, (n => { if (n) return r(n); makeLink(e, t) })) })) })) })) } function createLinkSync(e, t) { let r; try { r = s.lstatSync(t) } catch { } try { const t = s.lstatSync(e); if (r && u(t, r)) return } catch (e) { e.message = e.message.replace("lstat", "ensureLink"); throw e } const n = i.dirname(t); const a = s.existsSync(n); if (a) return s.linkSync(e, t); o.mkdirsSync(n); return s.linkSync(e, t) } e.exports = { createLink: n(createLink), createLinkSync: createLinkSync } }, 3727: (e, t, r) => { const n = r(1017); const i = r(7758); const s = r(3835).pathExists; function symlinkPaths(e, t, r) { if (n.isAbsolute(e)) { return i.lstat(e, (t => { if (t) { t.message = t.message.replace("lstat", "ensureSymlink"); return r(t) } return r(null, { toCwd: e, toDst: e }) })) } else { const o = n.dirname(t); const a = n.join(o, e); return s(a, ((t, s) => { if (t) return r(t); if (s) { return r(null, { toCwd: a, toDst: e }) } else { return i.lstat(e, (t => { if (t) { t.message = t.message.replace("lstat", "ensureSymlink"); return r(t) } return r(null, { toCwd: e, toDst: n.relative(o, e) }) })) } })) } } function symlinkPathsSync(e, t) { let r; if (n.isAbsolute(e)) { r = i.existsSync(e); if (!r) throw new Error("absolute srcpath does not exist"); return { toCwd: e, toDst: e } } else { const s = n.dirname(t); const o = n.join(s, e); r = i.existsSync(o); if (r) { return { toCwd: o, toDst: e } } else { r = i.existsSync(e); if (!r) throw new Error("relative srcpath does not exist"); return { toCwd: e, toDst: n.relative(s, e) } } } } e.exports = { symlinkPaths: symlinkPaths, symlinkPathsSync: symlinkPathsSync } }, 8254: (e, t, r) => { const n = r(7758); function symlinkType(e, t, r) { r = typeof t === "function" ? t : r; t = typeof t === "function" ? false : t; if (t) return r(null, t); n.lstat(e, ((e, n) => { if (e) return r(null, "file"); t = n && n.isDirectory() ? "dir" : "file"; r(null, t) })) } function symlinkTypeSync(e, t) { let r; if (t) return t; try { r = n.lstatSync(e) } catch { return "file" } return r && r.isDirectory() ? "dir" : "file" } e.exports = { symlinkType: symlinkType, symlinkTypeSync: symlinkTypeSync } }, 2549: (e, t, r) => { const n = r(9046).fromCallback; const i = r(1017); const s = r(1176); const o = r(8605); const a = o.mkdirs; const u = o.mkdirsSync; const l = r(3727); const f = l.symlinkPaths; const d = l.symlinkPathsSync; const p = r(8254); const h = p.symlinkType; const m = p.symlinkTypeSync; const g = r(3835).pathExists; const { areIdentical: y } = r(3901); function createSymlink(e, t, r, n) { n = typeof r === "function" ? r : n; r = typeof r === "function" ? false : r; s.lstat(t, ((i, o) => { if (!i && o.isSymbolicLink()) { Promise.all([s.stat(e), s.stat(t)]).then((([i, s]) => { if (y(i, s)) return n(null); _createSymlink(e, t, r, n) })) } else _createSymlink(e, t, r, n) })) } function _createSymlink(e, t, r, n) { f(e, t, ((o, u) => { if (o) return n(o); e = u.toDst; h(u.toCwd, r, ((r, o) => { if (r) return n(r); const u = i.dirname(t); g(u, ((r, i) => { if (r) return n(r); if (i) return s.symlink(e, t, o, n); a(u, (r => { if (r) return n(r); s.symlink(e, t, o, n) })) })) })) })) } function createSymlinkSync(e, t, r) { let n; try { n = s.lstatSync(t) } catch { } if (n && n.isSymbolicLink()) { const r = s.statSync(e); const n = s.statSync(t); if (y(r, n)) return } const o = d(e, t); e = o.toDst; r = m(o.toCwd, r); const a = i.dirname(t); const l = s.existsSync(a); if (l) return s.symlinkSync(e, t, r); u(a); return s.symlinkSync(e, t, r) } e.exports = { createSymlink: n(createSymlink), createSymlinkSync: createSymlinkSync } }, 1176: (e, t, r) => { const n = r(9046).fromCallback; const i = r(7758); const s = ["access", "appendFile", "chmod", "chown", "close", "copyFile", "fchmod", "fchown", "fdatasync", "fstat", "fsync", "ftruncate", "futimes", "lchmod", "lchown", "link", "lstat", "mkdir", "mkdtemp", "open", "opendir", "readdir", "readFile", "readlink", "realpath", "rename", "rm", "rmdir", "stat", "symlink", "truncate", "unlink", "utimes", "writeFile"].filter((e => typeof i[e] === "function")); Object.assign(t, i); s.forEach((e => { t[e] = n(i[e]) })); t.exists = function (e, t) { if (typeof t === "function") { return i.exists(e, t) } return new Promise((t => i.exists(e, t))) }; t.read = function (e, t, r, n, s, o) { if (typeof o === "function") { return i.read(e, t, r, n, s, o) } return new Promise(((o, a) => { i.read(e, t, r, n, s, ((e, t, r) => { if (e) return a(e); o({ bytesRead: t, buffer: r }) })) })) }; t.write = function (e, t, ...r) { if (typeof r[r.length - 1] === "function") { return i.write(e, t, ...r) } return new Promise(((n, s) => { i.write(e, t, ...r, ((e, t, r) => { if (e) return s(e); n({ bytesWritten: t, buffer: r }) })) })) }; t.readv = function (e, t, ...r) { if (typeof r[r.length - 1] === "function") { return i.readv(e, t, ...r) } return new Promise(((n, s) => { i.readv(e, t, ...r, ((e, t, r) => { if (e) return s(e); n({ bytesRead: t, buffers: r }) })) })) }; t.writev = function (e, t, ...r) { if (typeof r[r.length - 1] === "function") { return i.writev(e, t, ...r) } return new Promise(((n, s) => { i.writev(e, t, ...r, ((e, t, r) => { if (e) return s(e); n({ bytesWritten: t, buffers: r }) })) })) }; if (typeof i.realpath.native === "function") { t.realpath.native = n(i.realpath.native) } else { process.emitWarning("fs.realpath.native is not a function. Is fs being monkey-patched?", "Warning", "fs-extra-WARN0003") } }, 5630: (e, t, r) => { e.exports = { ...r(1176), ...r(1335), ...r(6970), ...r(55), ...r(213), ...r(8605), ...r(1497), ...r(1832), ...r(3835), ...r(7357) } }, 213: (e, t, r) => { const n = r(9046).fromPromise; const i = r(8970); i.outputJson = n(r(531)); i.outputJsonSync = r(9421); i.outputJSON = i.outputJson; i.outputJSONSync = i.outputJsonSync; i.writeJSON = i.writeJson; i.writeJSONSync = i.writeJsonSync; i.readJSON = i.readJson; i.readJSONSync = i.readJsonSync; e.exports = i }, 8970: (e, t, r) => { const n = r(6160); e.exports = { readJson: n.readFile, readJsonSync: n.readFileSync, writeJson: n.writeFile, writeJsonSync: n.writeFileSync } }, 9421: (e, t, r) => { const { stringify: n } = r(5902); const { outputFileSync: i } = r(1832); function outputJsonSync(e, t, r) { const s = n(t, r); i(e, s, r) } e.exports = outputJsonSync }, 531: (e, t, r) => { const { stringify: n } = r(5902); const { outputFile: i } = r(1832); async function outputJson(e, t, r = {}) { const s = n(t, r); await i(e, s, r) } e.exports = outputJson }, 8605: (e, t, r) => { const n = r(9046).fromPromise; const { makeDir: i, makeDirSync: s } = r(2751); const o = n(i); e.exports = { mkdirs: o, mkdirsSync: s, mkdirp: o, mkdirpSync: s, ensureDir: o, ensureDirSync: s } }, 2751: (e, t, r) => { const n = r(1176); const { checkPath: i } = r(9907); const getMode = e => { const t = { mode: 511 }; if (typeof e === "number") return e; return { ...t, ...e }.mode }; e.exports.makeDir = async (e, t) => { i(e); return n.mkdir(e, { mode: getMode(t), recursive: true }) }; e.exports.makeDirSync = (e, t) => { i(e); return n.mkdirSync(e, { mode: getMode(t), recursive: true }) } }, 9907: (e, t, r) => { const n = r(1017); e.exports.checkPath = function checkPath(e) { if (process.platform === "win32") { const t = /[<>:"|?*]/.test(e.replace(n.parse(e).root, "")); if (t) { const t = new Error(`Path contains invalid characters: ${e}`); t.code = "EINVAL"; throw t } } } }, 1497: (e, t, r) => { const n = r(9046).fromCallback; e.exports = { move: n(r(2231)), moveSync: r(2047) } }, 2047: (e, t, r) => { const n = r(7758); const i = r(1017); const s = r(1335).copySync; const o = r(7357).removeSync; const a = r(8605).mkdirpSync; const u = r(3901); function moveSync(e, t, r) { r = r || {}; const n = r.overwrite || r.clobber || false; const { srcStat: s, isChangingCase: o = false } = u.checkPathsSync(e, t, "move", r); u.checkParentPathsSync(e, s, t, "move"); if (!isParentRoot(t)) a(i.dirname(t)); return doRename(e, t, n, o) } function isParentRoot(e) { const t = i.dirname(e); const r = i.parse(t); return r.root === t } function doRename(e, t, r, i) { if (i) return rename(e, t, r); if (r) { o(t); return rename(e, t, r) } if (n.existsSync(t)) throw new Error("dest already exists."); return rename(e, t, r) } function rename(e, t, r) { try { n.renameSync(e, t) } catch (n) { if (n.code !== "EXDEV") throw n; return moveAcrossDevice(e, t, r) } } function moveAcrossDevice(e, t, r) { const n = { overwrite: r, errorOnExist: true, preserveTimestamps: true }; s(e, t, n); return o(e) } e.exports = moveSync }, 2231: (e, t, r) => { const n = r(7758); const i = r(1017); const s = r(1335).copy; const o = r(7357).remove; const a = r(8605).mkdirp; const u = r(3835).pathExists; const l = r(3901); function move(e, t, r, n) { if (typeof r === "function") { n = r; r = {} } r = r || {}; const s = r.overwrite || r.clobber || false; l.checkPaths(e, t, "move", r, ((r, o) => { if (r) return n(r); const { srcStat: u, isChangingCase: f = false } = o; l.checkParentPaths(e, u, t, "move", (r => { if (r) return n(r); if (isParentRoot(t)) return doRename(e, t, s, f, n); a(i.dirname(t), (r => { if (r) return n(r); return doRename(e, t, s, f, n) })) })) })) } function isParentRoot(e) { const t = i.dirname(e); const r = i.parse(t); return r.root === t } function doRename(e, t, r, n, i) { if (n) return rename(e, t, r, i); if (r) { return o(t, (n => { if (n) return i(n); return rename(e, t, r, i) })) } u(t, ((n, s) => { if (n) return i(n); if (s) return i(new Error("dest already exists.")); return rename(e, t, r, i) })) } function rename(e, t, r, i) { n.rename(e, t, (n => { if (!n) return i(); if (n.code !== "EXDEV") return i(n); return moveAcrossDevice(e, t, r, i) })) } function moveAcrossDevice(e, t, r, n) { const i = { overwrite: r, errorOnExist: true, preserveTimestamps: true }; s(e, t, i, (t => { if (t) return n(t); return o(e, n) })) } e.exports = move }, 1832: (e, t, r) => { const n = r(9046).fromCallback; const i = r(7758); const s = r(1017); const o = r(8605); const a = r(3835).pathExists; function outputFile(e, t, r, n) { if (typeof r === "function") { n = r; r = "utf8" } const u = s.dirname(e); a(u, ((s, a) => { if (s) return n(s); if (a) return i.writeFile(e, t, r, n); o.mkdirs(u, (s => { if (s) return n(s); i.writeFile(e, t, r, n) })) })) } function outputFileSync(e, ...t) { const r = s.dirname(e); if (i.existsSync(r)) { return i.writeFileSync(e, ...t) } o.mkdirsSync(r); i.writeFileSync(e, ...t) } e.exports = { outputFile: n(outputFile), outputFileSync: outputFileSync } }, 3835: (e, t, r) => { const n = r(9046).fromPromise; const i = r(1176); function pathExists(e) { return i.access(e).then((() => true)).catch((() => false)) } e.exports = { pathExists: n(pathExists), pathExistsSync: i.existsSync } }, 7357: (e, t, r) => { const n = r(7758); const i = r(9046).fromCallback; function remove(e, t) { n.rm(e, { recursive: true, force: true }, t) } function removeSync(e) { n.rmSync(e, { recursive: true, force: true }) } e.exports = { remove: i(remove), removeSync: removeSync } }, 3901: (e, t, r) => { const n = r(1176); const i = r(1017); const s = r(3837); function getStats(e, t, r) { const i = r.dereference ? e => n.stat(e, { bigint: true }) : e => n.lstat(e, { bigint: true }); return Promise.all([i(e), i(t).catch((e => { if (e.code === "ENOENT") return null; throw e }))]).then((([e, t]) => ({ srcStat: e, destStat: t }))) } function getStatsSync(e, t, r) { let i; const s = r.dereference ? e => n.statSync(e, { bigint: true }) : e => n.lstatSync(e, { bigint: true }); const o = s(e); try { i = s(t) } catch (e) { if (e.code === "ENOENT") return { srcStat: o, destStat: null }; throw e } return { srcStat: o, destStat: i } } function checkPaths(e, t, r, n, o) { s.callbackify(getStats)(e, t, n, ((n, s) => { if (n) return o(n); const { srcStat: a, destStat: u } = s; if (u) { if (areIdentical(a, u)) { const n = i.basename(e); const s = i.basename(t); if (r === "move" && n !== s && n.toLowerCase() === s.toLowerCase()) { return o(null, { srcStat: a, destStat: u, isChangingCase: true }) } return o(new Error("Source and destination must not be the same.")) } if (a.isDirectory() && !u.isDirectory()) { return o(new Error(`Cannot overwrite non-directory '${t}' with directory '${e}'.`)) } if (!a.isDirectory() && u.isDirectory()) { return o(new Error(`Cannot overwrite directory '${t}' with non-directory '${e}'.`)) } } if (a.isDirectory() && isSrcSubdir(e, t)) { return o(new Error(errMsg(e, t, r))) } return o(null, { srcStat: a, destStat: u }) })) } function checkPathsSync(e, t, r, n) { const { srcStat: s, destStat: o } = getStatsSync(e, t, n); if (o) { if (areIdentical(s, o)) { const n = i.basename(e); const a = i.basename(t); if (r === "move" && n !== a && n.toLowerCase() === a.toLowerCase()) { return { srcStat: s, destStat: o, isChangingCase: true } } throw new Error("Source and destination must not be the same.") } if (s.isDirectory() && !o.isDirectory()) { throw new Error(`Cannot overwrite non-directory '${t}' with directory '${e}'.`) } if (!s.isDirectory() && o.isDirectory()) { throw new Error(`Cannot overwrite directory '${t}' with non-directory '${e}'.`) } } if (s.isDirectory() && isSrcSubdir(e, t)) { throw new Error(errMsg(e, t, r)) } return { srcStat: s, destStat: o } } function checkParentPaths(e, t, r, s, o) { const a = i.resolve(i.dirname(e)); const u = i.resolve(i.dirname(r)); if (u === a || u === i.parse(u).root) return o(); n.stat(u, { bigint: true }, ((n, i) => { if (n) { if (n.code === "ENOENT") return o(); return o(n) } if (areIdentical(t, i)) { return o(new Error(errMsg(e, r, s))) } return checkParentPaths(e, t, u, s, o) })) } function checkParentPathsSync(e, t, r, s) { const o = i.resolve(i.dirname(e)); const a = i.resolve(i.dirname(r)); if (a === o || a === i.parse(a).root) return; let u; try { u = n.statSync(a, { bigint: true }) } catch (e) { if (e.code === "ENOENT") return; throw e } if (areIdentical(t, u)) { throw new Error(errMsg(e, r, s)) } return checkParentPathsSync(e, t, a, s) } function areIdentical(e, t) { return t.ino && t.dev && t.ino === e.ino && t.dev === e.dev } function isSrcSubdir(e, t) { const r = i.resolve(e).split(i.sep).filter((e => e)); const n = i.resolve(t).split(i.sep).filter((e => e)); return r.reduce(((e, t, r) => e && n[r] === t), true) } function errMsg(e, t, r) { return `Cannot ${r} '${e}' to a subdirectory of itself, '${t}'.` } e.exports = { checkPaths: checkPaths, checkPathsSync: checkPathsSync, checkParentPaths: checkParentPaths, checkParentPathsSync: checkParentPathsSync, isSrcSubdir: isSrcSubdir, areIdentical: areIdentical } }, 2548: (e, t, r) => { const n = r(7758); function utimesMillis(e, t, r, i) { n.open(e, "r+", ((e, s) => { if (e) return i(e); n.futimes(s, t, r, (e => { n.close(s, (t => { if (i) i(e || t) })) })) })) } function utimesMillisSync(e, t, r) { const i = n.openSync(e, "r+"); n.futimesSync(i, t, r); return n.closeSync(i) } e.exports = { utimesMillis: utimesMillis, utimesMillisSync: utimesMillisSync } }, 1585: (e, t, r) => { const { PassThrough: n } = r(2781); e.exports = e => { e = { ...e }; const { array: t } = e; let { encoding: r } = e; const i = r === "buffer"; let s = false; if (t) { s = !(r || i) } else { r = r || "utf8" } if (i) { r = null } const o = new n({ objectMode: s }); if (r) { o.setEncoding(r) } let a = 0; const u = []; o.on("data", (e => { u.push(e); if (s) { a = u.length } else { a += e.length } })); o.getBufferedValue = () => { if (t) { return u } return i ? Buffer.concat(u, a) : u.join("") }; o.getBufferedLength = () => a; return o } }, 1766: (e, t, r) => { const { constants: n } = r(4300); const i = r(2781); const { promisify: s } = r(3837); const o = r(1585); const a = s(i.pipeline); class MaxBufferError extends Error { constructor() { super("maxBuffer exceeded"); this.name = "MaxBufferError" } } async function getStream(e, t) { if (!e) { throw new Error("Expected a stream") } t = { maxBuffer: Infinity, ...t }; const { maxBuffer: r } = t; const i = o(t); await new Promise(((t, s) => { const rejectPromise = e => { if (e && i.getBufferedLength() <= n.MAX_LENGTH) { e.bufferedData = i.getBufferedValue() } s(e) }; (async () => { try { await a(e, i); t() } catch (e) { rejectPromise(e) } })(); i.on("data", (() => { if (i.getBufferedLength() > r) { rejectPromise(new MaxBufferError) } })) })); return i.getBufferedValue() } e.exports = getStream; e.exports.buffer = (e, t) => getStream(e, { ...t, encoding: "buffer" }); e.exports.array = (e, t) => getStream(e, { ...t, array: true }); e.exports.MaxBufferError = MaxBufferError }, 4655: (e, t, r) => { var n = r(4466); var i = r(1017).posix.dirname; var s = r(2037).platform() === "win32"; var o = "/"; var a = /\\/g; var u = /[\{\[].*[\}\]]$/; var l = /(^|[^\\])([\{\[]|\([^\)]+$)/; var f = /\\([\!\*\?\|\[\]\(\)\{\}])/g; e.exports = function globParent(e, t) { var r = Object.assign({ flipBackslashes: true }, t); if (r.flipBackslashes && s && e.indexOf(o) < 0) { e = e.replace(a, o) } if (u.test(e)) { e += o } e += "a"; do { e = i(e) } while (n(e) || l.test(e)); return e.replace(f, "$1") } }, 7356: e => { e.exports = clone; var t = Object.getPrototypeOf || function (e) { return e.__proto__ }; function clone(e) { if (e === null || typeof e !== "object") return e; if (e instanceof Object) var r = { __proto__: t(e) }; else var r = Object.create(null); Object.getOwnPropertyNames(e).forEach((function (t) { Object.defineProperty(r, t, Object.getOwnPropertyDescriptor(e, t)) })); return r } }, 7758: (e, t, r) => { var n = r(7147); var i = r(263); var s = r(3086); var o = r(7356); var a = r(3837); var u; var l; if (typeof Symbol === "function" && typeof Symbol.for === "function") { u = Symbol.for("graceful-fs.queue"); l = Symbol.for("graceful-fs.previous") } else { u = "___graceful-fs.queue"; l = "___graceful-fs.previous" } function noop() { } function publishQueue(e, t) { Object.defineProperty(e, u, { get: function () { return t } }) } var f = noop; if (a.debuglog) f = a.debuglog("gfs4"); else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) f = function () { var e = a.format.apply(a, arguments); e = "GFS4: " + e.split(/\n/).join("\nGFS4: "); console.error(e) }; if (!n[u]) { var d = global[u] || []; publishQueue(n, d); n.close = function (e) { function close(t, r) { return e.call(n, t, (function (e) { if (!e) { resetQueue() } if (typeof r === "function") r.apply(this, arguments) })) } Object.defineProperty(close, l, { value: e }); return close }(n.close); n.closeSync = function (e) { function closeSync(t) { e.apply(n, arguments); resetQueue() } Object.defineProperty(closeSync, l, { value: e }); return closeSync }(n.closeSync); if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) { process.on("exit", (function () { f(n[u]); r(9491).equal(n[u].length, 0) })) } } if (!global[u]) { publishQueue(global, n[u]) } e.exports = patch(o(n)); if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !n.__patched) { e.exports = patch(n); n.__patched = true } function patch(e) { i(e); e.gracefulify = patch; e.createReadStream = createReadStream; e.createWriteStream = createWriteStream; var t = e.readFile; e.readFile = readFile; function readFile(e, r, n) { if (typeof r === "function") n = r, r = null; return go$readFile(e, r, n); function go$readFile(e, r, n, i) { return t(e, r, (function (t) { if (t && (t.code === "EMFILE" || t.code === "ENFILE")) enqueue([go$readFile, [e, r, n], t, i || Date.now(), Date.now()]); else { if (typeof n === "function") n.apply(this, arguments) } })) } } var r = e.writeFile; e.writeFile = writeFile; function writeFile(e, t, n, i) { if (typeof n === "function") i = n, n = null; return go$writeFile(e, t, n, i); function go$writeFile(e, t, n, i, s) { return r(e, t, n, (function (r) { if (r && (r.code === "EMFILE" || r.code === "ENFILE")) enqueue([go$writeFile, [e, t, n, i], r, s || Date.now(), Date.now()]); else { if (typeof i === "function") i.apply(this, arguments) } })) } } var n = e.appendFile; if (n) e.appendFile = appendFile; function appendFile(e, t, r, i) { if (typeof r === "function") i = r, r = null; return go$appendFile(e, t, r, i); function go$appendFile(e, t, r, i, s) { return n(e, t, r, (function (n) { if (n && (n.code === "EMFILE" || n.code === "ENFILE")) enqueue([go$appendFile, [e, t, r, i], n, s || Date.now(), Date.now()]); else { if (typeof i === "function") i.apply(this, arguments) } })) } } var o = e.copyFile; if (o) e.copyFile = copyFile; function copyFile(e, t, r, n) { if (typeof r === "function") { n = r; r = 0 } return go$copyFile(e, t, r, n); function go$copyFile(e, t, r, n, i) { return o(e, t, r, (function (s) { if (s && (s.code === "EMFILE" || s.code === "ENFILE")) enqueue([go$copyFile, [e, t, r, n], s, i || Date.now(), Date.now()]); else { if (typeof n === "function") n.apply(this, arguments) } })) } } var a = e.readdir; e.readdir = readdir; var u = /^v[0-5]\./; function readdir(e, t, r) { if (typeof t === "function") r = t, t = null; var n = u.test(process.version) ? function go$readdir(e, t, r, n) { return a(e, fs$readdirCallback(e, t, r, n)) } : function go$readdir(e, t, r, n) { return a(e, t, fs$readdirCallback(e, t, r, n)) }; return n(e, t, r); function fs$readdirCallback(e, t, r, i) { return function (s, o) { if (s && (s.code === "EMFILE" || s.code === "ENFILE")) enqueue([n, [e, t, r], s, i || Date.now(), Date.now()]); else { if (o && o.sort) o.sort(); if (typeof r === "function") r.call(this, s, o) } } } } if (process.version.substr(0, 4) === "v0.8") { var l = s(e); ReadStream = l.ReadStream; WriteStream = l.WriteStream } var f = e.ReadStream; if (f) { ReadStream.prototype = Object.create(f.prototype); ReadStream.prototype.open = ReadStream$open } var d = e.WriteStream; if (d) { WriteStream.prototype = Object.create(d.prototype); WriteStream.prototype.open = WriteStream$open } Object.defineProperty(e, "ReadStream", { get: function () { return ReadStream }, set: function (e) { ReadStream = e }, enumerable: true, configurable: true }); Object.defineProperty(e, "WriteStream", { get: function () { return WriteStream }, set: function (e) { WriteStream = e }, enumerable: true, configurable: true }); var p = ReadStream; Object.defineProperty(e, "FileReadStream", { get: function () { return p }, set: function (e) { p = e }, enumerable: true, configurable: true }); var h = WriteStream; Object.defineProperty(e, "FileWriteStream", { get: function () { return h }, set: function (e) { h = e }, enumerable: true, configurable: true }); function ReadStream(e, t) { if (this instanceof ReadStream) return f.apply(this, arguments), this; else return ReadStream.apply(Object.create(ReadStream.prototype), arguments) } function ReadStream$open() { var e = this; open(e.path, e.flags, e.mode, (function (t, r) { if (t) { if (e.autoClose) e.destroy(); e.emit("error", t) } else { e.fd = r; e.emit("open", r); e.read() } })) } function WriteStream(e, t) { if (this instanceof WriteStream) return d.apply(this, arguments), this; else return WriteStream.apply(Object.create(WriteStream.prototype), arguments) } function WriteStream$open() { var e = this; open(e.path, e.flags, e.mode, (function (t, r) { if (t) { e.destroy(); e.emit("error", t) } else { e.fd = r; e.emit("open", r) } })) } function createReadStream(t, r) { return new e.ReadStream(t, r) } function createWriteStream(t, r) { return new e.WriteStream(t, r) } var m = e.open; e.open = open; function open(e, t, r, n) { if (typeof r === "function") n = r, r = null; return go$open(e, t, r, n); function go$open(e, t, r, n, i) { return m(e, t, r, (function (s, o) { if (s && (s.code === "EMFILE" || s.code === "ENFILE")) enqueue([go$open, [e, t, r, n], s, i || Date.now(), Date.now()]); else { if (typeof n === "function") n.apply(this, arguments) } })) } } return e } function enqueue(e) { f("ENQUEUE", e[0].name, e[1]); n[u].push(e); retry() } var p; function resetQueue() { var e = Date.now(); for (var t = 0; t < n[u].length; ++t) { if (n[u][t].length > 2) { n[u][t][3] = e; n[u][t][4] = e } } retry() } function retry() { clearTimeout(p); p = undefined; if (n[u].length === 0) return; var e = n[u].shift(); var t = e[0]; var r = e[1]; var i = e[2]; var s = e[3]; var o = e[4]; if (s === undefined) { f("RETRY", t.name, r); t.apply(null, r) } else if (Date.now() - s >= 6e4) { f("TIMEOUT", t.name, r); var a = r.pop(); if (typeof a === "function") a.call(null, i) } else { var l = Date.now() - o; var d = Math.max(o - s, 1); var h = Math.min(d * 1.2, 100); if (l >= h) { f("RETRY", t.name, r); t.apply(null, r.concat([s])) } else { n[u].push(e) } } if (p === undefined) { p = setTimeout(retry, 0) } } }, 3086: (e, t, r) => { var n = r(2781).Stream; e.exports = legacy; function legacy(e) { return { ReadStream: ReadStream, WriteStream: WriteStream }; function ReadStream(t, r) { if (!(this instanceof ReadStream)) return new ReadStream(t, r); n.call(this); var i = this; this.path = t; this.fd = null; this.readable = true; this.paused = false; this.flags = "r"; this.mode = 438; this.bufferSize = 64 * 1024; r = r || {}; var s = Object.keys(r); for (var o = 0, a = s.length; o < a; o++) { var u = s[o]; this[u] = r[u] } if (this.encoding) this.setEncoding(this.encoding); if (this.start !== undefined) { if ("number" !== typeof this.start) { throw TypeError("start must be a Number") } if (this.end === undefined) { this.end = Infinity } else if ("number" !== typeof this.end) { throw TypeError("end must be a Number") } if (this.start > this.end) { throw new Error("start must be <= end") } this.pos = this.start } if (this.fd !== null) { process.nextTick((function () { i._read() })); return } e.open(this.path, this.flags, this.mode, (function (e, t) { if (e) { i.emit("error", e); i.readable = false; return } i.fd = t; i.emit("open", t); i._read() })) } function WriteStream(t, r) { if (!(this instanceof WriteStream)) return new WriteStream(t, r); n.call(this); this.path = t; this.fd = null; this.writable = true; this.flags = "w"; this.encoding = "binary"; this.mode = 438; this.bytesWritten = 0; r = r || {}; var i = Object.keys(r); for (var s = 0, o = i.length; s < o; s++) { var a = i[s]; this[a] = r[a] } if (this.start !== undefined) { if ("number" !== typeof this.start) { throw TypeError("start must be a Number") } if (this.start < 0) { throw new Error("start must be >= zero") } this.pos = this.start } this.busy = false; this._queue = []; if (this.fd === null) { this._open = e.open; this._queue.push([this._open, this.path, this.flags, this.mode, undefined]); this.flush() } } } }, 263: (e, t, r) => { var n = r(2057); var i = process.cwd; var s = null; var o = process.env.GRACEFUL_FS_PLATFORM || process.platform; process.cwd = function () { if (!s) s = i.call(process); return s }; try { process.cwd() } catch (e) { } if (typeof process.chdir === "function") { var a = process.chdir; process.chdir = function (e) { s = null; a.call(process, e) }; if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, a) } e.exports = patch; function patch(e) { if (n.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) { patchLchmod(e) } if (!e.lutimes) { patchLutimes(e) } e.chown = chownFix(e.chown); e.fchown = chownFix(e.fchown); e.lchown = chownFix(e.lchown); e.chmod = chmodFix(e.chmod); e.fchmod = chmodFix(e.fchmod); e.lchmod = chmodFix(e.lchmod); e.chownSync = chownFixSync(e.chownSync); e.fchownSync = chownFixSync(e.fchownSync); e.lchownSync = chownFixSync(e.lchownSync); e.chmodSync = chmodFixSync(e.chmodSync); e.fchmodSync = chmodFixSync(e.fchmodSync); e.lchmodSync = chmodFixSync(e.lchmodSync); e.stat = statFix(e.stat); e.fstat = statFix(e.fstat); e.lstat = statFix(e.lstat); e.statSync = statFixSync(e.statSync); e.fstatSync = statFixSync(e.fstatSync); e.lstatSync = statFixSync(e.lstatSync); if (e.chmod && !e.lchmod) { e.lchmod = function (e, t, r) { if (r) process.nextTick(r) }; e.lchmodSync = function () { } } if (e.chown && !e.lchown) { e.lchown = function (e, t, r, n) { if (n) process.nextTick(n) }; e.lchownSync = function () { } } if (o === "win32") { e.rename = typeof e.rename !== "function" ? e.rename : function (t) { function rename(r, n, i) { var s = Date.now(); var o = 0; t(r, n, (function CB(a) { if (a && (a.code === "EACCES" || a.code === "EPERM" || a.code === "EBUSY") && Date.now() - s < 6e4) { setTimeout((function () { e.stat(n, (function (e, s) { if (e && e.code === "ENOENT") t(r, n, CB); else i(a) })) }), o); if (o < 100) o += 10; return } if (i) i(a) })) } if (Object.setPrototypeOf) Object.setPrototypeOf(rename, t); return rename }(e.rename) } e.read = typeof e.read !== "function" ? e.read : function (t) { function read(r, n, i, s, o, a) { var u; if (a && typeof a === "function") { var l = 0; u = function (f, d, p) { if (f && f.code === "EAGAIN" && l < 10) { l++; return t.call(e, r, n, i, s, o, u) } a.apply(this, arguments) } } return t.call(e, r, n, i, s, o, u) } if (Object.setPrototypeOf) Object.setPrototypeOf(read, t); return read }(e.read); e.readSync = typeof e.readSync !== "function" ? e.readSync : function (t) { return function (r, n, i, s, o) { var a = 0; while (true) { try { return t.call(e, r, n, i, s, o) } catch (e) { if (e.code === "EAGAIN" && a < 10) { a++; continue } throw e } } } }(e.readSync); function patchLchmod(e) { e.lchmod = function (t, r, i) { e.open(t, n.O_WRONLY | n.O_SYMLINK, r, (function (t, n) { if (t) { if (i) i(t); return } e.fchmod(n, r, (function (t) { e.close(n, (function (e) { if (i) i(t || e) })) })) })) }; e.lchmodSync = function (t, r) { var i = e.openSync(t, n.O_WRONLY | n.O_SYMLINK, r); var s = true; var o; try { o = e.fchmodSync(i, r); s = false } finally { if (s) { try { e.closeSync(i) } catch (e) { } } else { e.closeSync(i) } } return o } } function patchLutimes(e) { if (n.hasOwnProperty("O_SYMLINK") && e.futimes) { e.lutimes = function (t, r, i, s) { e.open(t, n.O_SYMLINK, (function (t, n) { if (t) { if (s) s(t); return } e.futimes(n, r, i, (function (t) { e.close(n, (function (e) { if (s) s(t || e) })) })) })) }; e.lutimesSync = function (t, r, i) { var s = e.openSync(t, n.O_SYMLINK); var o; var a = true; try { o = e.futimesSync(s, r, i); a = false } finally { if (a) { try { e.closeSync(s) } catch (e) { } } else { e.closeSync(s) } } return o } } else if (e.futimes) { e.lutimes = function (e, t, r, n) { if (n) process.nextTick(n) }; e.lutimesSync = function () { } } } function chmodFix(t) { if (!t) return t; return function (r, n, i) { return t.call(e, r, n, (function (e) { if (chownErOk(e)) e = null; if (i) i.apply(this, arguments) })) } } function chmodFixSync(t) { if (!t) return t; return function (r, n) { try { return t.call(e, r, n) } catch (e) { if (!chownErOk(e)) throw e } } } function chownFix(t) { if (!t) return t; return function (r, n, i, s) { return t.call(e, r, n, i, (function (e) { if (chownErOk(e)) e = null; if (s) s.apply(this, arguments) })) } } function chownFixSync(t) { if (!t) return t; return function (r, n, i) { try { return t.call(e, r, n, i) } catch (e) { if (!chownErOk(e)) throw e } } } function statFix(t) { if (!t) return t; return function (r, n, i) { if (typeof n === "function") { i = n; n = null } function callback(e, t) { if (t) { if (t.uid < 0) t.uid += 4294967296; if (t.gid < 0) t.gid += 4294967296 } if (i) i.apply(this, arguments) } return n ? t.call(e, r, n, callback) : t.call(e, r, callback) } } function statFixSync(t) { if (!t) return t; return function (r, n) { var i = n ? t.call(e, r, n) : t.call(e, r); if (i) { if (i.uid < 0) i.uid += 4294967296; if (i.gid < 0) i.gid += 4294967296 } return i } } function chownErOk(e) { if (!e) return true; if (e.code === "ENOSYS") return true; var t = !process.getuid || process.getuid() !== 0; if (t) { if (e.code === "EINVAL" || e.code === "EPERM") return true } return false } } }, 5382: (e, t, r) => { const n = r(7147); const i = r(1762); const s = r(5256); const o = r(905); const a = r(3919); const u = r(3190); const l = r(9652); const f = r(9368); const d = r(7405); function matter(e, t) { if (e === "") { return { data: {}, content: e, excerpt: "", orig: e } } let r = l(e); const n = matter.cache[r.content]; if (!t) { if (n) { r = Object.assign({}, n); r.orig = n.orig; return r } matter.cache[r.content] = r } return parseMatter(r, t) } function parseMatter(e, t) { const r = s(t); const n = r.delimiters[0]; const o = "\n" + r.delimiters[1]; let u = e.content; if (r.language) { e.language = r.language } const l = n.length; if (!d.startsWith(u, n, l)) { a(e, r); return e } if (u.charAt(l) === n.slice(-1)) { return e } u = u.slice(l); const p = u.length; const h = matter.language(u, r); if (h.name) { e.language = h.name; u = u.slice(h.raw.length) } let m = u.indexOf(o); if (m === -1) { m = p } e.matter = u.slice(0, m); const g = e.matter.replace(/^\s*#[^\n]+/gm, "").trim(); if (g === "") { e.isEmpty = true; e.empty = e.content; e.data = {} } else { e.data = f(e.language, e.matter, r) } if (m === p) { e.content = "" } else { e.content = u.slice(m + o.length); if (e.content[0] === "\r") { e.content = e.content.slice(1) } if (e.content[0] === "\n") { e.content = e.content.slice(1) } } a(e, r); if (r.sections === true || typeof r.section === "function") { i(e, r.section) } return e } matter.engines = u; matter.stringify = function (e, t, r) { if (typeof e === "string") e = matter(e, r); return o(e, t, r) }; matter.read = function (e, t) { const r = n.readFileSync(e, "utf8"); const i = matter(r, t); i.path = e; return i }; matter.test = function (e, t) { return d.startsWith(e, s(t).delimiters[0]) }; matter.language = function (e, t) { const r = s(t); const n = r.delimiters[0]; if (matter.test(e)) { e = e.slice(n.length) } const i = e.slice(0, e.search(/\r?\n/)); return { raw: i, name: i ? i.trim() : "" } }; matter.cache = {}; matter.clearCache = function () { matter.cache = {} }; e.exports = matter }, 5256: (e, t, r) => { const n = r(3190); const i = r(7405); e.exports = function (e) { const t = Object.assign({}, e); t.delimiters = i.arrayify(t.delims || t.delimiters || "---"); if (t.delimiters.length === 1) { t.delimiters.push(t.delimiters[0]) } t.language = (t.language || t.lang || "yaml").toLowerCase(); t.engines = Object.assign({}, n, t.parsers, t.engines); return t } }, 7669: e => { e.exports = function (e, t) { let r = t.engines[e] || t.engines[aliase(e)]; if (typeof r === "undefined") { throw new Error('gray-matter engine "' + e + '" is not registered') } if (typeof r === "function") { r = { parse: r } } return r }; function aliase(e) { switch (e.toLowerCase()) { case "js": case "javascript": return "javascript"; case "coffee": case "coffeescript": case "cson": return "coffee"; case "yaml": case "yml": return "yaml"; default: { return e } } } }, 3190: (module, exports, __nccwpck_require__) => { const yaml = __nccwpck_require__(1917); const engines = exports = module.exports; engines.yaml = { parse: yaml.safeLoad.bind(yaml), stringify: yaml.safeDump.bind(yaml) }; engines.json = { parse: JSON.parse.bind(JSON), stringify: function (e, t) { const r = Object.assign({ replacer: null, space: 2 }, t); return JSON.stringify(e, r.replacer, r.space) } }; engines.javascript = { parse: function parse(str, options, wrap) { try { if (wrap !== false) { str = "(function() {\nreturn " + str.trim() + ";\n}());" } return eval(str) || {} } catch (e) { if (wrap !== false && /(unexpected|identifier)/i.test(e.message)) { return parse(str, options, false) } throw new SyntaxError(e) } }, stringify: function () { throw new Error("stringifying JavaScript is not supported") } } }, 3919: (e, t, r) => { const n = r(5256); e.exports = function (e, t) { const r = n(t); if (e.data == null) { e.data = {} } if (typeof r.excerpt === "function") { return r.excerpt(e, r) } const i = e.data.excerpt_separator || r.excerpt_separator; if (i == null && (r.excerpt === false || r.excerpt == null)) { return e } const s = typeof r.excerpt === "string" ? r.excerpt : i || r.delimiters[0]; const o = e.content.indexOf(s); if (o !== -1) { e.excerpt = e.content.slice(0, o) } return e } }, 9368: (e, t, r) => { const n = r(7669); const i = r(5256); e.exports = function (e, t, r) { const s = i(r); const o = n(e, s); if (typeof o.parse !== "function") { throw new TypeError('expected "' + e + '.parse" to be a function') } return o.parse(t, s) } }, 905: (e, t, r) => { const n = r(6961); const i = r(7669); const s = r(5256); e.exports = function (e, t, r) { if (t == null && r == null) { switch (n(e)) { case "object": t = e.data; r = {}; break; case "string": return e; default: { throw new TypeError("expected file to be a string or object") } } } const o = e.content; const a = s(r); if (t == null) { if (!a.data) return e; t = a.data } const u = e.language || a.language; const l = i(u, a); if (typeof l.stringify !== "function") { throw new TypeError('expected "' + u + '.stringify" to be a function') } t = Object.assign({}, e.data, t); const f = a.delimiters[0]; const d = a.delimiters[1]; const p = l.stringify(t, r).trim(); let h = ""; if (p !== "{}") { h = newline(f) + newline(p) + newline(d) } if (typeof e.excerpt === "string" && e.excerpt !== "") { if (o.indexOf(e.excerpt.trim()) === -1) { h += newline(e.excerpt) + newline(d) } } return h + newline(o) }; function newline(e) { return e.slice(-1) !== "\n" ? e + "\n" : e } }, 9652: (e, t, r) => { const n = r(6961); const i = r(905); const s = r(7405); e.exports = function (e) { if (n(e) !== "object") { e = { content: e } } if (n(e.data) !== "object") { e.data = {} } if (e.contents && e.content == null) { e.content = e.contents } s.define(e, "orig", s.toBuffer(e.content)); s.define(e, "language", e.language || ""); s.define(e, "matter", e.matter || ""); s.define(e, "stringify", (function (t, r) { if (r && r.language) { e.language = r.language } return i(e, t, r) })); e.content = s.toString(e.content); e.isEmpty = false; e.excerpt = ""; return e } }, 7405: (e, t, r) => { const n = r(6550); const i = r(6961); t.define = function (e, t, r) { Reflect.defineProperty(e, t, { enumerable: false, configurable: true, writable: true, value: r }) }; t.isBuffer = function (e) { return i(e) === "buffer" }; t.isObject = function (e) { return i(e) === "object" }; t.toBuffer = function (e) { return typeof e === "string" ? Buffer.from(e) : e }; t.toString = function (e) { if (t.isBuffer(e)) return n(String(e)); if (typeof e !== "string") { throw new TypeError("expected input to be a string or buffer") } return n(e) }; t.arrayify = function (e) { return e ? Array.isArray(e) ? e : [e] : [] }; t.startsWith = function (e, t, r) { if (typeof r !== "number") r = t.length; return e.slice(0, r) === t } }, 1621: e => { e.exports = (e, t = process.argv) => { const r = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--"; const n = t.indexOf(r + e); const i = t.indexOf("--"); return n !== -1 && (i === -1 || n < i) } }, 5218: (e, t, r) => { var n = r(8380); var i = r(7147); var s = r(1017); e.exports = hasbin; hasbin.async = hasbin; hasbin.sync = hasbinSync; hasbin.all = hasbinAll; hasbin.all.sync = hasbinAllSync; hasbin.some = hasbinSome; hasbin.some.sync = hasbinSomeSync; hasbin.first = hasbinFirst; hasbin.first.sync = hasbinFirstSync; hasbin.every = hasbin.all; hasbin.any = hasbin.some; function hasbin(e, t) { n.some(getPaths(e), fileExists, t) } function hasbinSync(e) { return getPaths(e).some(fileExistsSync) } function hasbinAll(e, t) { n.every(e, hasbin.async, t) } function hasbinAllSync(e) { return e.every(hasbin.sync) } function hasbinSome(e, t) { n.some(e, hasbin.async, t) } function hasbinSomeSync(e) { return e.some(hasbin.sync) } function hasbinFirst(e, t) { n.detect(e, hasbin.async, (function (e) { t(e || false) })) } function hasbinFirstSync(e) { var t = e.filter(hasbin.sync); return t.length ? t[0] : false } function getPaths(e) { var t = process.env.PATH || ""; var r = process.env.PATHEXT || ""; return t.replace(/["]+/g, "").split(s.delimiter).map((function (t) { return r.split(s.delimiter).map((function (r) { return s.join(t, e + r) })) })).reduce((function (e, t) { return e.concat(t) })) } function fileExists(e, t) { i.stat(e, (function (e, r) { if (e) { return t(false) } t(r.isFile()) })) } function fileExistsSync(e) { try { return i.statSync(e).isFile() } catch (e) { return false } } }, 1002: e => { const t = new Set([200, 203, 204, 206, 300, 301, 308, 404, 405, 410, 414, 501]); const r = new Set([200, 203, 204, 300, 301, 302, 303, 307, 308, 404, 405, 410, 414, 501]); const n = new Set([500, 502, 503, 504]); const i = { date: true, connection: true, "keep-alive": true, "proxy-authenticate": true, "proxy-authorization": true, te: true, trailer: true, "transfer-encoding": true, upgrade: true }; const s = { "content-length": true, "content-encoding": true, "transfer-encoding": true, "content-range": true }; function toNumberOrZero(e) { const t = parseInt(e, 10); return isFinite(t) ? t : 0 } function isErrorResponse(e) { if (!e) { return true } return n.has(e.status) } function parseCacheControl(e) { const t = {}; if (!e) return t; const r = e.trim().split(/,/); for (const e of r) { const [r, n] = e.split(/=/, 2); t[r.trim()] = n === undefined ? true : n.trim().replace(/^"|"$/g, "") } return t } function formatCacheControl(e) { let t = []; for (const r in e) { const n = e[r]; t.push(n === true ? r : r + "=" + n) } if (!t.length) { return undefined } return t.join(", ") } e.exports = class CachePolicy { constructor(e, t, { shared: r, cacheHeuristic: n, immutableMinTimeToLive: i, ignoreCargoCult: s, _fromObject: o } = {}) { if (o) { this._fromObject(o); return } if (!t || !t.headers) { throw Error("Response headers missing") } this._assertRequestHasHeaders(e); this._responseTime = this.now(); this._isShared = r !== false; this._cacheHeuristic = undefined !== n ? n : .1; this._immutableMinTtl = undefined !== i ? i : 24 * 3600 * 1e3; this._status = "status" in t ? t.status : 200; this._resHeaders = t.headers; this._rescc = parseCacheControl(t.headers["cache-control"]); this._method = "method" in e ? e.method : "GET"; this._url = e.url; this._host = e.headers.host; this._noAuthorization = !e.headers.authorization; this._reqHeaders = t.headers.vary ? e.headers : null; this._reqcc = parseCacheControl(e.headers["cache-control"]); if (s && "pre-check" in this._rescc && "post-check" in this._rescc) { delete this._rescc["pre-check"]; delete this._rescc["post-check"]; delete this._rescc["no-cache"]; delete this._rescc["no-store"]; delete this._rescc["must-revalidate"]; this._resHeaders = Object.assign({}, this._resHeaders, { "cache-control": formatCacheControl(this._rescc) }); delete this._resHeaders.expires; delete this._resHeaders.pragma } if (t.headers["cache-control"] == null && /no-cache/.test(t.headers.pragma)) { this._rescc["no-cache"] = true } } now() { return Date.now() } storable() { return !!(!this._reqcc["no-store"] && ("GET" === this._method || "HEAD" === this._method || "POST" === this._method && this._hasExplicitExpiration()) && r.has(this._status) && !this._rescc["no-store"] && (!this._isShared || !this._rescc.private) && (!this._isShared || this._noAuthorization || this._allowsStoringAuthenticated()) && (this._resHeaders.expires || this._rescc["max-age"] || this._isShared && this._rescc["s-maxage"] || this._rescc.public || t.has(this._status))) } _hasExplicitExpiration() { return this._isShared && this._rescc["s-maxage"] || this._rescc["max-age"] || this._resHeaders.expires } _assertRequestHasHeaders(e) { if (!e || !e.headers) { throw Error("Request headers missing") } } satisfiesWithoutRevalidation(e) { this._assertRequestHasHeaders(e); const t = parseCacheControl(e.headers["cache-control"]); if (t["no-cache"] || /no-cache/.test(e.headers.pragma)) { return false } if (t["max-age"] && this.age() > t["max-age"]) { return false } if (t["min-fresh"] && this.timeToLive() < 1e3 * t["min-fresh"]) { return false } if (this.stale()) { const e = t["max-stale"] && !this._rescc["must-revalidate"] && (true === t["max-stale"] || t["max-stale"] > this.age() - this.maxAge()); if (!e) { return false } } return this._requestMatches(e, false) } _requestMatches(e, t) { return (!this._url || this._url === e.url) && this._host === e.headers.host && (!e.method || this._method === e.method || t && "HEAD" === e.method) && this._varyMatches(e) } _allowsStoringAuthenticated() { return this._rescc["must-revalidate"] || this._rescc.public || this._rescc["s-maxage"] } _varyMatches(e) { if (!this._resHeaders.vary) { return true } if (this._resHeaders.vary === "*") { return false } const t = this._resHeaders.vary.trim().toLowerCase().split(/\s*,\s*/); for (const r of t) { if (e.headers[r] !== this._reqHeaders[r]) return false } return true } _copyWithoutHopByHopHeaders(e) { const t = {}; for (const r in e) { if (i[r]) continue; t[r] = e[r] } if (e.connection) { const r = e.connection.trim().split(/\s*,\s*/); for (const e of r) { delete t[e] } } if (t.warning) { const e = t.warning.split(/,/).filter((e => !/^\s*1[0-9][0-9]/.test(e))); if (!e.length) { delete t.warning } else { t.warning = e.join(",").trim() } } return t } responseHeaders() { const e = this._copyWithoutHopByHopHeaders(this._resHeaders); const t = this.age(); if (t > 3600 * 24 && !this._hasExplicitExpiration() && this.maxAge() > 3600 * 24) { e.warning = (e.warning ? `${e.warning}, ` : "") + '113 - "rfc7234 5.5.4"' } e.age = `${Math.round(t)}`; e.date = new Date(this.now()).toUTCString(); return e } date() { const e = Date.parse(this._resHeaders.date); if (isFinite(e)) { return e } return this._responseTime } age() { let e = this._ageValue(); const t = (this.now() - this._responseTime) / 1e3; return e + t } _ageValue() { return toNumberOrZero(this._resHeaders.age) } maxAge() { if (!this.storable() || this._rescc["no-cache"]) { return 0 } if (this._isShared && (this._resHeaders["set-cookie"] && !this._rescc.public && !this._rescc.immutable)) { return 0 } if (this._resHeaders.vary === "*") { return 0 } if (this._isShared) { if (this._rescc["proxy-revalidate"]) { return 0 } if (this._rescc["s-maxage"]) { return toNumberOrZero(this._rescc["s-maxage"]) } } if (this._rescc["max-age"]) { return toNumberOrZero(this._rescc["max-age"]) } const e = this._rescc.immutable ? this._immutableMinTtl : 0; const t = this.date(); if (this._resHeaders.expires) { const r = Date.parse(this._resHeaders.expires); if (Number.isNaN(r) || r < t) { return 0 } return Math.max(e, (r - t) / 1e3) } if (this._resHeaders["last-modified"]) { const r = Date.parse(this._resHeaders["last-modified"]); if (isFinite(r) && t > r) { return Math.max(e, (t - r) / 1e3 * this._cacheHeuristic) } } return e } timeToLive() { const e = this.maxAge() - this.age(); const t = e + toNumberOrZero(this._rescc["stale-if-error"]); const r = e + toNumberOrZero(this._rescc["stale-while-revalidate"]); return Math.max(0, e, t, r) * 1e3 } stale() { return this.maxAge() <= this.age() } _useStaleIfError() { return this.maxAge() + toNumberOrZero(this._rescc["stale-if-error"]) > this.age() } useStaleWhileRevalidate() { return this.maxAge() + toNumberOrZero(this._rescc["stale-while-revalidate"]) > this.age() } static fromObject(e) { return new this(undefined, undefined, { _fromObject: e }) } _fromObject(e) { if (this._responseTime) throw Error("Reinitialized"); if (!e || e.v !== 1) throw Error("Invalid serialization"); this._responseTime = e.t; this._isShared = e.sh; this._cacheHeuristic = e.ch; this._immutableMinTtl = e.imm !== undefined ? e.imm : 24 * 3600 * 1e3; this._status = e.st; this._resHeaders = e.resh; this._rescc = e.rescc; this._method = e.m; this._url = e.u; this._host = e.h; this._noAuthorization = e.a; this._reqHeaders = e.reqh; this._reqcc = e.reqcc } toObject() { return { v: 1, t: this._responseTime, sh: this._isShared, ch: this._cacheHeuristic, imm: this._immutableMinTtl, st: this._status, resh: this._resHeaders, rescc: this._rescc, m: this._method, u: this._url, h: this._host, a: this._noAuthorization, reqh: this._reqHeaders, reqcc: this._reqcc } } revalidationHeaders(e) { this._assertRequestHasHeaders(e); const t = this._copyWithoutHopByHopHeaders(e.headers); delete t["if-range"]; if (!this._requestMatches(e, true) || !this.storable()) { delete t["if-none-match"]; delete t["if-modified-since"]; return t } if (this._resHeaders.etag) { t["if-none-match"] = t["if-none-match"] ? `${t["if-none-match"]}, ${this._resHeaders.etag}` : this._resHeaders.etag } const r = t["accept-ranges"] || t["if-match"] || t["if-unmodified-since"] || this._method && this._method != "GET"; if (r) { delete t["if-modified-since"]; if (t["if-none-match"]) { const e = t["if-none-match"].split(/,/).filter((e => !/^\s*W\//.test(e))); if (!e.length) { delete t["if-none-match"] } else { t["if-none-match"] = e.join(",").trim() } } } else if (this._resHeaders["last-modified"] && !t["if-modified-since"]) { t["if-modified-since"] = this._resHeaders["last-modified"] } return t } revalidatedPolicy(e, t) { this._assertRequestHasHeaders(e); if (this._useStaleIfError() && isErrorResponse(t)) { return { modified: false, matches: false, policy: this } } if (!t || !t.headers) { throw Error("Response headers missing") } let r = false; if (t.status !== undefined && t.status != 304) { r = false } else if (t.headers.etag && !/^\s*W\//.test(t.headers.etag)) { r = this._resHeaders.etag && this._resHeaders.etag.replace(/^\s*W\//, "") === t.headers.etag } else if (this._resHeaders.etag && t.headers.etag) { r = this._resHeaders.etag.replace(/^\s*W\//, "") === t.headers.etag.replace(/^\s*W\//, "") } else if (this._resHeaders["last-modified"]) { r = this._resHeaders["last-modified"] === t.headers["last-modified"] } else { if (!this._resHeaders.etag && !this._resHeaders["last-modified"] && !t.headers.etag && !t.headers["last-modified"]) { r = true } } if (!r) { return { policy: new this.constructor(e, t), modified: t.status != 304, matches: false } } const n = {}; for (const e in this._resHeaders) { n[e] = e in t.headers && !s[e] ? t.headers[e] : this._resHeaders[e] } const i = Object.assign({}, t, { status: this._status, method: this._method, headers: n }); return { policy: new this.constructor(e, i, { shared: this._isShared, cacheHeuristic: this._cacheHeuristic, immutableMinTimeToLive: this._immutableMinTtl }), modified: false, matches: true } } } }, 9898: (e, t, r) => { const { URL: n } = r(7310); const i = r(2361); const s = r(4404); const o = r(5158); const a = r(9273); const u = r(1086); const l = Symbol("currentStreamCount"); const f = Symbol("request"); const d = Symbol("cachedOriginSet"); const p = Symbol("gracefullyClosing"); const h = Symbol("length"); const m = ["createConnection", "maxDeflateDynamicTableSize", "maxSettings", "maxSessionMemory", "maxHeaderListPairs", "maxOutstandingPings", "maxReservedRemoteStreams", "maxSendHeaderBlockLength", "paddingStrategy", "peerMaxConcurrentStreams", "settings", "family", "localAddress", "rejectUnauthorized", "pskCallback", "minDHSize", "path", "socket", "ca", "cert", "sigalgs", "ciphers", "clientCertEngine", "crl", "dhparam", "ecdhCurve", "honorCipherOrder", "key", "privateKeyEngine", "privateKeyIdentifier", "maxVersion", "minVersion", "pfx", "secureOptions", "secureProtocol", "sessionIdContext", "ticketKeys"]; const getSortedIndex = (e, t, r) => { let n = 0; let i = e.length; while (n < i) { const s = n + i >>> 1; if (r(e[s], t)) { n = s + 1 } else { i = s } } return n }; const compareSessions = (e, t) => e.remoteSettings.maxConcurrentStreams > t.remoteSettings.maxConcurrentStreams; const closeCoveredSessions = (e, t) => { for (let r = 0; r < e.length; r++) { const n = e[r]; if (n[d].length > 0 && n[d].length < t[d].length && n[d].every((e => t[d].includes(e))) && n[l] + t[l] <= t.remoteSettings.maxConcurrentStreams) { gracefullyClose(n) } } }; const closeSessionIfCovered = (e, t) => { for (let r = 0; r < e.length; r++) { const n = e[r]; if (t[d].length > 0 && t[d].length < n[d].length && t[d].every((e => n[d].includes(e))) && t[l] + n[l] <= n.remoteSettings.maxConcurrentStreams) { gracefullyClose(t); return true } } return false }; const gracefullyClose = e => { e[p] = true; if (e[l] === 0) { e.close() } }; class Agent extends i { constructor({ timeout: e = 0, maxSessions: t = Number.POSITIVE_INFINITY, maxEmptySessions: r = 10, maxCachedTlsSessions: n = 100 } = {}) { super(); this.sessions = {}; this.queue = {}; this.timeout = e; this.maxSessions = t; this.maxEmptySessions = r; this._emptySessionCount = 0; this._sessionCount = 0; this.settings = { enablePush: false, initialWindowSize: 1024 * 1024 * 32 }; this.tlsSessionCache = new a({ maxSize: n }) } get protocol() { return "https:" } normalizeOptions(e) { let t = ""; for (let r = 0; r < m.length; r++) { const n = m[r]; t += ":"; if (e && e[n] !== undefined) { t += e[n] } } return t } _processQueue() { if (this._sessionCount >= this.maxSessions) { this.closeEmptySessions(this.maxSessions - this._sessionCount + 1); return } for (const e in this.queue) { for (const t in this.queue[e]) { const r = this.queue[e][t]; if (!r.completed) { r.completed = true; r() } } } } _isBetterSession(e, t) { return e > t } _accept(e, t, r, n) { let i = 0; while (i < t.length && e[l] < e.remoteSettings.maxConcurrentStreams) { t[i].resolve(e); i++ } t.splice(0, i); if (t.length > 0) { this.getSession(r, n, t); t.length = 0 } } getSession(e, t, r) { return new Promise(((i, s) => { if (Array.isArray(r) && r.length > 0) { r = [...r]; i() } else { r = [{ resolve: i, reject: s }] } try { if (typeof e === "string") { e = new n(e) } else if (!(e instanceof n)) { throw new TypeError("The `origin` argument needs to be a string or an URL object") } if (t) { const { servername: r } = t; const { hostname: n } = e; if (r && n !== r) { throw new Error(`Origin ${n} differs from servername ${r}`) } } } catch (e) { for (let t = 0; t < r.length; t++) { r[t].reject(e) } return } const a = this.normalizeOptions(t); const u = e.origin; if (a in this.sessions) { const e = this.sessions[a]; let n = -1; let i = -1; let s; for (let t = 0; t < e.length; t++) { const r = e[t]; const o = r.remoteSettings.maxConcurrentStreams; if (o < n) { break } if (!r[d].includes(u)) { continue } const a = r[l]; if (a >= o || r[p] || r.destroyed) { continue } if (!s) { n = o } if (this._isBetterSession(a, i)) { s = r; i = a } } if (s) { this._accept(s, r, u, t); return } } if (a in this.queue) { if (u in this.queue[a]) { this.queue[a][u].listeners.push(...r); return } } else { this.queue[a] = { [h]: 0 } } const removeFromQueue = () => { if (a in this.queue && this.queue[a][u] === entry) { delete this.queue[a][u]; if (--this.queue[a][h] === 0) { delete this.queue[a] } } }; const entry = async () => { this._sessionCount++; const n = `${u}:${a}`; let i = false; let s; try { const m = { ...t }; if (m.settings === undefined) { m.settings = this.settings } if (m.session === undefined) { m.session = this.tlsSessionCache.get(n) } const g = m.createConnection || this.createConnection; s = await g.call(this, e, m); m.createConnection = () => s; const y = o.connect(e, m); y[l] = 0; y[p] = false; const getOriginSet = () => { const { socket: e } = y; let t; if (e.servername === false) { e.servername = e.remoteAddress; t = y.originSet; e.servername = false } else { t = y.originSet } return t }; const isFree = () => y[l] < y.remoteSettings.maxConcurrentStreams; y.socket.once("session", (e => { this.tlsSessionCache.set(n, e) })); y.once("error", (e => { for (let t = 0; t < r.length; t++) { r[t].reject(e) } this.tlsSessionCache.delete(n) })); y.setTimeout(this.timeout, (() => { y.destroy() })); y.once("close", (() => { this._sessionCount--; if (i) { this._emptySessionCount--; const e = this.sessions[a]; if (e.length === 1) { delete this.sessions[a] } else { e.splice(e.indexOf(y), 1) } } else { removeFromQueue(); const e = new Error("Session closed without receiving a SETTINGS frame"); e.code = "HTTP2WRAPPER_NOSETTINGS"; for (let t = 0; t < r.length; t++) { r[t].reject(e) } } this._processQueue() })); const processListeners = () => { const e = this.queue[a]; if (!e) { return } const t = y[d]; for (let r = 0; r < t.length; r++) { const n = t[r]; if (n in e) { const { listeners: t, completed: r } = e[n]; let i = 0; while (i < t.length && isFree()) { t[i].resolve(y); i++ } e[n].listeners.splice(0, i); if (e[n].listeners.length === 0 && !r) { delete e[n]; if (--e[h] === 0) { delete this.queue[a]; break } } if (!isFree()) { break } } } }; y.on("origin", (() => { y[d] = getOriginSet() || []; y[p] = false; closeSessionIfCovered(this.sessions[a], y); if (y[p] || !isFree()) { return } processListeners(); if (!isFree()) { return } closeCoveredSessions(this.sessions[a], y) })); y.once("remoteSettings", (() => { if (entry.destroyed) { const e = new Error("Agent has been destroyed"); for (let t = 0; t < r.length; t++) { r[t].reject(e) } y.destroy(); return } if (y.setLocalWindowSize) { y.setLocalWindowSize(1024 * 1024 * 4) } y[d] = getOriginSet() || []; if (y.socket.encrypted) { const e = y[d][0]; if (e !== u) { const t = new Error(`Requested origin ${u} does not match server ${e}`); for (let e = 0; e < r.length; e++) { r[e].reject(t) } y.destroy(); return } } removeFromQueue(); { const e = this.sessions; if (a in e) { const t = e[a]; t.splice(getSortedIndex(t, y, compareSessions), 0, y) } else { e[a] = [y] } } i = true; this._emptySessionCount++; this.emit("session", y); this._accept(y, r, u, t); if (y[l] === 0 && this._emptySessionCount > this.maxEmptySessions) { this.closeEmptySessions(this._emptySessionCount - this.maxEmptySessions) } y.on("remoteSettings", (() => { if (!isFree()) { return } processListeners(); if (!isFree()) { return } closeCoveredSessions(this.sessions[a], y) })) })); y[f] = y.request; y.request = (e, t) => { if (y[p]) { throw new Error("The session is gracefully closing. No new streams are allowed.") } const r = y[f](e, t); y.ref(); if (y[l]++ === 0) { this._emptySessionCount-- } r.once("close", (() => { if (--y[l] === 0) { this._emptySessionCount++; y.unref(); if (this._emptySessionCount > this.maxEmptySessions || y[p]) { y.close(); return } } if (y.destroyed || y.closed) { return } if (isFree() && !closeSessionIfCovered(this.sessions[a], y)) { closeCoveredSessions(this.sessions[a], y); processListeners(); if (y[l] === 0) { this._processQueue() } } })); return r } } catch (e) { removeFromQueue(); this._sessionCount--; for (let t = 0; t < r.length; t++) { r[t].reject(e) } } }; entry.listeners = r; entry.completed = false; entry.destroyed = false; this.queue[a][u] = entry; this.queue[a][h]++; this._processQueue() })) } request(e, t, r, n) { return new Promise(((i, s) => { this.getSession(e, t, [{ reject: s, resolve: e => { try { const t = e.request(r, n); u(t); i(t) } catch (e) { s(e) } } }]) })) } async createConnection(e, t) { return Agent.connect(e, t) } static connect(e, t) { t.ALPNProtocols = ["h2"]; const r = e.port || 443; const n = e.hostname; if (typeof t.servername === "undefined") { t.servername = n } const i = s.connect(r, n, t); if (t.socket) { i._peername = { family: undefined, address: undefined, port: r } } return i } closeEmptySessions(e = Number.POSITIVE_INFINITY) { let t = 0; const { sessions: r } = this; for (const n in r) { const i = r[n]; for (let r = 0; r < i.length; r++) { const n = i[r]; if (n[l] === 0) { t++; n.close(); if (t >= e) { return t } } } } return t } destroy(e) { const { sessions: t, queue: r } = this; for (const r in t) { const n = t[r]; for (let t = 0; t < n.length; t++) { n[t].destroy(e) } } for (const e in r) { const t = r[e]; for (const e in t) { t[e].destroyed = true } } this.queue = {}; this.tlsSessionCache.clear() } get emptySessionCount() { return this._emptySessionCount } get pendingSessionCount() { return this._sessionCount - this._emptySessionCount } get sessionCount() { return this._sessionCount } } Agent.kCurrentStreamCount = l; Agent.kGracefullyClosing = p; e.exports = { Agent: Agent, globalAgent: new Agent } }, 7167: (e, t, r) => { const { URL: n, urlToHttpOptions: i } = r(7310); const s = r(3685); const o = r(5687); const a = r(6624); const u = r(9273); const { Agent: l, globalAgent: f } = r(9898); const d = r(9632); const p = r(1982); const h = r(1086); const m = new u({ maxSize: 100 }); const g = new Map; const installSocket = (e, t, r) => { t._httpMessage = { shouldKeepAlive: true }; const onFree = () => { e.emit("free", t, r) }; t.on("free", onFree); const onClose = () => { e.removeSocket(t, r) }; t.on("close", onClose); const onTimeout = () => { const { freeSockets: r } = e; for (const e of Object.values(r)) { if (e.includes(t)) { t.destroy(); return } } }; t.on("timeout", onTimeout); const onRemove = () => { e.removeSocket(t, r); t.off("close", onClose); t.off("free", onFree); t.off("timeout", onTimeout); t.off("agentRemove", onRemove) }; t.on("agentRemove", onRemove); e.emit("free", t, r) }; const createResolveProtocol = (e, t = new Map, r = undefined) => async n => { const i = `${n.host}:${n.port}:${n.ALPNProtocols.sort()}`; if (!e.has(i)) { if (t.has(i)) { const e = await t.get(i); return { alpnProtocol: e.alpnProtocol } } const { path: s } = n; n.path = n.socketPath; const o = a(n, r); t.set(i, o); try { const r = await o; e.set(i, r.alpnProtocol); t.delete(i); n.path = s; return r } catch (e) { t.delete(i); n.path = s; throw e } } return { alpnProtocol: e.get(i) } }; const y = createResolveProtocol(m, g); e.exports = async (e, t, r) => { if (typeof e === "string") { e = i(new n(e)) } else if (e instanceof n) { e = i(e) } else { e = { ...e } } if (typeof t === "function" || t === undefined) { r = t; t = e } else { t = Object.assign(e, t) } t.ALPNProtocols = t.ALPNProtocols || ["h2", "http/1.1"]; if (!Array.isArray(t.ALPNProtocols) || t.ALPNProtocols.length === 0) { throw new Error("The `ALPNProtocols` option must be an Array with at least one entry") } t.protocol = t.protocol || "https:"; const a = t.protocol === "https:"; t.host = t.hostname || t.host || "localhost"; t.session = t.tlsSession; t.servername = t.servername || p(t.headers && t.headers.host || t.host); t.port = t.port || (a ? 443 : 80); t._defaultAgent = a ? o.globalAgent : s.globalAgent; const u = t.resolveProtocol || y; let { agent: m } = t; if (m !== undefined && m !== false && m.constructor.name !== "Object") { throw new Error("The `options.agent` can be only an object `http`, `https` or `http2` properties") } if (a) { t.resolveSocket = true; let { socket: e, alpnProtocol: n, timeout: i } = await u(t); if (i) { if (e) { e.destroy() } const r = new Error(`Timed out resolving ALPN: ${t.timeout} ms`); r.code = "ETIMEDOUT"; r.ms = t.timeout; throw r } if (e && t.createConnection) { e.destroy(); e = undefined } delete t.resolveSocket; const s = n === "h2"; if (m) { m = s ? m.http2 : m.https; t.agent = m } if (m === undefined) { m = s ? f : o.globalAgent } if (e) { if (m === false) { e.destroy() } else { const r = (s ? l : o.Agent).prototype.createConnection; if (m.createConnection === r) { if (s) { t._reuseSocket = e } else { installSocket(m, e, t) } } else { e.destroy() } } } if (s) { return h(new d(t, r)) } } else if (m) { t.agent = m.http } return h(s.request(t, r)) }; e.exports.protocolCache = m; e.exports.resolveProtocol = y; e.exports.createResolveProtocol = createResolveProtocol }, 9632: (e, t, r) => { const { URL: n, urlToHttpOptions: i } = r(7310); const s = r(5158); const { Writable: o } = r(2781); const { Agent: a, globalAgent: u } = r(9898); const l = r(2575); const f = r(1818); const { ERR_INVALID_ARG_TYPE: d, ERR_INVALID_PROTOCOL: p, ERR_HTTP_HEADERS_SENT: h } = r(7087); const m = r(4592); const g = r(3549); const y = r(9404); const { HTTP2_HEADER_STATUS: b, HTTP2_HEADER_METHOD: _, HTTP2_HEADER_PATH: v, HTTP2_HEADER_AUTHORITY: w, HTTP2_METHOD_CONNECT: D } = s.constants; const E = Symbol("headers"); const S = Symbol("origin"); const C = Symbol("session"); const x = Symbol("options"); const A = Symbol("flushedHeaders"); const P = Symbol("jobs"); const R = Symbol("pendingAgentPromise"); class ClientRequest extends o { constructor(e, t, r) { super({ autoDestroy: false, emitClose: false }); if (typeof e === "string") { e = i(new n(e)) } else if (e instanceof n) { e = i(e) } else { e = { ...e } } if (typeof t === "function" || t === undefined) { r = t; t = e } else { t = Object.assign(e, t) } if (t.h2session) { this[C] = t.h2session; if (this[C].destroyed) { throw new Error("The session has been closed already") } this.protocol = this[C].socket.encrypted ? "https:" : "http:" } else if (t.agent === false) { this.agent = new a({ maxEmptySessions: 0 }) } else if (typeof t.agent === "undefined" || t.agent === null) { this.agent = u } else if (typeof t.agent.request === "function") { this.agent = t.agent } else { throw new d("options.agent", ["http2wrapper.Agent-like Object", "undefined", "false"], t.agent) } if (this.agent) { this.protocol = this.agent.protocol } if (t.protocol && t.protocol !== this.protocol) { throw new p(t.protocol, this.protocol) } if (!t.port) { t.port = t.defaultPort || this.agent && this.agent.defaultPort || 443 } t.host = t.hostname || t.host || "localhost"; delete t.hostname; const { timeout: s } = t; t.timeout = undefined; this[E] = Object.create(null); this[P] = []; this[R] = undefined; this.socket = null; this.connection = null; this.method = t.method || "GET"; if (!(this.method === "CONNECT" && (t.path === "/" || t.path === undefined))) { this.path = t.path } this.res = null; this.aborted = false; this.reusedSocket = false; const { headers: o } = t; if (o) { for (const e in o) { this.setHeader(e, o[e]) } } if (t.auth && !("authorization" in this[E])) { this[E].authorization = "Basic " + Buffer.from(t.auth).toString("base64") } t.session = t.tlsSession; t.path = t.socketPath; this[x] = t; this[S] = new n(`${this.protocol}//${t.servername || t.host}:${t.port}`); const l = t._reuseSocket; if (l) { t.createConnection = (...e) => { if (l.destroyed) { return this.agent.createConnection(...e) } return l }; this.agent.getSession(this[S], this[x]).catch((() => { })) } if (s) { this.setTimeout(s) } if (r) { this.once("response", r) } this[A] = false } get method() { return this[E][_] } set method(e) { if (e) { this[E][_] = e.toUpperCase() } } get path() { const e = this.method === "CONNECT" ? w : v; return this[E][e] } set path(e) { if (e) { const t = this.method === "CONNECT" ? w : v; this[E][t] = e } } get host() { return this[S].hostname } set host(e) { } get _mustNotHaveABody() { return this.method === "GET" || this.method === "HEAD" || this.method === "DELETE" } _write(e, t, r) { if (this._mustNotHaveABody) { r(new Error("The GET, HEAD and DELETE methods must NOT have a body")); return } this.flushHeaders(); const callWrite = () => this._request.write(e, t, r); if (this._request) { callWrite() } else { this[P].push(callWrite) } } _final(e) { this.flushHeaders(); const callEnd = () => { if (this._mustNotHaveABody || this.method === "CONNECT") { e(); return } this._request.end(e) }; if (this._request) { callEnd() } else { this[P].push(callEnd) } } abort() { if (this.res && this.res.complete) { return } if (!this.aborted) { process.nextTick((() => this.emit("abort"))) } this.aborted = true; this.destroy() } async _destroy(e, t) { if (this.res) { this.res._dump() } if (this._request) { this._request.destroy() } else { process.nextTick((() => { this.emit("close") })) } try { await this[R] } catch (t) { if (this.aborted) { e = t } } t(e) } async flushHeaders() { if (this[A] || this.destroyed) { return } this[A] = true; const e = this.method === D; const onStream = t => { this._request = t; if (this.destroyed) { t.destroy(); return } if (!e) { f(t, this, ["timeout", "continue"]) } t.once("error", (e => { this.destroy(e) })); t.once("aborted", (() => { const { res: e } = this; if (e) { e.aborted = true; e.emit("aborted"); e.destroy() } else { this.destroy(new Error("The server aborted the HTTP/2 stream")) } })); const onResponse = (r, n, i) => { const s = new l(this.socket, t.readableHighWaterMark); this.res = s; s.url = `${this[S].origin}${this.path}`; s.req = this; s.statusCode = r[b]; s.headers = r; s.rawHeaders = i; s.once("end", (() => { s.complete = true; s.socket = null; s.connection = null })); if (e) { s.upgrade = true; if (this.emit("connect", s, t, Buffer.alloc(0))) { this.emit("close") } else { t.destroy() } } else { t.on("data", (e => { if (!s._dumped && !s.push(e)) { t.pause() } })); t.once("end", (() => { if (!this.aborted) { s.push(null) } })); if (!this.emit("response", s)) { s._dump() } } }; t.once("response", onResponse); t.once("headers", (e => this.emit("information", { statusCode: e[b] }))); t.once("trailers", ((e, t, r) => { const { res: n } = this; if (n === null) { onResponse(e, t, r); return } n.trailers = e; n.rawTrailers = r })); t.once("close", (() => { const { aborted: e, res: t } = this; if (t) { if (e) { t.aborted = true; t.emit("aborted"); t.destroy() } const finish = () => { t.emit("close"); this.destroy(); this.emit("close") }; if (t.readable) { t.once("end", finish) } else { finish() } return } if (!this.destroyed) { this.destroy(new Error("The HTTP/2 stream has been early terminated")); this.emit("close"); return } this.destroy(); this.emit("close") })); this.socket = new Proxy(t, y); for (const e of this[P]) { e() } this[P].length = 0; this.emit("socket", this.socket) }; if (!(w in this[E]) && !e) { this[E][w] = this[S].host } if (this[C]) { try { onStream(this[C].request(this[E])) } catch (e) { this.destroy(e) } } else { this.reusedSocket = true; try { const e = this.agent.request(this[S], this[x], this[E]); this[R] = e; onStream(await e); this[R] = false } catch (e) { this[R] = false; this.destroy(e) } } } get connection() { return this.socket } set connection(e) { this.socket = e } getHeaderNames() { return Object.keys(this[E]) } hasHeader(e) { if (typeof e !== "string") { throw new d("name", "string", e) } return Boolean(this[E][e.toLowerCase()]) } getHeader(e) { if (typeof e !== "string") { throw new d("name", "string", e) } return this[E][e.toLowerCase()] } get headersSent() { return this[A] } removeHeader(e) { if (typeof e !== "string") { throw new d("name", "string", e) } if (this.headersSent) { throw new h("remove") } delete this[E][e.toLowerCase()] } setHeader(e, t) { if (this.headersSent) { throw new h("set") } m(e); g(e, t); const r = e.toLowerCase(); if (r === "connection") { if (t.toLowerCase() === "keep-alive") { return } throw new Error(`Invalid 'connection' header: ${t}`) } if (r === "host" && this.method === "CONNECT") { this[E][w] = t } else { this[E][r] = t } } setNoDelay() { } setSocketKeepAlive() { } setTimeout(e, t) { const applyTimeout = () => this._request.setTimeout(e, t); if (this._request) { applyTimeout() } else { this[P].push(applyTimeout) } return this } get maxHeadersCount() { if (!this.destroyed && this._request) { return this._request.session.localSettings.maxHeaderListSize } return undefined } set maxHeadersCount(e) { } } e.exports = ClientRequest }, 2575: (e, t, r) => { const { Readable: n } = r(2781); class IncomingMessage extends n { constructor(e, t) { super({ emitClose: false, autoDestroy: true, highWaterMark: t }); this.statusCode = null; this.statusMessage = ""; this.httpVersion = "2.0"; this.httpVersionMajor = 2; this.httpVersionMinor = 0; this.headers = {}; this.trailers = {}; this.req = null; this.aborted = false; this.complete = false; this.upgrade = null; this.rawHeaders = []; this.rawTrailers = []; this.socket = e; this._dumped = false } get connection() { return this.socket } set connection(e) { this.socket = e } _destroy(e, t) { if (!this.readableEnded) { this.aborted = true } t(); this.req._request.destroy(e) } setTimeout(e, t) { this.req.setTimeout(e, t); return this } _dump() { if (!this._dumped) { this._dumped = true; this.removeAllListeners("data"); this.resume() } } _read() { if (this.req) { this.req._request.resume() } } } e.exports = IncomingMessage }, 4645: (e, t, r) => { const n = r(5158); const { Agent: i, globalAgent: s } = r(9898); const o = r(9632); const a = r(2575); const u = r(7167); const { HttpOverHttp2: l, HttpsOverHttp2: f } = r(8795); const d = r(8553); const { Http2OverHttp: p, Http2OverHttps: h } = r(9794); const m = r(4592); const g = r(3549); const request = (e, t, r) => new o(e, t, r); const get = (e, t, r) => { const n = new o(e, t, r); n.end(); return n }; e.exports = { ...n, ClientRequest: o, IncomingMessage: a, Agent: i, globalAgent: s, request: request, get: get, auto: u, proxies: { HttpOverHttp2: l, HttpsOverHttp2: f, Http2OverHttp2: d, Http2OverHttp: p, Http2OverHttps: h }, validateHeaderName: m, validateHeaderValue: g } }, 7885: e => { e.exports = e => { const { username: t, password: r } = e.proxyOptions.url; if (t || r) { const e = `${t}:${r}`; const n = `Basic ${Buffer.from(e).toString("base64")}`; return { "proxy-authorization": n, authorization: n } } return {} } }, 8795: (e, t, r) => { const n = r(4404); const i = r(3685); const s = r(5687); const o = r(1564); const { globalAgent: a } = r(9898); const u = r(6203); const l = r(1089); const f = r(7885); const createConnection = (e, t, r) => { (async () => { try { const { proxyOptions: i } = e; const { url: l, headers: d, raw: p } = i; const h = await a.request(l, i, { ...f(e), ...d, ":method": "CONNECT", ":authority": `${t.host}:${t.port}` }); h.once("error", r); h.once("response", (i => { const a = i[":status"]; if (a !== 200) { r(new u(a, "")); return } const l = e instanceof s.Agent; if (p && l) { t.socket = h; const e = n.connect(t); e.once("close", (() => { h.destroy() })); r(null, e); return } const f = new o(h); f.encrypted = false; f._handle.getpeername = e => { e.family = undefined; e.address = undefined; e.port = undefined }; r(null, f) })) } catch (e) { r(e) } })() }; class HttpOverHttp2 extends i.Agent { constructor(e) { super(e); l(this, e.proxyOptions) } createConnection(e, t) { createConnection(this, e, t) } } class HttpsOverHttp2 extends s.Agent { constructor(e) { super(e); l(this, e.proxyOptions) } createConnection(e, t) { createConnection(this, e, t) } } e.exports = { HttpOverHttp2: HttpOverHttp2, HttpsOverHttp2: HttpsOverHttp2 } }, 9794: (e, t, r) => { const n = r(3685); const i = r(5687); const s = r(1857); const o = r(7885); const getStream = e => new Promise(((t, r) => { const onConnect = (n, i, s) => { i.unshift(s); e.off("error", r); t([i, n.statusCode, n.statusMessage]) }; e.once("error", r); e.once("connect", onConnect) })); class Http2OverHttp extends s { async _getProxyStream(e) { const { proxyOptions: t } = this; const { url: r, headers: s } = this.proxyOptions; const a = r.protocol === "https:" ? i : n; const u = a.request({ ...t, hostname: r.hostname, port: r.port, path: e, headers: { ...o(this), ...s, host: e }, method: "CONNECT" }).end(); return getStream(u) } } e.exports = { Http2OverHttp: Http2OverHttp, Http2OverHttps: Http2OverHttp } }, 8553: (e, t, r) => { const { globalAgent: n } = r(9898); const i = r(1857); const s = r(7885); const getStatusCode = e => new Promise(((t, r) => { e.once("error", r); e.once("response", (n => { e.off("error", r); t(n[":status"]) })) })); class Http2OverHttp2 extends i { async _getProxyStream(e) { const { proxyOptions: t } = this; const r = { ...s(this), ...t.headers, ":method": "CONNECT", ":authority": e }; const i = await n.request(t.url, t, r); const o = await getStatusCode(i); return [i, o, ""] } } e.exports = Http2OverHttp2 }, 1857: (e, t, r) => { const { Agent: n } = r(9898); const i = r(1564); const s = r(6203); const o = r(1089); class Http2OverHttpX extends n { constructor(e) { super(e); o(this, e.proxyOptions) } async createConnection(e, t) { const r = `${e.hostname}:${e.port || 443}`; const [n, o, a] = await this._getProxyStream(r); if (o !== 200) { throw new s(o, a) } if (this.proxyOptions.raw) { t.socket = n } else { const e = new i(n); e.encrypted = false; e._handle.getpeername = e => { e.family = undefined; e.address = undefined; e.port = undefined }; return e } return super.createConnection(e, t) } } e.exports = Http2OverHttpX }, 1089: (e, t, r) => { const { URL: n } = r(7310); const i = r(3453); e.exports = (e, t) => { i("proxyOptions", t, ["object"]); i("proxyOptions.headers", t.headers, ["object", "undefined"]); i("proxyOptions.raw", t.raw, ["boolean", "undefined"]); i("proxyOptions.url", t.url, [n, "string"]); const r = new n(t.url); e.proxyOptions = { raw: true, ...t, headers: { ...t.headers }, url: r } } }, 6203: e => { class UnexpectedStatusCodeError extends Error { constructor(e, t = "") { super(`The proxy server rejected the request with status code ${e} (${t || "empty status message"})`); this.statusCode = e; this.statusMessage = t } } e.exports = UnexpectedStatusCodeError }, 1982: (e, t, r) => { const { isIP: n } = r(1808); const i = r(9491); const getHost = e => { if (e[0] === "[") { const t = e.indexOf("]"); i(t !== -1); return e.slice(1, t) } const t = e.indexOf(":"); if (t === -1) { return e } return e.slice(0, t) }; e.exports = e => { const t = getHost(e); if (n(t)) { return "" } return t } }, 3453: e => { const checkType = (e, t, r) => { const n = r.some((e => { const r = typeof e; if (r === "string") { return typeof t === e } return t instanceof e })); if (!n) { const n = r.map((e => typeof e === "string" ? e : e.name)); throw new TypeError(`Expected '${e}' to be a type of ${n.join(" or ")}, got ${typeof t}`) } }; e.exports = checkType }, 1086: e => { e.exports = e => { if (e.listenerCount("error") !== 0) { return e } e.__destroy = e._destroy; e._destroy = (...t) => { const r = t.pop(); e.__destroy(...t, (async e => { await Promise.resolve(); r(e) })) }; const onError = t => { Promise.resolve().then((() => { e.emit("error", t) })) }; e.once("error", onError); Promise.resolve().then((() => { e.off("error", onError) })); return e } }, 7087: e => { const makeError = (t, r, n) => { e.exports[r] = class NodeError extends t { constructor(...e) { super(typeof n === "string" ? n : n(e)); this.name = `${super.name} [${r}]`; this.code = r } } }; makeError(TypeError, "ERR_INVALID_ARG_TYPE", (e => { const t = e[0].includes(".") ? "property" : "argument"; let r = e[1]; const n = Array.isArray(r); if (n) { r = `${r.slice(0, -1).join(", ")} or ${r.slice(-1)}` } return `The "${e[0]}" ${t} must be ${n ? "one of" : "of"} type ${r}. Received ${typeof e[2]}` })); makeError(TypeError, "ERR_INVALID_PROTOCOL", (e => `Protocol "${e[0]}" not supported. Expected "${e[1]}"`)); makeError(Error, "ERR_HTTP_HEADERS_SENT", (e => `Cannot ${e[0]} headers after they are sent to the client`)); makeError(TypeError, "ERR_INVALID_HTTP_TOKEN", (e => `${e[0]} must be a valid HTTP token [${e[1]}]`)); makeError(TypeError, "ERR_HTTP_INVALID_HEADER_VALUE", (e => `Invalid value "${e[0]} for header "${e[1]}"`)); makeError(TypeError, "ERR_INVALID_CHAR", (e => `Invalid character in ${e[0]} [${e[1]}]`)); makeError(Error, "ERR_HTTP2_NO_SOCKET_MANIPULATION", "HTTP/2 sockets should not be directly manipulated (e.g. read and written)") }, 1199: e => { e.exports = e => { switch (e) { case ":method": case ":scheme": case ":authority": case ":path": return true; default: return false } } }, 1564: (e, t, r) => { const n = r(2781); const i = r(4404); const s = new i.TLSSocket(new n.PassThrough)._handle._parentWrap.constructor; e.exports = s }, 1818: e => { e.exports = (e, t, r) => { for (const n of r) { e.on(n, ((...e) => t.emit(n, ...e))) } } }, 9404: (e, t, r) => { const { ERR_HTTP2_NO_SOCKET_MANIPULATION: n } = r(7087); const i = { has(e, t) { const r = e.session === undefined ? e : e.session.socket; return t in e || t in r }, get(e, t) { switch (t) { case "on": case "once": case "end": case "emit": case "destroy": return e[t].bind(e); case "writable": case "destroyed": return e[t]; case "readable": if (e.destroyed) { return false } return e.readable; case "setTimeout": { const { session: t } = e; if (t !== undefined) { return t.setTimeout.bind(t) } return e.setTimeout.bind(e) } case "write": case "read": case "pause": case "resume": throw new n; default: { const r = e.session === undefined ? e : e.session.socket; const n = r[t]; return typeof n === "function" ? n.bind(r) : n } } }, getPrototypeOf(e) { if (e.session !== undefined) { return Reflect.getPrototypeOf(e.session.socket) } return Reflect.getPrototypeOf(e) }, set(e, t, r) { switch (t) { case "writable": case "readable": case "destroyed": case "on": case "once": case "end": case "emit": case "destroy": e[t] = r; return true; case "setTimeout": { const { session: t } = e; if (t === undefined) { e.setTimeout = r } else { t.setTimeout = r } return true } case "write": case "read": case "pause": case "resume": throw new n; default: { const n = e.session === undefined ? e : e.session.socket; n[t] = r; return true } } } }; e.exports = i }, 4592: (e, t, r) => { const { ERR_INVALID_HTTP_TOKEN: n } = r(7087); const i = r(1199); const s = /^[\^`\-\w!#$%&*+.|~]+$/; e.exports = e => { if (typeof e !== "string" || !s.test(e) && !i(e)) { throw new n("Header name", e) } } }, 3549: (e, t, r) => { const { ERR_HTTP_INVALID_HEADER_VALUE: n, ERR_INVALID_CHAR: i } = r(7087); const s = /[^\t\u0020-\u007E\u0080-\u00FF]/; e.exports = (e, t) => { if (typeof t === "undefined") { throw new n(t, e) } if (s.test(t)) { throw new i("header content", e) } } }, 4777: e => { function makeArray(e) { return Array.isArray(e) ? e : [e] } const t = ""; const r = " "; const n = "\\"; const i = /^\s+$/; const s = /(?:[^\\]|^)\\$/; const o = /^\\!/; const a = /^\\#/; const u = /\r?\n/g; const l = /^\.*\/|^\.+$/; const f = "/"; let d = "node-ignore"; if (typeof Symbol !== "undefined") { d = Symbol.for("node-ignore") } const p = d; const define = (e, t, r) => Object.defineProperty(e, t, { value: r }); const h = /([0-z])-([0-z])/g; const RETURN_FALSE = () => false; const sanitizeRange = e => e.replace(h, ((e, r, n) => r.charCodeAt(0) <= n.charCodeAt(0) ? e : t)); const cleanRangeBackSlash = e => { const { length: t } = e; return e.slice(0, t - t % 2) }; const m = [[/\\?\s+$/, e => e.indexOf("\\") === 0 ? r : t], [/\\\s/g, () => r], [/[\\$.|*+(){^]/g, e => `\\${e}`], [/(?!\\)\?/g, () => "[^/]"], [/^\//, () => "^"], [/\//g, () => "\\/"], [/^\^*\\\*\\\*\\\//, () => "^(?:.*\\/)?"], [/^(?=[^^])/, function startingReplacer() { return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^" }], [/\\\/\\\*\\\*(?=\\\/|$)/g, (e, t, r) => t + 6 < r.length ? "(?:\\/[^\\/]+)*" : "\\/.+"], [/(^|[^\\]+)(\\\*)+(?=.+)/g, (e, t, r) => { const n = r.replace(/\\\*/g, "[^\\/]*"); return t + n }], [/\\\\\\(?=[$.|*+(){^])/g, () => n], [/\\\\/g, () => n], [/(\\)?\[([^\]/]*?)(\\*)($|\])/g, (e, t, r, i, s) => t === n ? `\\[${r}${cleanRangeBackSlash(i)}${s}` : s === "]" ? i.length % 2 === 0 ? `[${sanitizeRange(r)}${i}]` : "[]" : "[]"], [/(?:[^*])$/, e => /\/$/.test(e) ? `${e}$` : `${e}(?=$|\\/$)`], [/(\^|\\\/)?\\\*$/, (e, t) => { const r = t ? `${t}[^/]+` : "[^/]*"; return `${r}(?=$|\\/$)` }]]; const g = Object.create(null); const makeRegex = (e, t) => { let r = g[e]; if (!r) { r = m.reduce(((t, r) => t.replace(r[0], r[1].bind(e))), e); g[e] = r } return t ? new RegExp(r, "i") : new RegExp(r) }; const isString = e => typeof e === "string"; const checkPattern = e => e && isString(e) && !i.test(e) && !s.test(e) && e.indexOf("#") !== 0; const splitPattern = e => e.split(u); class IgnoreRule { constructor(e, t, r, n) { this.origin = e; this.pattern = t; this.negative = r; this.regex = n } } const createRule = (e, t) => { const r = e; let n = false; if (e.indexOf("!") === 0) { n = true; e = e.substr(1) } e = e.replace(o, "!").replace(a, "#"); const i = makeRegex(e, t); return new IgnoreRule(r, e, n, i) }; const throwError = (e, t) => { throw new t(e) }; const checkPath = (e, t, r) => { if (!isString(e)) { return r(`path must be a string, but got \`${t}\``, TypeError) } if (!e) { return r(`path must not be empty`, TypeError) } if (checkPath.isNotRelative(e)) { const e = "`path.relative()`d"; return r(`path should be a ${e} string, but got "${t}"`, RangeError) } return true }; const isNotRelative = e => l.test(e); checkPath.isNotRelative = isNotRelative; checkPath.convert = e => e; class Ignore { constructor({ ignorecase: e = true, ignoreCase: t = e, allowRelativePaths: r = false } = {}) { define(this, p, true); this._rules = []; this._ignoreCase = t; this._allowRelativePaths = r; this._initCache() } _initCache() { this._ignoreCache = Object.create(null); this._testCache = Object.create(null) } _addPattern(e) { if (e && e[p]) { this._rules = this._rules.concat(e._rules); this._added = true; return } if (checkPattern(e)) { const t = createRule(e, this._ignoreCase); this._added = true; this._rules.push(t) } } add(e) { this._added = false; makeArray(isString(e) ? splitPattern(e) : e).forEach(this._addPattern, this); if (this._added) { this._initCache() } return this } addPattern(e) { return this.add(e) } _testOne(e, t) { let r = false; let n = false; this._rules.forEach((i => { const { negative: s } = i; if (n === s && r !== n || s && !r && !n && !t) { return } const o = i.regex.test(e); if (o) { r = !s; n = s } })); return { ignored: r, unignored: n } } _test(e, t, r, n) { const i = e && checkPath.convert(e); checkPath(i, e, this._allowRelativePaths ? RETURN_FALSE : throwError); return this._t(i, t, r, n) } _t(e, t, r, n) { if (e in t) { return t[e] } if (!n) { n = e.split(f) } n.pop(); if (!n.length) { return t[e] = this._testOne(e, r) } const i = this._t(n.join(f) + f, t, r, n); return t[e] = i.ignored ? i : this._testOne(e, r) } ignores(e) { return this._test(e, this._ignoreCache, false).ignored } createFilter() { return e => !this.ignores(e) } filter(e) { return makeArray(e).filter(this.createFilter()) } test(e) { return this._test(e, this._testCache, true) } } const factory = e => new Ignore(e); const isPathValid = e => checkPath(e && checkPath.convert(e), e, RETURN_FALSE); factory.isPathValid = isPathValid; factory.default = factory; e.exports = factory; if (typeof process !== "undefined" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")) { const makePosix = e => /^\\\\\?\\/.test(e) || /["<>|\u0000-\u001F]+/u.test(e) ? e : e.replace(/\\/g, "/"); checkPath.convert = makePosix; const e = /^[a-z]:\//i; checkPath.isNotRelative = t => e.test(t) || isNotRelative(t) } }, 4124: (e, t, r) => { try { var n = r(3837); if (typeof n.inherits !== "function") throw ""; e.exports = n.inherits } catch (t) { e.exports = r(8544) } }, 8544: e => { if (typeof Object.create === "function") { e.exports = function inherits(e, t) { if (t) { e.super_ = t; e.prototype = Object.create(t.prototype, { constructor: { value: e, enumerable: false, writable: true, configurable: true } }) } } } else { e.exports = function inherits(e, t) { if (t) { e.super_ = t; var TempCtor = function () { }; TempCtor.prototype = t.prototype; e.prototype = new TempCtor; e.prototype.constructor = e } } } }, 429: e => {
    /*!
     * is-extendable <https://github.com/jonschlinkert/is-extendable>
     *
     * Copyright (c) 2015, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    e.exports = function isExtendable(e) { return typeof e !== "undefined" && e !== null && (typeof e === "object" || typeof e === "function") }
  }, 6435: e => {
    /*!
     * is-extglob <https://github.com/jonschlinkert/is-extglob>
     *
     * Copyright (c) 2014-2016, Jon Schlinkert.
     * Licensed under the MIT License.
     */
    e.exports = function isExtglob(e) { if (typeof e !== "string" || e === "") { return false } var t; while (t = /(\\).|([@?!+*]\(.*\))/g.exec(e)) { if (t[2]) return true; e = e.slice(t.index + t[0].length) } return false }
  }, 4882: e => { const isFullwidthCodePoint = e => { if (Number.isNaN(e)) { return false } if (e >= 4352 && (e <= 4447 || e === 9001 || e === 9002 || 11904 <= e && e <= 12871 && e !== 12351 || 12880 <= e && e <= 19903 || 19968 <= e && e <= 42182 || 43360 <= e && e <= 43388 || 44032 <= e && e <= 55203 || 63744 <= e && e <= 64255 || 65040 <= e && e <= 65049 || 65072 <= e && e <= 65131 || 65281 <= e && e <= 65376 || 65504 <= e && e <= 65510 || 110592 <= e && e <= 110593 || 127488 <= e && e <= 127569 || 131072 <= e && e <= 262141)) { return true } return false }; e.exports = isFullwidthCodePoint; e.exports["default"] = isFullwidthCodePoint }, 4466: (e, t, r) => {
    /*!
     * is-glob <https://github.com/jonschlinkert/is-glob>
     *
     * Copyright (c) 2014-2017, Jon Schlinkert.
     * Released under the MIT License.
     */
    var n = r(6435); var i = { "{": "}", "(": ")", "[": "]" }; var strictCheck = function (e) { if (e[0] === "!") { return true } var t = 0; var r = -2; var n = -2; var s = -2; var o = -2; var a = -2; while (t < e.length) { if (e[t] === "*") { return true } if (e[t + 1] === "?" && /[\].+)]/.test(e[t])) { return true } if (n !== -1 && e[t] === "[" && e[t + 1] !== "]") { if (n < t) { n = e.indexOf("]", t) } if (n > t) { if (a === -1 || a > n) { return true } a = e.indexOf("\\", t); if (a === -1 || a > n) { return true } } } if (s !== -1 && e[t] === "{" && e[t + 1] !== "}") { s = e.indexOf("}", t); if (s > t) { a = e.indexOf("\\", t); if (a === -1 || a > s) { return true } } } if (o !== -1 && e[t] === "(" && e[t + 1] === "?" && /[:!=]/.test(e[t + 2]) && e[t + 3] !== ")") { o = e.indexOf(")", t); if (o > t) { a = e.indexOf("\\", t); if (a === -1 || a > o) { return true } } } if (r !== -1 && e[t] === "(" && e[t + 1] !== "|") { if (r < t) { r = e.indexOf("|", t) } if (r !== -1 && e[r + 1] !== ")") { o = e.indexOf(")", r); if (o > r) { a = e.indexOf("\\", r); if (a === -1 || a > o) { return true } } } } if (e[t] === "\\") { var u = e[t + 1]; t += 2; var l = i[u]; if (l) { var f = e.indexOf(l, t); if (f !== -1) { t = f + 1 } } if (e[t] === "!") { return true } } else { t++ } } return false }; var relaxedCheck = function (e) { if (e[0] === "!") { return true } var t = 0; while (t < e.length) { if (/[*?{}()[\]]/.test(e[t])) { return true } if (e[t] === "\\") { var r = e[t + 1]; t += 2; var n = i[r]; if (n) { var s = e.indexOf(n, t); if (s !== -1) { t = s + 1 } } if (e[t] === "!") { return true } } else { t++ } } return false }; e.exports = function isGlob(e, t) { if (typeof e !== "string" || e === "") { return false } if (n(e)) { return true } var r = strictCheck; if (t && t.strict === false) { r = relaxedCheck } return r(e) }
  }, 5680: e => {
    /*!
     * is-number <https://github.com/jonschlinkert/is-number>
     *
     * Copyright (c) 2014-present, Jon Schlinkert.
     * Released under the MIT License.
     */
    e.exports = function (e) { if (typeof e === "number") { return e - e === 0 } if (typeof e === "string" && e.trim() !== "") { return Number.isFinite ? Number.isFinite(+e) : isFinite(+e) } return false }
  }, 7126: (e, t, r) => { var n = r(7147); var i; if (process.platform === "win32" || global.TESTING_WINDOWS) { i = r(2001) } else { i = r(9728) } e.exports = isexe; isexe.sync = sync; function isexe(e, t, r) { if (typeof t === "function") { r = t; t = {} } if (!r) { if (typeof Promise !== "function") { throw new TypeError("callback not provided") } return new Promise((function (r, n) { isexe(e, t || {}, (function (e, t) { if (e) { n(e) } else { r(t) } })) })) } i(e, t || {}, (function (e, n) { if (e) { if (e.code === "EACCES" || t && t.ignoreErrors) { e = null; n = false } } r(e, n) })) } function sync(e, t) { try { return i.sync(e, t || {}) } catch (e) { if (t && t.ignoreErrors || e.code === "EACCES") { return false } else { throw e } } } }, 9728: (e, t, r) => { e.exports = isexe; isexe.sync = sync; var n = r(7147); function isexe(e, t, r) { n.stat(e, (function (e, n) { r(e, e ? false : checkStat(n, t)) })) } function sync(e, t) { return checkStat(n.statSync(e), t) } function checkStat(e, t) { return e.isFile() && checkMode(e, t) } function checkMode(e, t) { var r = e.mode; var n = e.uid; var i = e.gid; var s = t.uid !== undefined ? t.uid : process.getuid && process.getuid(); var o = t.gid !== undefined ? t.gid : process.getgid && process.getgid(); var a = parseInt("100", 8); var u = parseInt("010", 8); var l = parseInt("001", 8); var f = a | u; var d = r & l || r & u && i === o || r & a && n === s || r & f && s === 0; return d } }, 2001: (e, t, r) => { e.exports = isexe; isexe.sync = sync; var n = r(7147); function checkPathExt(e, t) { var r = t.pathExt !== undefined ? t.pathExt : process.env.PATHEXT; if (!r) { return true } r = r.split(";"); if (r.indexOf("") !== -1) { return true } for (var n = 0; n < r.length; n++) { var i = r[n].toLowerCase(); if (i && e.substr(-i.length).toLowerCase() === i) { return true } } return false } function checkStat(e, t, r) { if (!e.isSymbolicLink() && !e.isFile()) { return false } return checkPathExt(t, r) } function isexe(e, t, r) { n.stat(e, (function (n, i) { r(n, n ? false : checkStat(i, e, t)) })) } function sync(e, t) { return checkStat(n.statSync(e), e, t) } }, 1917: (e, t, r) => { var n = r(916); e.exports = n }, 916: (e, t, r) => { var n = r(5190); var i = r(3034); function deprecated(e) { return function () { throw new Error("Function " + e + " is deprecated and cannot be used.") } } e.exports.Type = r(967); e.exports.Schema = r(6514); e.exports.FAILSAFE_SCHEMA = r(6037); e.exports.JSON_SCHEMA = r(1571); e.exports.CORE_SCHEMA = r(2183); e.exports.DEFAULT_SAFE_SCHEMA = r(8949); e.exports.DEFAULT_FULL_SCHEMA = r(6874); e.exports.load = n.load; e.exports.loadAll = n.loadAll; e.exports.safeLoad = n.safeLoad; e.exports.safeLoadAll = n.safeLoadAll; e.exports.dump = i.dump; e.exports.safeDump = i.safeDump; e.exports.YAMLException = r(5199); e.exports.MINIMAL_SCHEMA = r(6037); e.exports.SAFE_SCHEMA = r(8949); e.exports.DEFAULT_SCHEMA = r(6874); e.exports.scan = deprecated("scan"); e.exports.parse = deprecated("parse"); e.exports.compose = deprecated("compose"); e.exports.addConstructor = deprecated("addConstructor") }, 9136: e => { function isNothing(e) { return typeof e === "undefined" || e === null } function isObject(e) { return typeof e === "object" && e !== null } function toArray(e) { if (Array.isArray(e)) return e; else if (isNothing(e)) return []; return [e] } function extend(e, t) { var r, n, i, s; if (t) { s = Object.keys(t); for (r = 0, n = s.length; r < n; r += 1) { i = s[r]; e[i] = t[i] } } return e } function repeat(e, t) { var r = "", n; for (n = 0; n < t; n += 1) { r += e } return r } function isNegativeZero(e) { return e === 0 && Number.NEGATIVE_INFINITY === 1 / e } e.exports.isNothing = isNothing; e.exports.isObject = isObject; e.exports.toArray = toArray; e.exports.repeat = repeat; e.exports.isNegativeZero = isNegativeZero; e.exports.extend = extend }, 3034: (e, t, r) => { var n = r(9136); var i = r(5199); var s = r(6874); var o = r(8949); var a = Object.prototype.toString; var u = Object.prototype.hasOwnProperty; var l = 9; var f = 10; var d = 13; var p = 32; var h = 33; var m = 34; var g = 35; var y = 37; var b = 38; var _ = 39; var v = 42; var w = 44; var D = 45; var E = 58; var S = 61; var C = 62; var x = 63; var A = 64; var P = 91; var R = 93; var k = 96; var O = 123; var T = 124; var F = 125; var j = {}; j[0] = "\\0"; j[7] = "\\a"; j[8] = "\\b"; j[9] = "\\t"; j[10] = "\\n"; j[11] = "\\v"; j[12] = "\\f"; j[13] = "\\r"; j[27] = "\\e"; j[34] = '\\"'; j[92] = "\\\\"; j[133] = "\\N"; j[160] = "\\_"; j[8232] = "\\L"; j[8233] = "\\P"; var L = ["y", "Y", "yes", "Yes", "YES", "on", "On", "ON", "n", "N", "no", "No", "NO", "off", "Off", "OFF"]; function compileStyleMap(e, t) { var r, n, i, s, o, a, l; if (t === null) return {}; r = {}; n = Object.keys(t); for (i = 0, s = n.length; i < s; i += 1) { o = n[i]; a = String(t[o]); if (o.slice(0, 2) === "!!") { o = "tag:yaml.org,2002:" + o.slice(2) } l = e.compiledTypeMap["fallback"][o]; if (l && u.call(l.styleAliases, a)) { a = l.styleAliases[a] } r[o] = a } return r } function encodeHex(e) { var t, r, s; t = e.toString(16).toUpperCase(); if (e <= 255) { r = "x"; s = 2 } else if (e <= 65535) { r = "u"; s = 4 } else if (e <= 4294967295) { r = "U"; s = 8 } else { throw new i("code point within a string may not be greater than 0xFFFFFFFF") } return "\\" + r + n.repeat("0", s - t.length) + t } function State(e) { this.schema = e["schema"] || s; this.indent = Math.max(1, e["indent"] || 2); this.noArrayIndent = e["noArrayIndent"] || false; this.skipInvalid = e["skipInvalid"] || false; this.flowLevel = n.isNothing(e["flowLevel"]) ? -1 : e["flowLevel"]; this.styleMap = compileStyleMap(this.schema, e["styles"] || null); this.sortKeys = e["sortKeys"] || false; this.lineWidth = e["lineWidth"] || 80; this.noRefs = e["noRefs"] || false; this.noCompatMode = e["noCompatMode"] || false; this.condenseFlow = e["condenseFlow"] || false; this.implicitTypes = this.schema.compiledImplicit; this.explicitTypes = this.schema.compiledExplicit; this.tag = null; this.result = ""; this.duplicates = []; this.usedDuplicates = null } function indentString(e, t) { var r = n.repeat(" ", t), i = 0, s = -1, o = "", a, u = e.length; while (i < u) { s = e.indexOf("\n", i); if (s === -1) { a = e.slice(i); i = u } else { a = e.slice(i, s + 1); i = s + 1 } if (a.length && a !== "\n") o += r; o += a } return o } function generateNextLine(e, t) { return "\n" + n.repeat(" ", e.indent * t) } function testImplicitResolving(e, t) { var r, n, i; for (r = 0, n = e.implicitTypes.length; r < n; r += 1) { i = e.implicitTypes[r]; if (i.resolve(t)) { return true } } return false } function isWhitespace(e) { return e === p || e === l } function isPrintable(e) { return 32 <= e && e <= 126 || 161 <= e && e <= 55295 && e !== 8232 && e !== 8233 || 57344 <= e && e <= 65533 && e !== 65279 || 65536 <= e && e <= 1114111 } function isNsChar(e) { return isPrintable(e) && !isWhitespace(e) && e !== 65279 && e !== d && e !== f } function isPlainSafe(e, t) { return isPrintable(e) && e !== 65279 && e !== w && e !== P && e !== R && e !== O && e !== F && e !== E && (e !== g || t && isNsChar(t)) } function isPlainSafeFirst(e) { return isPrintable(e) && e !== 65279 && !isWhitespace(e) && e !== D && e !== x && e !== E && e !== w && e !== P && e !== R && e !== O && e !== F && e !== g && e !== b && e !== v && e !== h && e !== T && e !== S && e !== C && e !== _ && e !== m && e !== y && e !== A && e !== k } function needIndentIndicator(e) { var t = /^\n* /; return t.test(e) } var I = 1, B = 2, N = 3, M = 4, H = 5; function chooseScalarStyle(e, t, r, n, i) { var s; var o, a; var u = false; var l = false; var d = n !== -1; var p = -1; var h = isPlainSafeFirst(e.charCodeAt(0)) && !isWhitespace(e.charCodeAt(e.length - 1)); if (t) { for (s = 0; s < e.length; s++) { o = e.charCodeAt(s); if (!isPrintable(o)) { return H } a = s > 0 ? e.charCodeAt(s - 1) : null; h = h && isPlainSafe(o, a) } } else { for (s = 0; s < e.length; s++) { o = e.charCodeAt(s); if (o === f) { u = true; if (d) { l = l || s - p - 1 > n && e[p + 1] !== " "; p = s } } else if (!isPrintable(o)) { return H } a = s > 0 ? e.charCodeAt(s - 1) : null; h = h && isPlainSafe(o, a) } l = l || d && (s - p - 1 > n && e[p + 1] !== " ") } if (!u && !l) { return h && !i(e) ? I : B } if (r > 9 && needIndentIndicator(e)) { return H } return l ? M : N } function writeScalar(e, t, r, n) { e.dump = function () { if (t.length === 0) { return "''" } if (!e.noCompatMode && L.indexOf(t) !== -1) { return "'" + t + "'" } var s = e.indent * Math.max(1, r); var o = e.lineWidth === -1 ? -1 : Math.max(Math.min(e.lineWidth, 40), e.lineWidth - s); var a = n || e.flowLevel > -1 && r >= e.flowLevel; function testAmbiguity(t) { return testImplicitResolving(e, t) } switch (chooseScalarStyle(t, a, e.indent, o, testAmbiguity)) { case I: return t; case B: return "'" + t.replace(/'/g, "''") + "'"; case N: return "|" + blockHeader(t, e.indent) + dropEndingNewline(indentString(t, s)); case M: return ">" + blockHeader(t, e.indent) + dropEndingNewline(indentString(foldString(t, o), s)); case H: return '"' + escapeString(t, o) + '"'; default: throw new i("impossible error: invalid scalar style") } }() } function blockHeader(e, t) { var r = needIndentIndicator(e) ? String(t) : ""; var n = e[e.length - 1] === "\n"; var i = n && (e[e.length - 2] === "\n" || e === "\n"); var s = i ? "+" : n ? "" : "-"; return r + s + "\n" } function dropEndingNewline(e) { return e[e.length - 1] === "\n" ? e.slice(0, -1) : e } function foldString(e, t) { var r = /(\n+)([^\n]*)/g; var n = function () { var n = e.indexOf("\n"); n = n !== -1 ? n : e.length; r.lastIndex = n; return foldLine(e.slice(0, n), t) }(); var i = e[0] === "\n" || e[0] === " "; var s; var o; while (o = r.exec(e)) { var a = o[1], u = o[2]; s = u[0] === " "; n += a + (!i && !s && u !== "" ? "\n" : "") + foldLine(u, t); i = s } return n } function foldLine(e, t) { if (e === "" || e[0] === " ") return e; var r = / [^ ]/g; var n; var i = 0, s, o = 0, a = 0; var u = ""; while (n = r.exec(e)) { a = n.index; if (a - i > t) { s = o > i ? o : a; u += "\n" + e.slice(i, s); i = s + 1 } o = a } u += "\n"; if (e.length - i > t && o > i) { u += e.slice(i, o) + "\n" + e.slice(o + 1) } else { u += e.slice(i) } return u.slice(1) } function escapeString(e) { var t = ""; var r, n; var i; for (var s = 0; s < e.length; s++) { r = e.charCodeAt(s); if (r >= 55296 && r <= 56319) { n = e.charCodeAt(s + 1); if (n >= 56320 && n <= 57343) { t += encodeHex((r - 55296) * 1024 + n - 56320 + 65536); s++; continue } } i = j[r]; t += !i && isPrintable(r) ? e[s] : i || encodeHex(r) } return t } function writeFlowSequence(e, t, r) { var n = "", i = e.tag, s, o; for (s = 0, o = r.length; s < o; s += 1) { if (writeNode(e, t, r[s], false, false)) { if (s !== 0) n += "," + (!e.condenseFlow ? " " : ""); n += e.dump } } e.tag = i; e.dump = "[" + n + "]" } function writeBlockSequence(e, t, r, n) { var i = "", s = e.tag, o, a; for (o = 0, a = r.length; o < a; o += 1) { if (writeNode(e, t + 1, r[o], true, true)) { if (!n || o !== 0) { i += generateNextLine(e, t) } if (e.dump && f === e.dump.charCodeAt(0)) { i += "-" } else { i += "- " } i += e.dump } } e.tag = s; e.dump = i || "[]" } function writeFlowMapping(e, t, r) { var n = "", i = e.tag, s = Object.keys(r), o, a, u, l, f; for (o = 0, a = s.length; o < a; o += 1) { f = ""; if (o !== 0) f += ", "; if (e.condenseFlow) f += '"'; u = s[o]; l = r[u]; if (!writeNode(e, t, u, false, false)) { continue } if (e.dump.length > 1024) f += "? "; f += e.dump + (e.condenseFlow ? '"' : "") + ":" + (e.condenseFlow ? "" : " "); if (!writeNode(e, t, l, false, false)) { continue } f += e.dump; n += f } e.tag = i; e.dump = "{" + n + "}" } function writeBlockMapping(e, t, r, n) { var s = "", o = e.tag, a = Object.keys(r), u, l, d, p, h, m; if (e.sortKeys === true) { a.sort() } else if (typeof e.sortKeys === "function") { a.sort(e.sortKeys) } else if (e.sortKeys) { throw new i("sortKeys must be a boolean or a function") } for (u = 0, l = a.length; u < l; u += 1) { m = ""; if (!n || u !== 0) { m += generateNextLine(e, t) } d = a[u]; p = r[d]; if (!writeNode(e, t + 1, d, true, true, true)) { continue } h = e.tag !== null && e.tag !== "?" || e.dump && e.dump.length > 1024; if (h) { if (e.dump && f === e.dump.charCodeAt(0)) { m += "?" } else { m += "? " } } m += e.dump; if (h) { m += generateNextLine(e, t) } if (!writeNode(e, t + 1, p, true, h)) { continue } if (e.dump && f === e.dump.charCodeAt(0)) { m += ":" } else { m += ": " } m += e.dump; s += m } e.tag = o; e.dump = s || "{}" } function detectType(e, t, r) { var n, s, o, l, f, d; s = r ? e.explicitTypes : e.implicitTypes; for (o = 0, l = s.length; o < l; o += 1) { f = s[o]; if ((f.instanceOf || f.predicate) && (!f.instanceOf || typeof t === "object" && t instanceof f.instanceOf) && (!f.predicate || f.predicate(t))) { e.tag = r ? f.tag : "?"; if (f.represent) { d = e.styleMap[f.tag] || f.defaultStyle; if (a.call(f.represent) === "[object Function]") { n = f.represent(t, d) } else if (u.call(f.represent, d)) { n = f.represent[d](t, d) } else { throw new i("!<" + f.tag + '> tag resolver accepts not "' + d + '" style') } e.dump = n } return true } } return false } function writeNode(e, t, r, n, s, o) { e.tag = null; e.dump = r; if (!detectType(e, r, false)) { detectType(e, r, true) } var u = a.call(e.dump); if (n) { n = e.flowLevel < 0 || e.flowLevel > t } var l = u === "[object Object]" || u === "[object Array]", f, d; if (l) { f = e.duplicates.indexOf(r); d = f !== -1 } if (e.tag !== null && e.tag !== "?" || d || e.indent !== 2 && t > 0) { s = false } if (d && e.usedDuplicates[f]) { e.dump = "*ref_" + f } else { if (l && d && !e.usedDuplicates[f]) { e.usedDuplicates[f] = true } if (u === "[object Object]") { if (n && Object.keys(e.dump).length !== 0) { writeBlockMapping(e, t, e.dump, s); if (d) { e.dump = "&ref_" + f + e.dump } } else { writeFlowMapping(e, t, e.dump); if (d) { e.dump = "&ref_" + f + " " + e.dump } } } else if (u === "[object Array]") { var p = e.noArrayIndent && t > 0 ? t - 1 : t; if (n && e.dump.length !== 0) { writeBlockSequence(e, p, e.dump, s); if (d) { e.dump = "&ref_" + f + e.dump } } else { writeFlowSequence(e, p, e.dump); if (d) { e.dump = "&ref_" + f + " " + e.dump } } } else if (u === "[object String]") { if (e.tag !== "?") { writeScalar(e, e.dump, t, o) } } else { if (e.skipInvalid) return false; throw new i("unacceptable kind of an object to dump " + u) } if (e.tag !== null && e.tag !== "?") { e.dump = "!<" + e.tag + "> " + e.dump } } return true } function getDuplicateReferences(e, t) { var r = [], n = [], i, s; inspectNode(e, r, n); for (i = 0, s = n.length; i < s; i += 1) { t.duplicates.push(r[n[i]]) } t.usedDuplicates = new Array(s) } function inspectNode(e, t, r) { var n, i, s; if (e !== null && typeof e === "object") { i = t.indexOf(e); if (i !== -1) { if (r.indexOf(i) === -1) { r.push(i) } } else { t.push(e); if (Array.isArray(e)) { for (i = 0, s = e.length; i < s; i += 1) { inspectNode(e[i], t, r) } } else { n = Object.keys(e); for (i = 0, s = n.length; i < s; i += 1) { inspectNode(e[n[i]], t, r) } } } } } function dump(e, t) { t = t || {}; var r = new State(t); if (!r.noRefs) getDuplicateReferences(e, r); if (writeNode(r, 0, e, true, true)) return r.dump + "\n"; return "" } function safeDump(e, t) { return dump(e, n.extend({ schema: o }, t)) } e.exports.dump = dump; e.exports.safeDump = safeDump }, 5199: e => { function YAMLException(e, t) { Error.call(this); this.name = "YAMLException"; this.reason = e; this.mark = t; this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : ""); if (Error.captureStackTrace) { Error.captureStackTrace(this, this.constructor) } else { this.stack = (new Error).stack || "" } } YAMLException.prototype = Object.create(Error.prototype); YAMLException.prototype.constructor = YAMLException; YAMLException.prototype.toString = function toString(e) { var t = this.name + ": "; t += this.reason || "(unknown reason)"; if (!e && this.mark) { t += " " + this.mark.toString() } return t }; e.exports = YAMLException }, 5190: (e, t, r) => { var n = r(9136); var i = r(5199); var s = r(5426); var o = r(8949); var a = r(6874); var u = Object.prototype.hasOwnProperty; var l = 1; var f = 2; var d = 3; var p = 4; var h = 1; var m = 2; var g = 3; var y = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/; var b = /[\x85\u2028\u2029]/; var _ = /[,\[\]\{\}]/; var v = /^(?:!|!!|![a-z\-]+!)$/i; var w = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i; function _class(e) { return Object.prototype.toString.call(e) } function is_EOL(e) { return e === 10 || e === 13 } function is_WHITE_SPACE(e) { return e === 9 || e === 32 } function is_WS_OR_EOL(e) { return e === 9 || e === 32 || e === 10 || e === 13 } function is_FLOW_INDICATOR(e) { return e === 44 || e === 91 || e === 93 || e === 123 || e === 125 } function fromHexCode(e) { var t; if (48 <= e && e <= 57) { return e - 48 } t = e | 32; if (97 <= t && t <= 102) { return t - 97 + 10 } return -1 } function escapedHexLen(e) { if (e === 120) { return 2 } if (e === 117) { return 4 } if (e === 85) { return 8 } return 0 } function fromDecimalCode(e) { if (48 <= e && e <= 57) { return e - 48 } return -1 } function simpleEscapeSequence(e) { return e === 48 ? "\0" : e === 97 ? "" : e === 98 ? "\b" : e === 116 ? "\t" : e === 9 ? "\t" : e === 110 ? "\n" : e === 118 ? "\v" : e === 102 ? "\f" : e === 114 ? "\r" : e === 101 ? "" : e === 32 ? " " : e === 34 ? '"' : e === 47 ? "/" : e === 92 ? "\\" : e === 78 ? "" : e === 95 ? " " : e === 76 ? "\u2028" : e === 80 ? "\u2029" : "" } function charFromCodepoint(e) { if (e <= 65535) { return String.fromCharCode(e) } return String.fromCharCode((e - 65536 >> 10) + 55296, (e - 65536 & 1023) + 56320) } var D = new Array(256); var E = new Array(256); for (var S = 0; S < 256; S++) { D[S] = simpleEscapeSequence(S) ? 1 : 0; E[S] = simpleEscapeSequence(S) } function State(e, t) { this.input = e; this.filename = t["filename"] || null; this.schema = t["schema"] || a; this.onWarning = t["onWarning"] || null; this.legacy = t["legacy"] || false; this.json = t["json"] || false; this.listener = t["listener"] || null; this.implicitTypes = this.schema.compiledImplicit; this.typeMap = this.schema.compiledTypeMap; this.length = e.length; this.position = 0; this.line = 0; this.lineStart = 0; this.lineIndent = 0; this.documents = [] } function generateError(e, t) { return new i(t, new s(e.filename, e.input, e.position, e.line, e.position - e.lineStart)) } function throwError(e, t) { throw generateError(e, t) } function throwWarning(e, t) { if (e.onWarning) { e.onWarning.call(null, generateError(e, t)) } } var C = { YAML: function handleYamlDirective(e, t, r) { var n, i, s; if (e.version !== null) { throwError(e, "duplication of %YAML directive") } if (r.length !== 1) { throwError(e, "YAML directive accepts exactly one argument") } n = /^([0-9]+)\.([0-9]+)$/.exec(r[0]); if (n === null) { throwError(e, "ill-formed argument of the YAML directive") } i = parseInt(n[1], 10); s = parseInt(n[2], 10); if (i !== 1) { throwError(e, "unacceptable YAML version of the document") } e.version = r[0]; e.checkLineBreaks = s < 2; if (s !== 1 && s !== 2) { throwWarning(e, "unsupported YAML version of the document") } }, TAG: function handleTagDirective(e, t, r) { var n, i; if (r.length !== 2) { throwError(e, "TAG directive accepts exactly two arguments") } n = r[0]; i = r[1]; if (!v.test(n)) { throwError(e, "ill-formed tag handle (first argument) of the TAG directive") } if (u.call(e.tagMap, n)) { throwError(e, 'there is a previously declared suffix for "' + n + '" tag handle') } if (!w.test(i)) { throwError(e, "ill-formed tag prefix (second argument) of the TAG directive") } e.tagMap[n] = i } }; function captureSegment(e, t, r, n) { var i, s, o, a; if (t < r) { a = e.input.slice(t, r); if (n) { for (i = 0, s = a.length; i < s; i += 1) { o = a.charCodeAt(i); if (!(o === 9 || 32 <= o && o <= 1114111)) { throwError(e, "expected valid JSON character") } } } else if (y.test(a)) { throwError(e, "the stream contains non-printable characters") } e.result += a } } function mergeMappings(e, t, r, i) { var s, o, a, l; if (!n.isObject(r)) { throwError(e, "cannot merge mappings; the provided source object is unacceptable") } s = Object.keys(r); for (a = 0, l = s.length; a < l; a += 1) { o = s[a]; if (!u.call(t, o)) { t[o] = r[o]; i[o] = true } } } function storeMappingPair(e, t, r, n, i, s, o, a) { var l, f; if (Array.isArray(i)) { i = Array.prototype.slice.call(i); for (l = 0, f = i.length; l < f; l += 1) { if (Array.isArray(i[l])) { throwError(e, "nested arrays are not supported inside keys") } if (typeof i === "object" && _class(i[l]) === "[object Object]") { i[l] = "[object Object]" } } } if (typeof i === "object" && _class(i) === "[object Object]") { i = "[object Object]" } i = String(i); if (t === null) { t = {} } if (n === "tag:yaml.org,2002:merge") { if (Array.isArray(s)) { for (l = 0, f = s.length; l < f; l += 1) { mergeMappings(e, t, s[l], r) } } else { mergeMappings(e, t, s, r) } } else { if (!e.json && !u.call(r, i) && u.call(t, i)) { e.line = o || e.line; e.position = a || e.position; throwError(e, "duplicated mapping key") } t[i] = s; delete r[i] } return t } function readLineBreak(e) { var t; t = e.input.charCodeAt(e.position); if (t === 10) { e.position++ } else if (t === 13) { e.position++; if (e.input.charCodeAt(e.position) === 10) { e.position++ } } else { throwError(e, "a line break is expected") } e.line += 1; e.lineStart = e.position } function skipSeparationSpace(e, t, r) { var n = 0, i = e.input.charCodeAt(e.position); while (i !== 0) { while (is_WHITE_SPACE(i)) { i = e.input.charCodeAt(++e.position) } if (t && i === 35) { do { i = e.input.charCodeAt(++e.position) } while (i !== 10 && i !== 13 && i !== 0) } if (is_EOL(i)) { readLineBreak(e); i = e.input.charCodeAt(e.position); n++; e.lineIndent = 0; while (i === 32) { e.lineIndent++; i = e.input.charCodeAt(++e.position) } } else { break } } if (r !== -1 && n !== 0 && e.lineIndent < r) { throwWarning(e, "deficient indentation") } return n } function testDocumentSeparator(e) { var t = e.position, r; r = e.input.charCodeAt(t); if ((r === 45 || r === 46) && r === e.input.charCodeAt(t + 1) && r === e.input.charCodeAt(t + 2)) { t += 3; r = e.input.charCodeAt(t); if (r === 0 || is_WS_OR_EOL(r)) { return true } } return false } function writeFoldedLines(e, t) { if (t === 1) { e.result += " " } else if (t > 1) { e.result += n.repeat("\n", t - 1) } } function readPlainScalar(e, t, r) { var n, i, s, o, a, u, l, f, d = e.kind, p = e.result, h; h = e.input.charCodeAt(e.position); if (is_WS_OR_EOL(h) || is_FLOW_INDICATOR(h) || h === 35 || h === 38 || h === 42 || h === 33 || h === 124 || h === 62 || h === 39 || h === 34 || h === 37 || h === 64 || h === 96) { return false } if (h === 63 || h === 45) { i = e.input.charCodeAt(e.position + 1); if (is_WS_OR_EOL(i) || r && is_FLOW_INDICATOR(i)) { return false } } e.kind = "scalar"; e.result = ""; s = o = e.position; a = false; while (h !== 0) { if (h === 58) { i = e.input.charCodeAt(e.position + 1); if (is_WS_OR_EOL(i) || r && is_FLOW_INDICATOR(i)) { break } } else if (h === 35) { n = e.input.charCodeAt(e.position - 1); if (is_WS_OR_EOL(n)) { break } } else if (e.position === e.lineStart && testDocumentSeparator(e) || r && is_FLOW_INDICATOR(h)) { break } else if (is_EOL(h)) { u = e.line; l = e.lineStart; f = e.lineIndent; skipSeparationSpace(e, false, -1); if (e.lineIndent >= t) { a = true; h = e.input.charCodeAt(e.position); continue } else { e.position = o; e.line = u; e.lineStart = l; e.lineIndent = f; break } } if (a) { captureSegment(e, s, o, false); writeFoldedLines(e, e.line - u); s = o = e.position; a = false } if (!is_WHITE_SPACE(h)) { o = e.position + 1 } h = e.input.charCodeAt(++e.position) } captureSegment(e, s, o, false); if (e.result) { return true } e.kind = d; e.result = p; return false } function readSingleQuotedScalar(e, t) { var r, n, i; r = e.input.charCodeAt(e.position); if (r !== 39) { return false } e.kind = "scalar"; e.result = ""; e.position++; n = i = e.position; while ((r = e.input.charCodeAt(e.position)) !== 0) { if (r === 39) { captureSegment(e, n, e.position, true); r = e.input.charCodeAt(++e.position); if (r === 39) { n = e.position; e.position++; i = e.position } else { return true } } else if (is_EOL(r)) { captureSegment(e, n, i, true); writeFoldedLines(e, skipSeparationSpace(e, false, t)); n = i = e.position } else if (e.position === e.lineStart && testDocumentSeparator(e)) { throwError(e, "unexpected end of the document within a single quoted scalar") } else { e.position++; i = e.position } } throwError(e, "unexpected end of the stream within a single quoted scalar") } function readDoubleQuotedScalar(e, t) { var r, n, i, s, o, a; a = e.input.charCodeAt(e.position); if (a !== 34) { return false } e.kind = "scalar"; e.result = ""; e.position++; r = n = e.position; while ((a = e.input.charCodeAt(e.position)) !== 0) { if (a === 34) { captureSegment(e, r, e.position, true); e.position++; return true } else if (a === 92) { captureSegment(e, r, e.position, true); a = e.input.charCodeAt(++e.position); if (is_EOL(a)) { skipSeparationSpace(e, false, t) } else if (a < 256 && D[a]) { e.result += E[a]; e.position++ } else if ((o = escapedHexLen(a)) > 0) { i = o; s = 0; for (; i > 0; i--) { a = e.input.charCodeAt(++e.position); if ((o = fromHexCode(a)) >= 0) { s = (s << 4) + o } else { throwError(e, "expected hexadecimal character") } } e.result += charFromCodepoint(s); e.position++ } else { throwError(e, "unknown escape sequence") } r = n = e.position } else if (is_EOL(a)) { captureSegment(e, r, n, true); writeFoldedLines(e, skipSeparationSpace(e, false, t)); r = n = e.position } else if (e.position === e.lineStart && testDocumentSeparator(e)) { throwError(e, "unexpected end of the document within a double quoted scalar") } else { e.position++; n = e.position } } throwError(e, "unexpected end of the stream within a double quoted scalar") } function readFlowCollection(e, t) { var r = true, n, i = e.tag, s, o = e.anchor, a, u, f, d, p, h = {}, m, g, y, b; b = e.input.charCodeAt(e.position); if (b === 91) { u = 93; p = false; s = [] } else if (b === 123) { u = 125; p = true; s = {} } else { return false } if (e.anchor !== null) { e.anchorMap[e.anchor] = s } b = e.input.charCodeAt(++e.position); while (b !== 0) { skipSeparationSpace(e, true, t); b = e.input.charCodeAt(e.position); if (b === u) { e.position++; e.tag = i; e.anchor = o; e.kind = p ? "mapping" : "sequence"; e.result = s; return true } else if (!r) { throwError(e, "missed comma between flow collection entries") } g = m = y = null; f = d = false; if (b === 63) { a = e.input.charCodeAt(e.position + 1); if (is_WS_OR_EOL(a)) { f = d = true; e.position++; skipSeparationSpace(e, true, t) } } n = e.line; composeNode(e, t, l, false, true); g = e.tag; m = e.result; skipSeparationSpace(e, true, t); b = e.input.charCodeAt(e.position); if ((d || e.line === n) && b === 58) { f = true; b = e.input.charCodeAt(++e.position); skipSeparationSpace(e, true, t); composeNode(e, t, l, false, true); y = e.result } if (p) { storeMappingPair(e, s, h, g, m, y) } else if (f) { s.push(storeMappingPair(e, null, h, g, m, y)) } else { s.push(m) } skipSeparationSpace(e, true, t); b = e.input.charCodeAt(e.position); if (b === 44) { r = true; b = e.input.charCodeAt(++e.position) } else { r = false } } throwError(e, "unexpected end of the stream within a flow collection") } function readBlockScalar(e, t) { var r, i, s = h, o = false, a = false, u = t, l = 0, f = false, d, p; p = e.input.charCodeAt(e.position); if (p === 124) { i = false } else if (p === 62) { i = true } else { return false } e.kind = "scalar"; e.result = ""; while (p !== 0) { p = e.input.charCodeAt(++e.position); if (p === 43 || p === 45) { if (h === s) { s = p === 43 ? g : m } else { throwError(e, "repeat of a chomping mode identifier") } } else if ((d = fromDecimalCode(p)) >= 0) { if (d === 0) { throwError(e, "bad explicit indentation width of a block scalar; it cannot be less than one") } else if (!a) { u = t + d - 1; a = true } else { throwError(e, "repeat of an indentation width identifier") } } else { break } } if (is_WHITE_SPACE(p)) { do { p = e.input.charCodeAt(++e.position) } while (is_WHITE_SPACE(p)); if (p === 35) { do { p = e.input.charCodeAt(++e.position) } while (!is_EOL(p) && p !== 0) } } while (p !== 0) { readLineBreak(e); e.lineIndent = 0; p = e.input.charCodeAt(e.position); while ((!a || e.lineIndent < u) && p === 32) { e.lineIndent++; p = e.input.charCodeAt(++e.position) } if (!a && e.lineIndent > u) { u = e.lineIndent } if (is_EOL(p)) { l++; continue } if (e.lineIndent < u) { if (s === g) { e.result += n.repeat("\n", o ? 1 + l : l) } else if (s === h) { if (o) { e.result += "\n" } } break } if (i) { if (is_WHITE_SPACE(p)) { f = true; e.result += n.repeat("\n", o ? 1 + l : l) } else if (f) { f = false; e.result += n.repeat("\n", l + 1) } else if (l === 0) { if (o) { e.result += " " } } else { e.result += n.repeat("\n", l) } } else { e.result += n.repeat("\n", o ? 1 + l : l) } o = true; a = true; l = 0; r = e.position; while (!is_EOL(p) && p !== 0) { p = e.input.charCodeAt(++e.position) } captureSegment(e, r, e.position, false) } return true } function readBlockSequence(e, t) { var r, n = e.tag, i = e.anchor, s = [], o, a = false, u; if (e.anchor !== null) { e.anchorMap[e.anchor] = s } u = e.input.charCodeAt(e.position); while (u !== 0) { if (u !== 45) { break } o = e.input.charCodeAt(e.position + 1); if (!is_WS_OR_EOL(o)) { break } a = true; e.position++; if (skipSeparationSpace(e, true, -1)) { if (e.lineIndent <= t) { s.push(null); u = e.input.charCodeAt(e.position); continue } } r = e.line; composeNode(e, t, d, false, true); s.push(e.result); skipSeparationSpace(e, true, -1); u = e.input.charCodeAt(e.position); if ((e.line === r || e.lineIndent > t) && u !== 0) { throwError(e, "bad indentation of a sequence entry") } else if (e.lineIndent < t) { break } } if (a) { e.tag = n; e.anchor = i; e.kind = "sequence"; e.result = s; return true } return false } function readBlockMapping(e, t, r) { var n, i, s, o, a = e.tag, u = e.anchor, l = {}, d = {}, h = null, m = null, g = null, y = false, b = false, _; if (e.anchor !== null) { e.anchorMap[e.anchor] = l } _ = e.input.charCodeAt(e.position); while (_ !== 0) { n = e.input.charCodeAt(e.position + 1); s = e.line; o = e.position; if ((_ === 63 || _ === 58) && is_WS_OR_EOL(n)) { if (_ === 63) { if (y) { storeMappingPair(e, l, d, h, m, null); h = m = g = null } b = true; y = true; i = true } else if (y) { y = false; i = true } else { throwError(e, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line") } e.position += 1; _ = n } else if (composeNode(e, r, f, false, true)) { if (e.line === s) { _ = e.input.charCodeAt(e.position); while (is_WHITE_SPACE(_)) { _ = e.input.charCodeAt(++e.position) } if (_ === 58) { _ = e.input.charCodeAt(++e.position); if (!is_WS_OR_EOL(_)) { throwError(e, "a whitespace character is expected after the key-value separator within a block mapping") } if (y) { storeMappingPair(e, l, d, h, m, null); h = m = g = null } b = true; y = false; i = false; h = e.tag; m = e.result } else if (b) { throwError(e, "can not read an implicit mapping pair; a colon is missed") } else { e.tag = a; e.anchor = u; return true } } else if (b) { throwError(e, "can not read a block mapping entry; a multiline key may not be an implicit key") } else { e.tag = a; e.anchor = u; return true } } else { break } if (e.line === s || e.lineIndent > t) { if (composeNode(e, t, p, true, i)) { if (y) { m = e.result } else { g = e.result } } if (!y) { storeMappingPair(e, l, d, h, m, g, s, o); h = m = g = null } skipSeparationSpace(e, true, -1); _ = e.input.charCodeAt(e.position) } if (e.lineIndent > t && _ !== 0) { throwError(e, "bad indentation of a mapping entry") } else if (e.lineIndent < t) { break } } if (y) { storeMappingPair(e, l, d, h, m, null) } if (b) { e.tag = a; e.anchor = u; e.kind = "mapping"; e.result = l } return b } function readTagProperty(e) { var t, r = false, n = false, i, s, o; o = e.input.charCodeAt(e.position); if (o !== 33) return false; if (e.tag !== null) { throwError(e, "duplication of a tag property") } o = e.input.charCodeAt(++e.position); if (o === 60) { r = true; o = e.input.charCodeAt(++e.position) } else if (o === 33) { n = true; i = "!!"; o = e.input.charCodeAt(++e.position) } else { i = "!" } t = e.position; if (r) { do { o = e.input.charCodeAt(++e.position) } while (o !== 0 && o !== 62); if (e.position < e.length) { s = e.input.slice(t, e.position); o = e.input.charCodeAt(++e.position) } else { throwError(e, "unexpected end of the stream within a verbatim tag") } } else { while (o !== 0 && !is_WS_OR_EOL(o)) { if (o === 33) { if (!n) { i = e.input.slice(t - 1, e.position + 1); if (!v.test(i)) { throwError(e, "named tag handle cannot contain such characters") } n = true; t = e.position + 1 } else { throwError(e, "tag suffix cannot contain exclamation marks") } } o = e.input.charCodeAt(++e.position) } s = e.input.slice(t, e.position); if (_.test(s)) { throwError(e, "tag suffix cannot contain flow indicator characters") } } if (s && !w.test(s)) { throwError(e, "tag name cannot contain such characters: " + s) } if (r) { e.tag = s } else if (u.call(e.tagMap, i)) { e.tag = e.tagMap[i] + s } else if (i === "!") { e.tag = "!" + s } else if (i === "!!") { e.tag = "tag:yaml.org,2002:" + s } else { throwError(e, 'undeclared tag handle "' + i + '"') } return true } function readAnchorProperty(e) { var t, r; r = e.input.charCodeAt(e.position); if (r !== 38) return false; if (e.anchor !== null) { throwError(e, "duplication of an anchor property") } r = e.input.charCodeAt(++e.position); t = e.position; while (r !== 0 && !is_WS_OR_EOL(r) && !is_FLOW_INDICATOR(r)) { r = e.input.charCodeAt(++e.position) } if (e.position === t) { throwError(e, "name of an anchor node must contain at least one character") } e.anchor = e.input.slice(t, e.position); return true } function readAlias(e) { var t, r, n; n = e.input.charCodeAt(e.position); if (n !== 42) return false; n = e.input.charCodeAt(++e.position); t = e.position; while (n !== 0 && !is_WS_OR_EOL(n) && !is_FLOW_INDICATOR(n)) { n = e.input.charCodeAt(++e.position) } if (e.position === t) { throwError(e, "name of an alias node must contain at least one character") } r = e.input.slice(t, e.position); if (!u.call(e.anchorMap, r)) { throwError(e, 'unidentified alias "' + r + '"') } e.result = e.anchorMap[r]; skipSeparationSpace(e, true, -1); return true } function composeNode(e, t, r, n, i) { var s, o, a, h = 1, m = false, g = false, y, b, _, v, w; if (e.listener !== null) { e.listener("open", e) } e.tag = null; e.anchor = null; e.kind = null; e.result = null; s = o = a = p === r || d === r; if (n) { if (skipSeparationSpace(e, true, -1)) { m = true; if (e.lineIndent > t) { h = 1 } else if (e.lineIndent === t) { h = 0 } else if (e.lineIndent < t) { h = -1 } } } if (h === 1) { while (readTagProperty(e) || readAnchorProperty(e)) { if (skipSeparationSpace(e, true, -1)) { m = true; a = s; if (e.lineIndent > t) { h = 1 } else if (e.lineIndent === t) { h = 0 } else if (e.lineIndent < t) { h = -1 } } else { a = false } } } if (a) { a = m || i } if (h === 1 || p === r) { if (l === r || f === r) { v = t } else { v = t + 1 } w = e.position - e.lineStart; if (h === 1) { if (a && (readBlockSequence(e, w) || readBlockMapping(e, w, v)) || readFlowCollection(e, v)) { g = true } else { if (o && readBlockScalar(e, v) || readSingleQuotedScalar(e, v) || readDoubleQuotedScalar(e, v)) { g = true } else if (readAlias(e)) { g = true; if (e.tag !== null || e.anchor !== null) { throwError(e, "alias node should not have any properties") } } else if (readPlainScalar(e, v, l === r)) { g = true; if (e.tag === null) { e.tag = "?" } } if (e.anchor !== null) { e.anchorMap[e.anchor] = e.result } } } else if (h === 0) { g = a && readBlockSequence(e, w) } } if (e.tag !== null && e.tag !== "!") { if (e.tag === "?") { if (e.result !== null && e.kind !== "scalar") { throwError(e, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + e.kind + '"') } for (y = 0, b = e.implicitTypes.length; y < b; y += 1) { _ = e.implicitTypes[y]; if (_.resolve(e.result)) { e.result = _.construct(e.result); e.tag = _.tag; if (e.anchor !== null) { e.anchorMap[e.anchor] = e.result } break } } } else if (u.call(e.typeMap[e.kind || "fallback"], e.tag)) { _ = e.typeMap[e.kind || "fallback"][e.tag]; if (e.result !== null && _.kind !== e.kind) { throwError(e, "unacceptable node kind for !<" + e.tag + '> tag; it should be "' + _.kind + '", not "' + e.kind + '"') } if (!_.resolve(e.result)) { throwError(e, "cannot resolve a node with !<" + e.tag + "> explicit tag") } else { e.result = _.construct(e.result); if (e.anchor !== null) { e.anchorMap[e.anchor] = e.result } } } else { throwError(e, "unknown tag !<" + e.tag + ">") } } if (e.listener !== null) { e.listener("close", e) } return e.tag !== null || e.anchor !== null || g } function readDocument(e) { var t = e.position, r, n, i, s = false, o; e.version = null; e.checkLineBreaks = e.legacy; e.tagMap = {}; e.anchorMap = {}; while ((o = e.input.charCodeAt(e.position)) !== 0) { skipSeparationSpace(e, true, -1); o = e.input.charCodeAt(e.position); if (e.lineIndent > 0 || o !== 37) { break } s = true; o = e.input.charCodeAt(++e.position); r = e.position; while (o !== 0 && !is_WS_OR_EOL(o)) { o = e.input.charCodeAt(++e.position) } n = e.input.slice(r, e.position); i = []; if (n.length < 1) { throwError(e, "directive name must not be less than one character in length") } while (o !== 0) { while (is_WHITE_SPACE(o)) { o = e.input.charCodeAt(++e.position) } if (o === 35) { do { o = e.input.charCodeAt(++e.position) } while (o !== 0 && !is_EOL(o)); break } if (is_EOL(o)) break; r = e.position; while (o !== 0 && !is_WS_OR_EOL(o)) { o = e.input.charCodeAt(++e.position) } i.push(e.input.slice(r, e.position)) } if (o !== 0) readLineBreak(e); if (u.call(C, n)) { C[n](e, n, i) } else { throwWarning(e, 'unknown document directive "' + n + '"') } } skipSeparationSpace(e, true, -1); if (e.lineIndent === 0 && e.input.charCodeAt(e.position) === 45 && e.input.charCodeAt(e.position + 1) === 45 && e.input.charCodeAt(e.position + 2) === 45) { e.position += 3; skipSeparationSpace(e, true, -1) } else if (s) { throwError(e, "directives end mark is expected") } composeNode(e, e.lineIndent - 1, p, false, true); skipSeparationSpace(e, true, -1); if (e.checkLineBreaks && b.test(e.input.slice(t, e.position))) { throwWarning(e, "non-ASCII line breaks are interpreted as content") } e.documents.push(e.result); if (e.position === e.lineStart && testDocumentSeparator(e)) { if (e.input.charCodeAt(e.position) === 46) { e.position += 3; skipSeparationSpace(e, true, -1) } return } if (e.position < e.length - 1) { throwError(e, "end of the stream or a document separator is expected") } else { return } } function loadDocuments(e, t) { e = String(e); t = t || {}; if (e.length !== 0) { if (e.charCodeAt(e.length - 1) !== 10 && e.charCodeAt(e.length - 1) !== 13) { e += "\n" } if (e.charCodeAt(0) === 65279) { e = e.slice(1) } } var r = new State(e, t); var n = e.indexOf("\0"); if (n !== -1) { r.position = n; throwError(r, "null byte is not allowed in input") } r.input += "\0"; while (r.input.charCodeAt(r.position) === 32) { r.lineIndent += 1; r.position += 1 } while (r.position < r.length - 1) { readDocument(r) } return r.documents } function loadAll(e, t, r) { if (t !== null && typeof t === "object" && typeof r === "undefined") { r = t; t = null } var n = loadDocuments(e, r); if (typeof t !== "function") { return n } for (var i = 0, s = n.length; i < s; i += 1) { t(n[i]) } } function load(e, t) { var r = loadDocuments(e, t); if (r.length === 0) { return undefined } else if (r.length === 1) { return r[0] } throw new i("expected a single document in the stream, but found more") } function safeLoadAll(e, t, r) { if (typeof t === "object" && t !== null && typeof r === "undefined") { r = t; t = null } return loadAll(e, t, n.extend({ schema: o }, r)) } function safeLoad(e, t) { return load(e, n.extend({ schema: o }, t)) } e.exports.loadAll = loadAll; e.exports.load = load; e.exports.safeLoadAll = safeLoadAll; e.exports.safeLoad = safeLoad }, 5426: (e, t, r) => { var n = r(9136); function Mark(e, t, r, n, i) { this.name = e; this.buffer = t; this.position = r; this.line = n; this.column = i } Mark.prototype.getSnippet = function getSnippet(e, t) { var r, i, s, o, a; if (!this.buffer) return null; e = e || 4; t = t || 75; r = ""; i = this.position; while (i > 0 && "\0\r\n\u2028\u2029".indexOf(this.buffer.charAt(i - 1)) === -1) { i -= 1; if (this.position - i > t / 2 - 1) { r = " ... "; i += 5; break } } s = ""; o = this.position; while (o < this.buffer.length && "\0\r\n\u2028\u2029".indexOf(this.buffer.charAt(o)) === -1) { o += 1; if (o - this.position > t / 2 - 1) { s = " ... "; o -= 5; break } } a = this.buffer.slice(i, o); return n.repeat(" ", e) + r + a + s + "\n" + n.repeat(" ", e + this.position - i + r.length) + "^" }; Mark.prototype.toString = function toString(e) { var t, r = ""; if (this.name) { r += 'in "' + this.name + '" ' } r += "at line " + (this.line + 1) + ", column " + (this.column + 1); if (!e) { t = this.getSnippet(); if (t) { r += ":\n" + t } } return r }; e.exports = Mark }, 6514: (e, t, r) => { var n = r(9136); var i = r(5199); var s = r(967); function compileList(e, t, r) { var n = []; e.include.forEach((function (e) { r = compileList(e, t, r) })); e[t].forEach((function (e) { r.forEach((function (t, r) { if (t.tag === e.tag && t.kind === e.kind) { n.push(r) } })); r.push(e) })); return r.filter((function (e, t) { return n.indexOf(t) === -1 })) } function compileMap() { var e = { scalar: {}, sequence: {}, mapping: {}, fallback: {} }, t, r; function collectType(t) { e[t.kind][t.tag] = e["fallback"][t.tag] = t } for (t = 0, r = arguments.length; t < r; t += 1) { arguments[t].forEach(collectType) } return e } function Schema(e) { this.include = e.include || []; this.implicit = e.implicit || []; this.explicit = e.explicit || []; this.implicit.forEach((function (e) { if (e.loadKind && e.loadKind !== "scalar") { throw new i("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.") } })); this.compiledImplicit = compileList(this, "implicit", []); this.compiledExplicit = compileList(this, "explicit", []); this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit) } Schema.DEFAULT = null; Schema.create = function createSchema() { var e, t; switch (arguments.length) { case 1: e = Schema.DEFAULT; t = arguments[0]; break; case 2: e = arguments[0]; t = arguments[1]; break; default: throw new i("Wrong number of arguments for Schema.create function") }e = n.toArray(e); t = n.toArray(t); if (!e.every((function (e) { return e instanceof Schema }))) { throw new i("Specified list of super schemas (or a single Schema object) contains a non-Schema object.") } if (!t.every((function (e) { return e instanceof s }))) { throw new i("Specified list of YAML types (or a single Type object) contains a non-Type object.") } return new Schema({ include: e, explicit: t }) }; e.exports = Schema }, 2183: (e, t, r) => { var n = r(6514); e.exports = new n({ include: [r(1571)] }) }, 6874: (e, t, r) => { var n = r(6514); e.exports = n.DEFAULT = new n({ include: [r(8949)], explicit: [r(5914), r(9242), r(7278)] }) }, 8949: (e, t, r) => { var n = r(6514); e.exports = new n({ include: [r(2183)], implicit: [r(3714), r(1393)], explicit: [r(2551), r(6668), r(6039), r(9237)] }) }, 6037: (e, t, r) => { var n = r(6514); e.exports = new n({ explicit: [r(2672), r(5490), r(1173)] }) }, 1571: (e, t, r) => { var n = r(6514); e.exports = new n({ include: [r(6037)], implicit: [r(2671), r(4675), r(9963), r(5564)] }) }, 967: (e, t, r) => { var n = r(5199); var i = ["kind", "resolve", "construct", "instanceOf", "predicate", "represent", "defaultStyle", "styleAliases"]; var s = ["scalar", "sequence", "mapping"]; function compileStyleAliases(e) { var t = {}; if (e !== null) { Object.keys(e).forEach((function (r) { e[r].forEach((function (e) { t[String(e)] = r })) })) } return t } function Type(e, t) { t = t || {}; Object.keys(t).forEach((function (t) { if (i.indexOf(t) === -1) { throw new n('Unknown option "' + t + '" is met in definition of "' + e + '" YAML type.') } })); this.tag = e; this.kind = t["kind"] || null; this.resolve = t["resolve"] || function () { return true }; this.construct = t["construct"] || function (e) { return e }; this.instanceOf = t["instanceOf"] || null; this.predicate = t["predicate"] || null; this.represent = t["represent"] || null; this.defaultStyle = t["defaultStyle"] || null; this.styleAliases = compileStyleAliases(t["styleAliases"] || null); if (s.indexOf(this.kind) === -1) { throw new n('Unknown kind "' + this.kind + '" is specified for "' + e + '" YAML type.') } } e.exports = Type }, 2551: (e, t, r) => { var n; try { var i = require; n = i("buffer").Buffer } catch (e) { } var s = r(967); var o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r"; function resolveYamlBinary(e) { if (e === null) return false; var t, r, n = 0, i = e.length, s = o; for (r = 0; r < i; r++) { t = s.indexOf(e.charAt(r)); if (t > 64) continue; if (t < 0) return false; n += 6 } return n % 8 === 0 } function constructYamlBinary(e) { var t, r, i = e.replace(/[\r\n=]/g, ""), s = i.length, a = o, u = 0, l = []; for (t = 0; t < s; t++) { if (t % 4 === 0 && t) { l.push(u >> 16 & 255); l.push(u >> 8 & 255); l.push(u & 255) } u = u << 6 | a.indexOf(i.charAt(t)) } r = s % 4 * 6; if (r === 0) { l.push(u >> 16 & 255); l.push(u >> 8 & 255); l.push(u & 255) } else if (r === 18) { l.push(u >> 10 & 255); l.push(u >> 2 & 255) } else if (r === 12) { l.push(u >> 4 & 255) } if (n) { return n.from ? n.from(l) : new n(l) } return l } function representYamlBinary(e) { var t = "", r = 0, n, i, s = e.length, a = o; for (n = 0; n < s; n++) { if (n % 3 === 0 && n) { t += a[r >> 18 & 63]; t += a[r >> 12 & 63]; t += a[r >> 6 & 63]; t += a[r & 63] } r = (r << 8) + e[n] } i = s % 3; if (i === 0) { t += a[r >> 18 & 63]; t += a[r >> 12 & 63]; t += a[r >> 6 & 63]; t += a[r & 63] } else if (i === 2) { t += a[r >> 10 & 63]; t += a[r >> 4 & 63]; t += a[r << 2 & 63]; t += a[64] } else if (i === 1) { t += a[r >> 2 & 63]; t += a[r << 4 & 63]; t += a[64]; t += a[64] } return t } function isBinary(e) { return n && n.isBuffer(e) } e.exports = new s("tag:yaml.org,2002:binary", { kind: "scalar", resolve: resolveYamlBinary, construct: constructYamlBinary, predicate: isBinary, represent: representYamlBinary }) }, 4675: (e, t, r) => { var n = r(967); function resolveYamlBoolean(e) { if (e === null) return false; var t = e.length; return t === 4 && (e === "true" || e === "True" || e === "TRUE") || t === 5 && (e === "false" || e === "False" || e === "FALSE") } function constructYamlBoolean(e) { return e === "true" || e === "True" || e === "TRUE" } function isBoolean(e) { return Object.prototype.toString.call(e) === "[object Boolean]" } e.exports = new n("tag:yaml.org,2002:bool", { kind: "scalar", resolve: resolveYamlBoolean, construct: constructYamlBoolean, predicate: isBoolean, represent: { lowercase: function (e) { return e ? "true" : "false" }, uppercase: function (e) { return e ? "TRUE" : "FALSE" }, camelcase: function (e) { return e ? "True" : "False" } }, defaultStyle: "lowercase" }) }, 5564: (e, t, r) => { var n = r(9136); var i = r(967); var s = new RegExp("^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?" + "|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?" + "|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*" + "|[-+]?\\.(?:inf|Inf|INF)" + "|\\.(?:nan|NaN|NAN))$"); function resolveYamlFloat(e) { if (e === null) return false; if (!s.test(e) || e[e.length - 1] === "_") { return false } return true } function constructYamlFloat(e) { var t, r, n, i; t = e.replace(/_/g, "").toLowerCase(); r = t[0] === "-" ? -1 : 1; i = []; if ("+-".indexOf(t[0]) >= 0) { t = t.slice(1) } if (t === ".inf") { return r === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY } else if (t === ".nan") { return NaN } else if (t.indexOf(":") >= 0) { t.split(":").forEach((function (e) { i.unshift(parseFloat(e, 10)) })); t = 0; n = 1; i.forEach((function (e) { t += e * n; n *= 60 })); return r * t } return r * parseFloat(t, 10) } var o = /^[-+]?[0-9]+e/; function representYamlFloat(e, t) { var r; if (isNaN(e)) { switch (t) { case "lowercase": return ".nan"; case "uppercase": return ".NAN"; case "camelcase": return ".NaN" } } else if (Number.POSITIVE_INFINITY === e) { switch (t) { case "lowercase": return ".inf"; case "uppercase": return ".INF"; case "camelcase": return ".Inf" } } else if (Number.NEGATIVE_INFINITY === e) { switch (t) { case "lowercase": return "-.inf"; case "uppercase": return "-.INF"; case "camelcase": return "-.Inf" } } else if (n.isNegativeZero(e)) { return "-0.0" } r = e.toString(10); return o.test(r) ? r.replace("e", ".e") : r } function isFloat(e) { return Object.prototype.toString.call(e) === "[object Number]" && (e % 1 !== 0 || n.isNegativeZero(e)) } e.exports = new i("tag:yaml.org,2002:float", { kind: "scalar", resolve: resolveYamlFloat, construct: constructYamlFloat, predicate: isFloat, represent: representYamlFloat, defaultStyle: "lowercase" }) }, 9963: (e, t, r) => { var n = r(9136); var i = r(967); function isHexCode(e) { return 48 <= e && e <= 57 || 65 <= e && e <= 70 || 97 <= e && e <= 102 } function isOctCode(e) { return 48 <= e && e <= 55 } function isDecCode(e) { return 48 <= e && e <= 57 } function resolveYamlInteger(e) { if (e === null) return false; var t = e.length, r = 0, n = false, i; if (!t) return false; i = e[r]; if (i === "-" || i === "+") { i = e[++r] } if (i === "0") { if (r + 1 === t) return true; i = e[++r]; if (i === "b") { r++; for (; r < t; r++) { i = e[r]; if (i === "_") continue; if (i !== "0" && i !== "1") return false; n = true } return n && i !== "_" } if (i === "x") { r++; for (; r < t; r++) { i = e[r]; if (i === "_") continue; if (!isHexCode(e.charCodeAt(r))) return false; n = true } return n && i !== "_" } for (; r < t; r++) { i = e[r]; if (i === "_") continue; if (!isOctCode(e.charCodeAt(r))) return false; n = true } return n && i !== "_" } if (i === "_") return false; for (; r < t; r++) { i = e[r]; if (i === "_") continue; if (i === ":") break; if (!isDecCode(e.charCodeAt(r))) { return false } n = true } if (!n || i === "_") return false; if (i !== ":") return true; return /^(:[0-5]?[0-9])+$/.test(e.slice(r)) } function constructYamlInteger(e) { var t = e, r = 1, n, i, s = []; if (t.indexOf("_") !== -1) { t = t.replace(/_/g, "") } n = t[0]; if (n === "-" || n === "+") { if (n === "-") r = -1; t = t.slice(1); n = t[0] } if (t === "0") return 0; if (n === "0") { if (t[1] === "b") return r * parseInt(t.slice(2), 2); if (t[1] === "x") return r * parseInt(t, 16); return r * parseInt(t, 8) } if (t.indexOf(":") !== -1) { t.split(":").forEach((function (e) { s.unshift(parseInt(e, 10)) })); t = 0; i = 1; s.forEach((function (e) { t += e * i; i *= 60 })); return r * t } return r * parseInt(t, 10) } function isInteger(e) { return Object.prototype.toString.call(e) === "[object Number]" && (e % 1 === 0 && !n.isNegativeZero(e)) } e.exports = new i("tag:yaml.org,2002:int", { kind: "scalar", resolve: resolveYamlInteger, construct: constructYamlInteger, predicate: isInteger, represent: { binary: function (e) { return e >= 0 ? "0b" + e.toString(2) : "-0b" + e.toString(2).slice(1) }, octal: function (e) { return e >= 0 ? "0" + e.toString(8) : "-0" + e.toString(8).slice(1) }, decimal: function (e) { return e.toString(10) }, hexadecimal: function (e) { return e >= 0 ? "0x" + e.toString(16).toUpperCase() : "-0x" + e.toString(16).toUpperCase().slice(1) } }, defaultStyle: "decimal", styleAliases: { binary: [2, "bin"], octal: [8, "oct"], decimal: [10, "dec"], hexadecimal: [16, "hex"] } }) }, 7278: (e, t, r) => { var n; try { var i = require; n = i("esprima") } catch (e) { if (typeof window !== "undefined") n = window.esprima } var s = r(967); function resolveJavascriptFunction(e) { if (e === null) return false; try { var t = "(" + e + ")", r = n.parse(t, { range: true }); if (r.type !== "Program" || r.body.length !== 1 || r.body[0].type !== "ExpressionStatement" || r.body[0].expression.type !== "ArrowFunctionExpression" && r.body[0].expression.type !== "FunctionExpression") { return false } return true } catch (e) { return false } } function constructJavascriptFunction(e) { var t = "(" + e + ")", r = n.parse(t, { range: true }), i = [], s; if (r.type !== "Program" || r.body.length !== 1 || r.body[0].type !== "ExpressionStatement" || r.body[0].expression.type !== "ArrowFunctionExpression" && r.body[0].expression.type !== "FunctionExpression") { throw new Error("Failed to resolve function") } r.body[0].expression.params.forEach((function (e) { i.push(e.name) })); s = r.body[0].expression.body.range; if (r.body[0].expression.body.type === "BlockStatement") { return new Function(i, t.slice(s[0] + 1, s[1] - 1)) } return new Function(i, "return " + t.slice(s[0], s[1])) } function representJavascriptFunction(e) { return e.toString() } function isFunction(e) { return Object.prototype.toString.call(e) === "[object Function]" } e.exports = new s("tag:yaml.org,2002:js/function", { kind: "scalar", resolve: resolveJavascriptFunction, construct: constructJavascriptFunction, predicate: isFunction, represent: representJavascriptFunction }) }, 9242: (e, t, r) => { var n = r(967); function resolveJavascriptRegExp(e) { if (e === null) return false; if (e.length === 0) return false; var t = e, r = /\/([gim]*)$/.exec(e), n = ""; if (t[0] === "/") { if (r) n = r[1]; if (n.length > 3) return false; if (t[t.length - n.length - 1] !== "/") return false } return true } function constructJavascriptRegExp(e) { var t = e, r = /\/([gim]*)$/.exec(e), n = ""; if (t[0] === "/") { if (r) n = r[1]; t = t.slice(1, t.length - n.length - 1) } return new RegExp(t, n) } function representJavascriptRegExp(e) { var t = "/" + e.source + "/"; if (e.global) t += "g"; if (e.multiline) t += "m"; if (e.ignoreCase) t += "i"; return t } function isRegExp(e) { return Object.prototype.toString.call(e) === "[object RegExp]" } e.exports = new n("tag:yaml.org,2002:js/regexp", { kind: "scalar", resolve: resolveJavascriptRegExp, construct: constructJavascriptRegExp, predicate: isRegExp, represent: representJavascriptRegExp }) }, 5914: (e, t, r) => { var n = r(967); function resolveJavascriptUndefined() { return true } function constructJavascriptUndefined() { return undefined } function representJavascriptUndefined() { return "" } function isUndefined(e) { return typeof e === "undefined" } e.exports = new n("tag:yaml.org,2002:js/undefined", { kind: "scalar", resolve: resolveJavascriptUndefined, construct: constructJavascriptUndefined, predicate: isUndefined, represent: representJavascriptUndefined }) }, 1173: (e, t, r) => { var n = r(967); e.exports = new n("tag:yaml.org,2002:map", { kind: "mapping", construct: function (e) { return e !== null ? e : {} } }) }, 1393: (e, t, r) => { var n = r(967); function resolveYamlMerge(e) { return e === "<<" || e === null } e.exports = new n("tag:yaml.org,2002:merge", { kind: "scalar", resolve: resolveYamlMerge }) }, 2671: (e, t, r) => { var n = r(967); function resolveYamlNull(e) { if (e === null) return true; var t = e.length; return t === 1 && e === "~" || t === 4 && (e === "null" || e === "Null" || e === "NULL") } function constructYamlNull() { return null } function isNull(e) { return e === null } e.exports = new n("tag:yaml.org,2002:null", { kind: "scalar", resolve: resolveYamlNull, construct: constructYamlNull, predicate: isNull, represent: { canonical: function () { return "~" }, lowercase: function () { return "null" }, uppercase: function () { return "NULL" }, camelcase: function () { return "Null" } }, defaultStyle: "lowercase" }) }, 6668: (e, t, r) => { var n = r(967); var i = Object.prototype.hasOwnProperty; var s = Object.prototype.toString; function resolveYamlOmap(e) { if (e === null) return true; var t = [], r, n, o, a, u, l = e; for (r = 0, n = l.length; r < n; r += 1) { o = l[r]; u = false; if (s.call(o) !== "[object Object]") return false; for (a in o) { if (i.call(o, a)) { if (!u) u = true; else return false } } if (!u) return false; if (t.indexOf(a) === -1) t.push(a); else return false } return true } function constructYamlOmap(e) { return e !== null ? e : [] } e.exports = new n("tag:yaml.org,2002:omap", { kind: "sequence", resolve: resolveYamlOmap, construct: constructYamlOmap }) }, 6039: (e, t, r) => { var n = r(967); var i = Object.prototype.toString; function resolveYamlPairs(e) { if (e === null) return true; var t, r, n, s, o, a = e; o = new Array(a.length); for (t = 0, r = a.length; t < r; t += 1) { n = a[t]; if (i.call(n) !== "[object Object]") return false; s = Object.keys(n); if (s.length !== 1) return false; o[t] = [s[0], n[s[0]]] } return true } function constructYamlPairs(e) { if (e === null) return []; var t, r, n, i, s, o = e; s = new Array(o.length); for (t = 0, r = o.length; t < r; t += 1) { n = o[t]; i = Object.keys(n); s[t] = [i[0], n[i[0]]] } return s } e.exports = new n("tag:yaml.org,2002:pairs", { kind: "sequence", resolve: resolveYamlPairs, construct: constructYamlPairs }) }, 5490: (e, t, r) => { var n = r(967); e.exports = new n("tag:yaml.org,2002:seq", { kind: "sequence", construct: function (e) { return e !== null ? e : [] } }) }, 9237: (e, t, r) => { var n = r(967); var i = Object.prototype.hasOwnProperty; function resolveYamlSet(e) { if (e === null) return true; var t, r = e; for (t in r) { if (i.call(r, t)) { if (r[t] !== null) return false } } return true } function constructYamlSet(e) { return e !== null ? e : {} } e.exports = new n("tag:yaml.org,2002:set", { kind: "mapping", resolve: resolveYamlSet, construct: constructYamlSet }) }, 2672: (e, t, r) => { var n = r(967); e.exports = new n("tag:yaml.org,2002:str", { kind: "scalar", construct: function (e) { return e !== null ? e : "" } }) }, 3714: (e, t, r) => { var n = r(967); var i = new RegExp("^([0-9][0-9][0-9][0-9])" + "-([0-9][0-9])" + "-([0-9][0-9])$"); var s = new RegExp("^([0-9][0-9][0-9][0-9])" + "-([0-9][0-9]?)" + "-([0-9][0-9]?)" + "(?:[Tt]|[ \\t]+)" + "([0-9][0-9]?)" + ":([0-9][0-9])" + ":([0-9][0-9])" + "(?:\\.([0-9]*))?" + "(?:[ \\t]*(Z|([-+])([0-9][0-9]?)" + "(?::([0-9][0-9]))?))?$"); function resolveYamlTimestamp(e) { if (e === null) return false; if (i.exec(e) !== null) return true; if (s.exec(e) !== null) return true; return false } function constructYamlTimestamp(e) { var t, r, n, o, a, u, l, f = 0, d = null, p, h, m; t = i.exec(e); if (t === null) t = s.exec(e); if (t === null) throw new Error("Date resolve error"); r = +t[1]; n = +t[2] - 1; o = +t[3]; if (!t[4]) { return new Date(Date.UTC(r, n, o)) } a = +t[4]; u = +t[5]; l = +t[6]; if (t[7]) { f = t[7].slice(0, 3); while (f.length < 3) { f += "0" } f = +f } if (t[9]) { p = +t[10]; h = +(t[11] || 0); d = (p * 60 + h) * 6e4; if (t[9] === "-") d = -d } m = new Date(Date.UTC(r, n, o, a, u, l, f)); if (d) m.setTime(m.getTime() - d); return m } function representYamlTimestamp(e) { return e.toISOString() } e.exports = new n("tag:yaml.org,2002:timestamp", { kind: "scalar", resolve: resolveYamlTimestamp, construct: constructYamlTimestamp, instanceOf: Date, represent: representYamlTimestamp }) }, 2820: (e, t) => { t.stringify = function stringify(e) { if ("undefined" == typeof e) return e; if (e && Buffer.isBuffer(e)) return JSON.stringify(":base64:" + e.toString("base64")); if (e && e.toJSON) e = e.toJSON(); if (e && "object" === typeof e) { var t = ""; var r = Array.isArray(e); t = r ? "[" : "{"; var n = true; for (var i in e) { var s = "function" == typeof e[i] || !r && "undefined" === typeof e[i]; if (Object.hasOwnProperty.call(e, i) && !s) { if (!n) t += ","; n = false; if (r) { if (e[i] == undefined) t += "null"; else t += stringify(e[i]) } else if (e[i] !== void 0) { t += stringify(i) + ":" + stringify(e[i]) } } } t += r ? "]" : "}"; return t } else if ("string" === typeof e) { return JSON.stringify(/^:/.test(e) ? ":" + e : e) } else if ("undefined" === typeof e) { return "null" } else return JSON.stringify(e) }; t.parse = function (e) { return JSON.parse(e, (function (e, t) { if ("string" === typeof t) { if (/^:base64:/.test(t)) return Buffer.from(t.substring(8), "base64"); else return /^:/.test(t) ? t.substring(1) : t } return t })) } }, 6160: (e, t, r) => { let n; try { n = r(7758) } catch (e) { n = r(7147) } const i = r(9046); const { stringify: s, stripBom: o } = r(5902); async function _readFile(e, t = {}) { if (typeof t === "string") { t = { encoding: t } } const r = t.fs || n; const s = "throws" in t ? t.throws : true; let a = await i.fromCallback(r.readFile)(e, t); a = o(a); let u; try { u = JSON.parse(a, t ? t.reviver : null) } catch (t) { if (s) { t.message = `${e}: ${t.message}`; throw t } else { return null } } return u } const a = i.fromPromise(_readFile); function readFileSync(e, t = {}) { if (typeof t === "string") { t = { encoding: t } } const r = t.fs || n; const i = "throws" in t ? t.throws : true; try { let n = r.readFileSync(e, t); n = o(n); return JSON.parse(n, t.reviver) } catch (t) { if (i) { t.message = `${e}: ${t.message}`; throw t } else { return null } } } async function _writeFile(e, t, r = {}) { const o = r.fs || n; const a = s(t, r); await i.fromCallback(o.writeFile)(e, a, r) } const u = i.fromPromise(_writeFile); function writeFileSync(e, t, r = {}) { const i = r.fs || n; const o = s(t, r); return i.writeFileSync(e, o, r) } const l = { readFile: a, readFileSync: readFileSync, writeFile: u, writeFileSync: writeFileSync }; e.exports = l }, 5902: e => { function stringify(e, { EOL: t = "\n", finalEOL: r = true, replacer: n = null, spaces: i } = {}) { const s = r ? t : ""; const o = JSON.stringify(e, n, i); return o.replace(/\n/g, t) + s } function stripBom(e) { if (Buffer.isBuffer(e)) e = e.toString("utf8"); return e.replace(/^\uFEFF/, "") } e.exports = { stringify: stringify, stripBom: stripBom } }, 1531: (e, t, r) => { const n = r(2361); const i = r(2820); const loadStore = e => { const t = { redis: "@keyv/redis", rediss: "@keyv/redis", mongodb: "@keyv/mongo", mongo: "@keyv/mongo", sqlite: "@keyv/sqlite", postgresql: "@keyv/postgres", postgres: "@keyv/postgres", mysql: "@keyv/mysql", etcd: "@keyv/etcd", offline: "@keyv/offline", tiered: "@keyv/tiered" }; if (e.adapter || e.uri) { const r = e.adapter || /^[^:+]*/.exec(e.uri)[0]; return new (require(t[r]))(e) } return new Map }; const s = ["sqlite", "postgres", "mysql", "mongo", "redis", "tiered"]; class Keyv extends n { constructor(e, { emitErrors: t = true, ...r } = {}) { super(); this.opts = { namespace: "keyv", serialize: i.stringify, deserialize: i.parse, ...typeof e === "string" ? { uri: e } : e, ...r }; if (!this.opts.store) { const e = { ...this.opts }; this.opts.store = loadStore(e) } if (this.opts.compression) { const e = this.opts.compression; this.opts.serialize = e.serialize.bind(e); this.opts.deserialize = e.deserialize.bind(e) } if (typeof this.opts.store.on === "function" && t) { this.opts.store.on("error", (e => this.emit("error", e))) } this.opts.store.namespace = this.opts.namespace; const generateIterator = e => async function* () { for await (const [t, r] of typeof e === "function" ? e(this.opts.store.namespace) : e) { const e = this.opts.deserialize(r); if (this.opts.store.namespace && !t.includes(this.opts.store.namespace)) { continue } if (typeof e.expires === "number" && Date.now() > e.expires) { this.delete(t); continue } yield [this._getKeyUnprefix(t), e.value] } }; if (typeof this.opts.store[Symbol.iterator] === "function" && this.opts.store instanceof Map) { this.iterator = generateIterator(this.opts.store) } else if (typeof this.opts.store.iterator === "function" && this.opts.store.opts && this._checkIterableAdaptar()) { this.iterator = generateIterator(this.opts.store.iterator.bind(this.opts.store)) } } _checkIterableAdaptar() { return s.includes(this.opts.store.opts.dialect) || s.findIndex((e => this.opts.store.opts.url.includes(e))) >= 0 } _getKeyPrefix(e) { return `${this.opts.namespace}:${e}` } _getKeyPrefixArray(e) { return e.map((e => `${this.opts.namespace}:${e}`)) } _getKeyUnprefix(e) { return e.split(":").splice(1).join(":") } get(e, t) { const { store: r } = this.opts; const n = Array.isArray(e); const i = n ? this._getKeyPrefixArray(e) : this._getKeyPrefix(e); if (n && r.getMany === undefined) { const e = []; for (const n of i) { e.push(Promise.resolve().then((() => r.get(n))).then((e => typeof e === "string" ? this.opts.deserialize(e) : this.opts.compression ? this.opts.deserialize(e) : e)).then((e => { if (e === undefined || e === null) { return undefined } if (typeof e.expires === "number" && Date.now() > e.expires) { return this.delete(n).then((() => undefined)) } return t && t.raw ? e : e.value }))) } return Promise.allSettled(e).then((e => { const t = []; for (const r of e) { t.push(r.value) } return t })) } return Promise.resolve().then((() => n ? r.getMany(i) : r.get(i))).then((e => typeof e === "string" ? this.opts.deserialize(e) : this.opts.compression ? this.opts.deserialize(e) : e)).then((r => { if (r === undefined || r === null) { return undefined } if (n) { const n = []; for (let i of r) { if (typeof i === "string") { i = this.opts.deserialize(i) } if (i === undefined || i === null) { n.push(undefined); continue } if (typeof i.expires === "number" && Date.now() > i.expires) { this.delete(e).then((() => undefined)); n.push(undefined) } else { n.push(t && t.raw ? i : i.value) } } return n } if (typeof r.expires === "number" && Date.now() > r.expires) { return this.delete(e).then((() => undefined)) } return t && t.raw ? r : r.value })) } set(e, t, r) { const n = this._getKeyPrefix(e); if (typeof r === "undefined") { r = this.opts.ttl } if (r === 0) { r = undefined } const { store: i } = this.opts; return Promise.resolve().then((() => { const e = typeof r === "number" ? Date.now() + r : null; if (typeof t === "symbol") { this.emit("error", "symbol cannot be serialized") } t = { value: t, expires: e }; return this.opts.serialize(t) })).then((e => i.set(n, e, r))).then((() => true)) } delete(e) { const { store: t } = this.opts; if (Array.isArray(e)) { const r = this._getKeyPrefixArray(e); if (t.deleteMany === undefined) { const e = []; for (const n of r) { e.push(t.delete(n)) } return Promise.allSettled(e).then((e => e.every((e => e.value === true)))) } return Promise.resolve().then((() => t.deleteMany(r))) } const r = this._getKeyPrefix(e); return Promise.resolve().then((() => t.delete(r))) } clear() { const { store: e } = this.opts; return Promise.resolve().then((() => e.clear())) } has(e) { const t = this._getKeyPrefix(e); const { store: r } = this.opts; return Promise.resolve().then((async () => { if (typeof r.has === "function") { return r.has(t) } const e = await r.get(t); return e !== undefined })) } disconnect() { const { store: e } = this.opts; if (typeof e.disconnect === "function") { return e.disconnect() } } } e.exports = Keyv }, 6961: e => { var t = Object.prototype.toString; e.exports = function kindOf(e) { if (e === void 0) return "undefined"; if (e === null) return "null"; var r = typeof e; if (r === "boolean") return "boolean"; if (r === "string") return "string"; if (r === "number") return "number"; if (r === "symbol") return "symbol"; if (r === "function") { return isGeneratorFn(e) ? "generatorfunction" : "function" } if (isArray(e)) return "array"; if (isBuffer(e)) return "buffer"; if (isArguments(e)) return "arguments"; if (isDate(e)) return "date"; if (isError(e)) return "error"; if (isRegexp(e)) return "regexp"; switch (ctorName(e)) { case "Symbol": return "symbol"; case "Promise": return "promise"; case "WeakMap": return "weakmap"; case "WeakSet": return "weakset"; case "Map": return "map"; case "Set": return "set"; case "Int8Array": return "int8array"; case "Uint8Array": return "uint8array"; case "Uint8ClampedArray": return "uint8clampedarray"; case "Int16Array": return "int16array"; case "Uint16Array": return "uint16array"; case "Int32Array": return "int32array"; case "Uint32Array": return "uint32array"; case "Float32Array": return "float32array"; case "Float64Array": return "float64array" }if (isGeneratorObj(e)) { return "generator" } r = t.call(e); switch (r) { case "[object Object]": return "object"; case "[object Map Iterator]": return "mapiterator"; case "[object Set Iterator]": return "setiterator"; case "[object String Iterator]": return "stringiterator"; case "[object Array Iterator]": return "arrayiterator" }return r.slice(8, -1).toLowerCase().replace(/\s/g, "") }; function ctorName(e) { return typeof e.constructor === "function" ? e.constructor.name : null } function isArray(e) { if (Array.isArray) return Array.isArray(e); return e instanceof Array } function isError(e) { return e instanceof Error || typeof e.message === "string" && e.constructor && typeof e.constructor.stackTraceLimit === "number" } function isDate(e) { if (e instanceof Date) return true; return typeof e.toDateString === "function" && typeof e.getDate === "function" && typeof e.setDate === "function" } function isRegexp(e) { if (e instanceof RegExp) return true; return typeof e.flags === "string" && typeof e.ignoreCase === "boolean" && typeof e.multiline === "boolean" && typeof e.global === "boolean" } function isGeneratorFn(e, t) { return ctorName(e) === "GeneratorFunction" } function isGeneratorObj(e) { return typeof e.throw === "function" && typeof e.return === "function" && typeof e.next === "function" } function isArguments(e) { try { if (typeof e.length === "number" && typeof e.callee === "function") { return true } } catch (e) { if (e.message.indexOf("callee") !== -1) { return true } } return false } function isBuffer(e) { if (e.constructor && typeof e.constructor.isBuffer === "function") { return e.constructor.isBuffer(e) } return false } }, 4436: (e, t, r) => { e = r.nmd(e); var n = 30, i = "..."; var s = 1 / 0, o = 17976931348623157e292, a = 0 / 0; var u = "[object RegExp]", l = "[object Symbol]"; var f = /^\s+|\s+$/g; var d = /\w*$/; var p = /^[-+]0x[0-9a-f]+$/i; var h = /^0b[01]+$/i; var m = /^0o[0-7]+$/i; var g = "\\ud800-\\udfff", y = "\\u0300-\\u036f\\ufe20-\\ufe23", b = "\\u20d0-\\u20f0", _ = "\\ufe0e\\ufe0f"; var v = "[" + g + "]", w = "[" + y + b + "]", D = "\\ud83c[\\udffb-\\udfff]", E = "(?:" + w + "|" + D + ")", S = "[^" + g + "]", C = "(?:\\ud83c[\\udde6-\\uddff]){2}", x = "[\\ud800-\\udbff][\\udc00-\\udfff]", A = "\\u200d"; var P = E + "?", R = "[" + _ + "]?", k = "(?:" + A + "(?:" + [S, C, x].join("|") + ")" + R + P + ")*", O = R + P + k, T = "(?:" + [S + w + "?", w, C, x, v].join("|") + ")"; var F = RegExp(D + "(?=" + D + ")|" + T + O, "g"); var j = RegExp("[" + A + g + y + b + _ + "]"); var L = parseInt; var I = typeof global == "object" && global && global.Object === Object && global; var B = typeof self == "object" && self && self.Object === Object && self; var N = I || B || Function("return this")(); var M = true && t && !t.nodeType && t; var H = M && "object" == "object" && e && !e.nodeType && e; var q = H && H.exports === M; var U = q && I.process; var W = function () { try { return U && U.binding("util") } catch (e) { } }(); var G = W && W.isRegExp; var z = baseProperty("length"); function asciiToArray(e) { return e.split("") } function baseProperty(e) { return function (t) { return t == null ? undefined : t[e] } } function baseUnary(e) { return function (t) { return e(t) } } function hasUnicode(e) { return j.test(e) } function stringSize(e) { return hasUnicode(e) ? unicodeSize(e) : z(e) } function stringToArray(e) { return hasUnicode(e) ? unicodeToArray(e) : asciiToArray(e) } function unicodeSize(e) { var t = F.lastIndex = 0; while (F.test(e)) { t++ } return t } function unicodeToArray(e) { return e.match(F) || [] } var V = Object.prototype; var K = V.toString; var J = N.Symbol; var Y = J ? J.prototype : undefined, Q = Y ? Y.toString : undefined; function baseIsRegExp(e) { return isObject(e) && K.call(e) == u } function baseSlice(e, t, r) { var n = -1, i = e.length; if (t < 0) { t = -t > i ? 0 : i + t } r = r > i ? i : r; if (r < 0) { r += i } i = t > r ? 0 : r - t >>> 0; t >>>= 0; var s = Array(i); while (++n < i) { s[n] = e[n + t] } return s } function baseToString(e) { if (typeof e == "string") { return e } if (isSymbol(e)) { return Q ? Q.call(e) : "" } var t = e + ""; return t == "0" && 1 / e == -s ? "-0" : t } function castSlice(e, t, r) { var n = e.length; r = r === undefined ? n : r; return !t && r >= n ? e : baseSlice(e, t, r) } function isObject(e) { var t = typeof e; return !!e && (t == "object" || t == "function") } function isObjectLike(e) { return !!e && typeof e == "object" } var X = G ? baseUnary(G) : baseIsRegExp; function isSymbol(e) { return typeof e == "symbol" || isObjectLike(e) && K.call(e) == l } function toFinite(e) { if (!e) { return e === 0 ? e : 0 } e = toNumber(e); if (e === s || e === -s) { var t = e < 0 ? -1 : 1; return t * o } return e === e ? e : 0 } function toInteger(e) { var t = toFinite(e), r = t % 1; return t === t ? r ? t - r : t : 0 } function toNumber(e) { if (typeof e == "number") { return e } if (isSymbol(e)) { return a } if (isObject(e)) { var t = typeof e.valueOf == "function" ? e.valueOf() : e; e = isObject(t) ? t + "" : t } if (typeof e != "string") { return e === 0 ? e : +e } e = e.replace(f, ""); var r = h.test(e); return r || m.test(e) ? L(e.slice(2), r ? 2 : 8) : p.test(e) ? a : +e } function toString(e) { return e == null ? "" : baseToString(e) } function truncate(e, t) { var r = n, s = i; if (isObject(t)) { var o = "separator" in t ? t.separator : o; r = "length" in t ? toInteger(t.length) : r; s = "omission" in t ? baseToString(t.omission) : s } e = toString(e); var a = e.length; if (hasUnicode(e)) { var u = stringToArray(e); a = u.length } if (r >= a) { return e } var l = r - stringSize(s); if (l < 1) { return s } var f = u ? castSlice(u, 0, l).join("") : e.slice(0, l); if (o === undefined) { return f + s } if (u) { l += f.length - l } if (X(o)) { if (e.slice(l).search(o)) { var p, h = f; if (!o.global) { o = RegExp(o.source, toString(d.exec(o)) + "g") } o.lastIndex = 0; while (p = o.exec(h)) { var m = p.index } f = f.slice(0, m === undefined ? l : m) } } else if (e.indexOf(baseToString(o), l) != l) { var g = f.lastIndexOf(o); if (g > -1) { f = f.slice(0, g) } } return f + s } e.exports = truncate }, 2621: (e, t, r) => { const { PassThrough: n } = r(2781); e.exports = function () { var e = []; var t = new n({ objectMode: true }); t.setMaxListeners(0); t.add = add; t.isEmpty = isEmpty; t.on("unpipe", remove); Array.prototype.slice.call(arguments).forEach(add); return t; function add(r) { if (Array.isArray(r)) { r.forEach(add); return this } e.push(r); r.once("end", remove.bind(null, r)); r.once("error", t.emit.bind(t, "error")); r.pipe(t, { end: false }); return this } function isEmpty() { return e.length == 0 } function remove(r) { e = e.filter((function (e) { return e !== r })); if (!e.length && t.readable) { t.end() } } } }, 2578: (e, t, r) => { const n = r(2781); const i = n.PassThrough; const s = Array.prototype.slice; e.exports = merge2; function merge2() { const e = []; const t = s.call(arguments); let r = false; let n = t[t.length - 1]; if (n && !Array.isArray(n) && n.pipe == null) { t.pop() } else { n = {} } const o = n.end !== false; const a = n.pipeError === true; if (n.objectMode == null) { n.objectMode = true } if (n.highWaterMark == null) { n.highWaterMark = 64 * 1024 } const u = i(n); function addStream() { for (let t = 0, r = arguments.length; t < r; t++) { e.push(pauseStreams(arguments[t], n)) } mergeStream(); return this } function mergeStream() { if (r) { return } r = true; let t = e.shift(); if (!t) { process.nextTick(endStream); return } if (!Array.isArray(t)) { t = [t] } let n = t.length + 1; function next() { if (--n > 0) { return } r = false; mergeStream() } function pipe(e) { function onend() { e.removeListener("merge2UnpipeEnd", onend); e.removeListener("end", onend); if (a) { e.removeListener("error", onerror) } next() } function onerror(e) { u.emit("error", e) } if (e._readableState.endEmitted) { return next() } e.on("merge2UnpipeEnd", onend); e.on("end", onend); if (a) { e.on("error", onerror) } e.pipe(u, { end: false }); e.resume() } for (let e = 0; e < t.length; e++) { pipe(t[e]) } next() } function endStream() { r = false; u.emit("queueDrain"); if (o) { u.end() } } u.setMaxListeners(0); u.add = addStream; u.on("unpipe", (function (e) { e.emit("merge2UnpipeEnd") })); if (t.length) { addStream.apply(null, t) } return u } function pauseStreams(e, t) { if (!Array.isArray(e)) { if (!e._readableState && e.pipe) { e = e.pipe(i(t)) } if (!e._readableState || !e.pause || !e.pipe) { throw new Error("Only readable stream can be merged.") } e.pause() } else { for (let r = 0, n = e.length; r < n; r++) { e[r] = pauseStreams(e[r], t) } } return e } }, 6228: (e, t, r) => { const n = r(3837); const i = r(610); const s = r(8569); const o = r(479); const isEmptyString = e => e === "" || e === "./"; const micromatch = (e, t, r) => { t = [].concat(t); e = [].concat(e); let n = new Set; let i = new Set; let o = new Set; let a = 0; let onResult = e => { o.add(e.output); if (r && r.onResult) { r.onResult(e) } }; for (let o = 0; o < t.length; o++) { let u = s(String(t[o]), { ...r, onResult: onResult }, true); let l = u.state.negated || u.state.negatedExtglob; if (l) a++; for (let t of e) { let e = u(t, true); let r = l ? !e.isMatch : e.isMatch; if (!r) continue; if (l) { n.add(e.output) } else { n.delete(e.output); i.add(e.output) } } } let u = a === t.length ? [...o] : [...i]; let l = u.filter((e => !n.has(e))); if (r && l.length === 0) { if (r.failglob === true) { throw new Error(`No matches found for "${t.join(", ")}"`) } if (r.nonull === true || r.nullglob === true) { return r.unescape ? t.map((e => e.replace(/\\/g, ""))) : t } } return l }; micromatch.match = micromatch; micromatch.matcher = (e, t) => s(e, t); micromatch.isMatch = (e, t, r) => s(t, r)(e); micromatch.any = micromatch.isMatch; micromatch.not = (e, t, r = {}) => { t = [].concat(t).map(String); let n = new Set; let i = []; let onResult = e => { if (r.onResult) r.onResult(e); i.push(e.output) }; let s = new Set(micromatch(e, t, { ...r, onResult: onResult })); for (let e of i) { if (!s.has(e)) { n.add(e) } } return [...n] }; micromatch.contains = (e, t, r) => { if (typeof e !== "string") { throw new TypeError(`Expected a string: "${n.inspect(e)}"`) } if (Array.isArray(t)) { return t.some((t => micromatch.contains(e, t, r))) } if (typeof t === "string") { if (isEmptyString(e) || isEmptyString(t)) { return false } if (e.includes(t) || e.startsWith("./") && e.slice(2).includes(t)) { return true } } return micromatch.isMatch(e, t, { ...r, contains: true }) }; micromatch.matchKeys = (e, t, r) => { if (!o.isObject(e)) { throw new TypeError("Expected the first argument to be an object") } let n = micromatch(Object.keys(e), t, r); let i = {}; for (let t of n) i[t] = e[t]; return i }; micromatch.some = (e, t, r) => { let n = [].concat(e); for (let e of [].concat(t)) { let t = s(String(e), r); if (n.some((e => t(e)))) { return true } } return false }; micromatch.every = (e, t, r) => { let n = [].concat(e); for (let e of [].concat(t)) { let t = s(String(e), r); if (!n.every((e => t(e)))) { return false } } return true }; micromatch.all = (e, t, r) => { if (typeof e !== "string") { throw new TypeError(`Expected a string: "${n.inspect(e)}"`) } return [].concat(t).every((t => s(t, r)(e))) }; micromatch.capture = (e, t, r) => { let n = o.isWindows(r); let i = s.makeRe(String(e), { ...r, capture: true }); let a = i.exec(n ? o.toPosixSlashes(t) : t); if (a) { return a.slice(1).map((e => e === void 0 ? "" : e)) } }; micromatch.makeRe = (...e) => s.makeRe(...e); micromatch.scan = (...e) => s.scan(...e); micromatch.parse = (e, t) => { let r = []; for (let n of [].concat(e || [])) { for (let e of i(String(n), t)) { r.push(s.parse(e, t)) } } return r }; micromatch.braces = (e, t) => { if (typeof e !== "string") throw new TypeError("Expected a string"); if (t && t.nobrace === true || !/\{.*\}/.test(e)) { return [e] } return i(e, t) }; micromatch.braceExpand = (e, t) => { if (typeof e !== "string") throw new TypeError("Expected a string"); return micromatch.braces(e, { ...t, expand: true }) }; e.exports = micromatch }, 5871: e => { function hasKey(e, t) { var r = e; t.slice(0, -1).forEach((function (e) { r = r[e] || {} })); var n = t[t.length - 1]; return n in r } function isNumber(e) { if (typeof e === "number") { return true } if (/^0x[0-9a-f]+$/i.test(e)) { return true } return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(e) } function isConstructorOrProto(e, t) { return t === "constructor" && typeof e[t] === "function" || t === "__proto__" } e.exports = function (e, t) { if (!t) { t = {} } var r = { bools: {}, strings: {}, unknownFn: null }; if (typeof t.unknown === "function") { r.unknownFn = t.unknown } if (typeof t.boolean === "boolean" && t.boolean) { r.allBools = true } else { [].concat(t.boolean).filter(Boolean).forEach((function (e) { r.bools[e] = true })) } var n = {}; function aliasIsBoolean(e) { return n[e].some((function (e) { return r.bools[e] })) } Object.keys(t.alias || {}).forEach((function (e) { n[e] = [].concat(t.alias[e]); n[e].forEach((function (t) { n[t] = [e].concat(n[e].filter((function (e) { return t !== e }))) })) }));[].concat(t.string).filter(Boolean).forEach((function (e) { r.strings[e] = true; if (n[e]) { [].concat(n[e]).forEach((function (e) { r.strings[e] = true })) } })); var i = t.default || {}; var s = { _: [] }; function argDefined(e, t) { return r.allBools && /^--[^=]+$/.test(t) || r.strings[e] || r.bools[e] || n[e] } function setKey(e, t, n) { var i = e; for (var s = 0; s < t.length - 1; s++) { var o = t[s]; if (isConstructorOrProto(i, o)) { return } if (i[o] === undefined) { i[o] = {} } if (i[o] === Object.prototype || i[o] === Number.prototype || i[o] === String.prototype) { i[o] = {} } if (i[o] === Array.prototype) { i[o] = [] } i = i[o] } var a = t[t.length - 1]; if (isConstructorOrProto(i, a)) { return } if (i === Object.prototype || i === Number.prototype || i === String.prototype) { i = {} } if (i === Array.prototype) { i = [] } if (i[a] === undefined || r.bools[a] || typeof i[a] === "boolean") { i[a] = n } else if (Array.isArray(i[a])) { i[a].push(n) } else { i[a] = [i[a], n] } } function setArg(e, t, i) { if (i && r.unknownFn && !argDefined(e, i)) { if (r.unknownFn(i) === false) { return } } var o = !r.strings[e] && isNumber(t) ? Number(t) : t; setKey(s, e.split("."), o); (n[e] || []).forEach((function (e) { setKey(s, e.split("."), o) })) } Object.keys(r.bools).forEach((function (e) { setArg(e, i[e] === undefined ? false : i[e]) })); var o = []; if (e.indexOf("--") !== -1) { o = e.slice(e.indexOf("--") + 1); e = e.slice(0, e.indexOf("--")) } for (var a = 0; a < e.length; a++) { var u = e[a]; var l; var f; if (/^--.+=/.test(u)) { var d = u.match(/^--([^=]+)=([\s\S]*)$/); l = d[1]; var p = d[2]; if (r.bools[l]) { p = p !== "false" } setArg(l, p, u) } else if (/^--no-.+/.test(u)) { l = u.match(/^--no-(.+)/)[1]; setArg(l, false, u) } else if (/^--.+/.test(u)) { l = u.match(/^--(.+)/)[1]; f = e[a + 1]; if (f !== undefined && !/^(-|--)[^-]/.test(f) && !r.bools[l] && !r.allBools && (n[l] ? !aliasIsBoolean(l) : true)) { setArg(l, f, u); a += 1 } else if (/^(true|false)$/.test(f)) { setArg(l, f === "true", u); a += 1 } else { setArg(l, r.strings[l] ? "" : true, u) } } else if (/^-[^-]+/.test(u)) { var h = u.slice(1, -1).split(""); var m = false; for (var g = 0; g < h.length; g++) { f = u.slice(g + 2); if (f === "-") { setArg(h[g], f, u); continue } if (/[A-Za-z]/.test(h[g]) && f[0] === "=") { setArg(h[g], f.slice(1), u); m = true; break } if (/[A-Za-z]/.test(h[g]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(f)) { setArg(h[g], f, u); m = true; break } if (h[g + 1] && h[g + 1].match(/\W/)) { setArg(h[g], u.slice(g + 2), u); m = true; break } else { setArg(h[g], r.strings[h[g]] ? "" : true, u) } } l = u.slice(-1)[0]; if (!m && l !== "-") { if (e[a + 1] && !/^(-|--)[^-]/.test(e[a + 1]) && !r.bools[l] && (n[l] ? !aliasIsBoolean(l) : true)) { setArg(l, e[a + 1], u); a += 1 } else if (e[a + 1] && /^(true|false)$/.test(e[a + 1])) { setArg(l, e[a + 1] === "true", u); a += 1 } else { setArg(l, r.strings[l] ? "" : true, u) } } } else { if (!r.unknownFn || r.unknownFn(u) !== false) { s._.push(r.strings._ || !isNumber(u) ? u : Number(u)) } if (t.stopEarly) { s._.push.apply(s._, e.slice(a + 1)); break } } } Object.keys(i).forEach((function (e) { if (!hasKey(s, e.split("."))) { setKey(s, e.split("."), i[e]); (n[e] || []).forEach((function (t) { setKey(s, t.split("."), i[e]) })) } })); if (t["--"]) { s["--"] = o.slice() } else { o.forEach((function (e) { s._.push(e) })) } return s } }, 900: e => { var t = 1e3; var r = t * 60; var n = r * 60; var i = n * 24; var s = i * 7; var o = i * 365.25; e.exports = function (e, t) { t = t || {}; var r = typeof e; if (r === "string" && e.length > 0) { return parse(e) } else if (r === "number" && isFinite(e)) { return t.long ? fmtLong(e) : fmtShort(e) } throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e)) }; function parse(e) { e = String(e); if (e.length > 100) { return } var a = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e); if (!a) { return } var u = parseFloat(a[1]); var l = (a[2] || "ms").toLowerCase(); switch (l) { case "years": case "year": case "yrs": case "yr": case "y": return u * o; case "weeks": case "week": case "w": return u * s; case "days": case "day": case "d": return u * i; case "hours": case "hour": case "hrs": case "hr": case "h": return u * n; case "minutes": case "minute": case "mins": case "min": case "m": return u * r; case "seconds": case "second": case "secs": case "sec": case "s": return u * t; case "milliseconds": case "millisecond": case "msecs": case "msec": case "ms": return u; default: return undefined } } function fmtShort(e) { var s = Math.abs(e); if (s >= i) { return Math.round(e / i) + "d" } if (s >= n) { return Math.round(e / n) + "h" } if (s >= r) { return Math.round(e / r) + "m" } if (s >= t) { return Math.round(e / t) + "s" } return e + "ms" } function fmtLong(e) { var s = Math.abs(e); if (s >= i) { return plural(e, s, i, "day") } if (s >= n) { return plural(e, s, n, "hour") } if (s >= r) { return plural(e, s, r, "minute") } if (s >= t) { return plural(e, s, t, "second") } return e + " ms" } function plural(e, t, r, n) { var i = t >= r * 1.5; return Math.round(e / r) + " " + n + (i ? "s" : "") } }, 539: e => { const pathKey = (e = {}) => { const t = e.env || process.env; const r = e.platform || process.platform; if (r !== "win32") { return "PATH" } return Object.keys(t).reverse().find((e => e.toUpperCase() === "PATH")) || "Path" }; e.exports = pathKey; e.exports["default"] = pathKey }, 3433: (e, t, r) => { const { promisify: n } = r(3837); const i = r(7147); async function isType(e, t, r) { if (typeof r !== "string") { throw new TypeError(`Expected a string, got ${typeof r}`) } try { const s = await n(i[e])(r); return s[t]() } catch (e) { if (e.code === "ENOENT") { return false } throw e } } function isTypeSync(e, t, r) { if (typeof r !== "string") { throw new TypeError(`Expected a string, got ${typeof r}`) } try { return i[e](r)[t]() } catch (e) { if (e.code === "ENOENT") { return false } throw e } } t.isFile = isType.bind(null, "stat", "isFile"); t.isDirectory = isType.bind(null, "stat", "isDirectory"); t.isSymlink = isType.bind(null, "lstat", "isSymbolicLink"); t.isFileSync = isTypeSync.bind(null, "statSync", "isFile"); t.isDirectorySync = isTypeSync.bind(null, "statSync", "isDirectory"); t.isSymlinkSync = isTypeSync.bind(null, "lstatSync", "isSymbolicLink") }, 8569: (e, t, r) => { e.exports = r(3322) }, 6099: (e, t, r) => { const n = r(1017); const i = "\\\\/"; const s = `[^${i}]`; const o = "\\."; const a = "\\+"; const u = "\\?"; const l = "\\/"; const f = "(?=.)"; const d = "[^/]"; const p = `(?:${l}|$)`; const h = `(?:^|${l})`; const m = `${o}{1,2}${p}`; const g = `(?!${o})`; const y = `(?!${h}${m})`; const b = `(?!${o}{0,1}${p})`; const _ = `(?!${m})`; const v = `[^.${l}]`; const w = `${d}*?`; const D = { DOT_LITERAL: o, PLUS_LITERAL: a, QMARK_LITERAL: u, SLASH_LITERAL: l, ONE_CHAR: f, QMARK: d, END_ANCHOR: p, DOTS_SLASH: m, NO_DOT: g, NO_DOTS: y, NO_DOT_SLASH: b, NO_DOTS_SLASH: _, QMARK_NO_DOT: v, STAR: w, START_ANCHOR: h }; const E = { ...D, SLASH_LITERAL: `[${i}]`, QMARK: s, STAR: `${s}*?`, DOTS_SLASH: `${o}{1,2}(?:[${i}]|$)`, NO_DOT: `(?!${o})`, NO_DOTS: `(?!(?:^|[${i}])${o}{1,2}(?:[${i}]|$))`, NO_DOT_SLASH: `(?!${o}{0,1}(?:[${i}]|$))`, NO_DOTS_SLASH: `(?!${o}{1,2}(?:[${i}]|$))`, QMARK_NO_DOT: `[^.${i}]`, START_ANCHOR: `(?:^|[${i}])`, END_ANCHOR: `(?:[${i}]|$)` }; const S = { alnum: "a-zA-Z0-9", alpha: "a-zA-Z", ascii: "\\x00-\\x7F", blank: " \\t", cntrl: "\\x00-\\x1F\\x7F", digit: "0-9", graph: "\\x21-\\x7E", lower: "a-z", print: "\\x20-\\x7E ", punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~", space: " \\t\\r\\n\\v\\f", upper: "A-Z", word: "A-Za-z0-9_", xdigit: "A-Fa-f0-9" }; e.exports = { MAX_LENGTH: 1024 * 64, POSIX_REGEX_SOURCE: S, REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g, REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/, REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/, REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g, REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g, REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g, REPLACEMENTS: { "***": "*", "**/**": "**", "**/**/**": "**" }, CHAR_0: 48, CHAR_9: 57, CHAR_UPPERCASE_A: 65, CHAR_LOWERCASE_A: 97, CHAR_UPPERCASE_Z: 90, CHAR_LOWERCASE_Z: 122, CHAR_LEFT_PARENTHESES: 40, CHAR_RIGHT_PARENTHESES: 41, CHAR_ASTERISK: 42, CHAR_AMPERSAND: 38, CHAR_AT: 64, CHAR_BACKWARD_SLASH: 92, CHAR_CARRIAGE_RETURN: 13, CHAR_CIRCUMFLEX_ACCENT: 94, CHAR_COLON: 58, CHAR_COMMA: 44, CHAR_DOT: 46, CHAR_DOUBLE_QUOTE: 34, CHAR_EQUAL: 61, CHAR_EXCLAMATION_MARK: 33, CHAR_FORM_FEED: 12, CHAR_FORWARD_SLASH: 47, CHAR_GRAVE_ACCENT: 96, CHAR_HASH: 35, CHAR_HYPHEN_MINUS: 45, CHAR_LEFT_ANGLE_BRACKET: 60, CHAR_LEFT_CURLY_BRACE: 123, CHAR_LEFT_SQUARE_BRACKET: 91, CHAR_LINE_FEED: 10, CHAR_NO_BREAK_SPACE: 160, CHAR_PERCENT: 37, CHAR_PLUS: 43, CHAR_QUESTION_MARK: 63, CHAR_RIGHT_ANGLE_BRACKET: 62, CHAR_RIGHT_CURLY_BRACE: 125, CHAR_RIGHT_SQUARE_BRACKET: 93, CHAR_SEMICOLON: 59, CHAR_SINGLE_QUOTE: 39, CHAR_SPACE: 32, CHAR_TAB: 9, CHAR_UNDERSCORE: 95, CHAR_VERTICAL_LINE: 124, CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, SEP: n.sep, extglobChars(e) { return { "!": { type: "negate", open: "(?:(?!(?:", close: `))${e.STAR})` }, "?": { type: "qmark", open: "(?:", close: ")?" }, "+": { type: "plus", open: "(?:", close: ")+" }, "*": { type: "star", open: "(?:", close: ")*" }, "@": { type: "at", open: "(?:", close: ")" } } }, globChars(e) { return e === true ? E : D } } }, 2139: (e, t, r) => { const n = r(6099); const i = r(479); const { MAX_LENGTH: s, POSIX_REGEX_SOURCE: o, REGEX_NON_SPECIAL_CHARS: a, REGEX_SPECIAL_CHARS_BACKREF: u, REPLACEMENTS: l } = n; const expandRange = (e, t) => { if (typeof t.expandRange === "function") { return t.expandRange(...e, t) } e.sort(); const r = `[${e.join("-")}]`; try { new RegExp(r) } catch (t) { return e.map((e => i.escapeRegex(e))).join("..") } return r }; const syntaxError = (e, t) => `Missing ${e}: "${t}" - use "\\\\${t}" to match literal characters`; const parse = (e, t) => { if (typeof e !== "string") { throw new TypeError("Expected a string") } e = l[e] || e; const r = { ...t }; const f = typeof r.maxLength === "number" ? Math.min(s, r.maxLength) : s; let d = e.length; if (d > f) { throw new SyntaxError(`Input length: ${d}, exceeds maximum allowed length: ${f}`) } const p = { type: "bos", value: "", output: r.prepend || "" }; const h = [p]; const m = r.capture ? "" : "?:"; const g = i.isWindows(t); const y = n.globChars(g); const b = n.extglobChars(y); const { DOT_LITERAL: _, PLUS_LITERAL: v, SLASH_LITERAL: w, ONE_CHAR: D, DOTS_SLASH: E, NO_DOT: S, NO_DOT_SLASH: C, NO_DOTS_SLASH: x, QMARK: A, QMARK_NO_DOT: P, STAR: R, START_ANCHOR: k } = y; const globstar = e => `(${m}(?:(?!${k}${e.dot ? E : _}).)*?)`; const O = r.dot ? "" : S; const T = r.dot ? A : P; let F = r.bash === true ? globstar(r) : R; if (r.capture) { F = `(${F})` } if (typeof r.noext === "boolean") { r.noextglob = r.noext } const j = { input: e, index: -1, start: 0, dot: r.dot === true, consumed: "", output: "", prefix: "", backtrack: false, negated: false, brackets: 0, braces: 0, parens: 0, quotes: 0, globstar: false, tokens: h }; e = i.removePrefix(e, j); d = e.length; const L = []; const I = []; const B = []; let N = p; let M; const eos = () => j.index === d - 1; const H = j.peek = (t = 1) => e[j.index + t]; const q = j.advance = () => e[++j.index] || ""; const remaining = () => e.slice(j.index + 1); const consume = (e = "", t = 0) => { j.consumed += e; j.index += t }; const append = e => { j.output += e.output != null ? e.output : e.value; consume(e.value) }; const negate = () => { let e = 1; while (H() === "!" && (H(2) !== "(" || H(3) === "?")) { q(); j.start++; e++ } if (e % 2 === 0) { return false } j.negated = true; j.start++; return true }; const increment = e => { j[e]++; B.push(e) }; const decrement = e => { j[e]--; B.pop() }; const push = e => { if (N.type === "globstar") { const t = j.braces > 0 && (e.type === "comma" || e.type === "brace"); const r = e.extglob === true || L.length && (e.type === "pipe" || e.type === "paren"); if (e.type !== "slash" && e.type !== "paren" && !t && !r) { j.output = j.output.slice(0, -N.output.length); N.type = "star"; N.value = "*"; N.output = F; j.output += N.output } } if (L.length && e.type !== "paren") { L[L.length - 1].inner += e.value } if (e.value || e.output) append(e); if (N && N.type === "text" && e.type === "text") { N.value += e.value; N.output = (N.output || "") + e.value; return } e.prev = N; h.push(e); N = e }; const extglobOpen = (e, t) => { const n = { ...b[t], conditions: 1, inner: "" }; n.prev = N; n.parens = j.parens; n.output = j.output; const i = (r.capture ? "(" : "") + n.open; increment("parens"); push({ type: e, value: t, output: j.output ? "" : D }); push({ type: "paren", extglob: true, value: q(), output: i }); L.push(n) }; const extglobClose = e => { let n = e.close + (r.capture ? ")" : ""); let i; if (e.type === "negate") { let s = F; if (e.inner && e.inner.length > 1 && e.inner.includes("/")) { s = globstar(r) } if (s !== F || eos() || /^\)+$/.test(remaining())) { n = e.close = `)$))${s}` } if (e.inner.includes("*") && (i = remaining()) && /^\.[^\\/.]+$/.test(i)) { const r = parse(i, { ...t, fastpaths: false }).output; n = e.close = `)${r})${s})` } if (e.prev.type === "bos") { j.negatedExtglob = true } } push({ type: "paren", extglob: true, value: M, output: n }); decrement("parens") }; if (r.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(e)) { let n = false; let s = e.replace(u, ((e, t, r, i, s, o) => { if (i === "\\") { n = true; return e } if (i === "?") { if (t) { return t + i + (s ? A.repeat(s.length) : "") } if (o === 0) { return T + (s ? A.repeat(s.length) : "") } return A.repeat(r.length) } if (i === ".") { return _.repeat(r.length) } if (i === "*") { if (t) { return t + i + (s ? F : "") } return F } return t ? e : `\\${e}` })); if (n === true) { if (r.unescape === true) { s = s.replace(/\\/g, "") } else { s = s.replace(/\\+/g, (e => e.length % 2 === 0 ? "\\\\" : e ? "\\" : "")) } } if (s === e && r.contains === true) { j.output = e; return j } j.output = i.wrapOutput(s, j, t); return j } while (!eos()) { M = q(); if (M === "\0") { continue } if (M === "\\") { const e = H(); if (e === "/" && r.bash !== true) { continue } if (e === "." || e === ";") { continue } if (!e) { M += "\\"; push({ type: "text", value: M }); continue } const t = /^\\+/.exec(remaining()); let n = 0; if (t && t[0].length > 2) { n = t[0].length; j.index += n; if (n % 2 !== 0) { M += "\\" } } if (r.unescape === true) { M = q() } else { M += q() } if (j.brackets === 0) { push({ type: "text", value: M }); continue } } if (j.brackets > 0 && (M !== "]" || N.value === "[" || N.value === "[^")) { if (r.posix !== false && M === ":") { const e = N.value.slice(1); if (e.includes("[")) { N.posix = true; if (e.includes(":")) { const e = N.value.lastIndexOf("["); const t = N.value.slice(0, e); const r = N.value.slice(e + 2); const n = o[r]; if (n) { N.value = t + n; j.backtrack = true; q(); if (!p.output && h.indexOf(N) === 1) { p.output = D } continue } } } } if (M === "[" && H() !== ":" || M === "-" && H() === "]") { M = `\\${M}` } if (M === "]" && (N.value === "[" || N.value === "[^")) { M = `\\${M}` } if (r.posix === true && M === "!" && N.value === "[") { M = "^" } N.value += M; append({ value: M }); continue } if (j.quotes === 1 && M !== '"') { M = i.escapeRegex(M); N.value += M; append({ value: M }); continue } if (M === '"') { j.quotes = j.quotes === 1 ? 0 : 1; if (r.keepQuotes === true) { push({ type: "text", value: M }) } continue } if (M === "(") { increment("parens"); push({ type: "paren", value: M }); continue } if (M === ")") { if (j.parens === 0 && r.strictBrackets === true) { throw new SyntaxError(syntaxError("opening", "(")) } const e = L[L.length - 1]; if (e && j.parens === e.parens + 1) { extglobClose(L.pop()); continue } push({ type: "paren", value: M, output: j.parens ? ")" : "\\)" }); decrement("parens"); continue } if (M === "[") { if (r.nobracket === true || !remaining().includes("]")) { if (r.nobracket !== true && r.strictBrackets === true) { throw new SyntaxError(syntaxError("closing", "]")) } M = `\\${M}` } else { increment("brackets") } push({ type: "bracket", value: M }); continue } if (M === "]") { if (r.nobracket === true || N && N.type === "bracket" && N.value.length === 1) { push({ type: "text", value: M, output: `\\${M}` }); continue } if (j.brackets === 0) { if (r.strictBrackets === true) { throw new SyntaxError(syntaxError("opening", "[")) } push({ type: "text", value: M, output: `\\${M}` }); continue } decrement("brackets"); const e = N.value.slice(1); if (N.posix !== true && e[0] === "^" && !e.includes("/")) { M = `/${M}` } N.value += M; append({ value: M }); if (r.literalBrackets === false || i.hasRegexChars(e)) { continue } const t = i.escapeRegex(N.value); j.output = j.output.slice(0, -N.value.length); if (r.literalBrackets === true) { j.output += t; N.value = t; continue } N.value = `(${m}${t}|${N.value})`; j.output += N.value; continue } if (M === "{" && r.nobrace !== true) { increment("braces"); const e = { type: "brace", value: M, output: "(", outputIndex: j.output.length, tokensIndex: j.tokens.length }; I.push(e); push(e); continue } if (M === "}") { const e = I[I.length - 1]; if (r.nobrace === true || !e) { push({ type: "text", value: M, output: M }); continue } let t = ")"; if (e.dots === true) { const e = h.slice(); const n = []; for (let t = e.length - 1; t >= 0; t--) { h.pop(); if (e[t].type === "brace") { break } if (e[t].type !== "dots") { n.unshift(e[t].value) } } t = expandRange(n, r); j.backtrack = true } if (e.comma !== true && e.dots !== true) { const r = j.output.slice(0, e.outputIndex); const n = j.tokens.slice(e.tokensIndex); e.value = e.output = "\\{"; M = t = "\\}"; j.output = r; for (const e of n) { j.output += e.output || e.value } } push({ type: "brace", value: M, output: t }); decrement("braces"); I.pop(); continue } if (M === "|") { if (L.length > 0) { L[L.length - 1].conditions++ } push({ type: "text", value: M }); continue } if (M === ",") { let e = M; const t = I[I.length - 1]; if (t && B[B.length - 1] === "braces") { t.comma = true; e = "|" } push({ type: "comma", value: M, output: e }); continue } if (M === "/") { if (N.type === "dot" && j.index === j.start + 1) { j.start = j.index + 1; j.consumed = ""; j.output = ""; h.pop(); N = p; continue } push({ type: "slash", value: M, output: w }); continue } if (M === ".") { if (j.braces > 0 && N.type === "dot") { if (N.value === ".") N.output = _; const e = I[I.length - 1]; N.type = "dots"; N.output += M; N.value += M; e.dots = true; continue } if (j.braces + j.parens === 0 && N.type !== "bos" && N.type !== "slash") { push({ type: "text", value: M, output: _ }); continue } push({ type: "dot", value: M, output: _ }); continue } if (M === "?") { const e = N && N.value === "("; if (!e && r.noextglob !== true && H() === "(" && H(2) !== "?") { extglobOpen("qmark", M); continue } if (N && N.type === "paren") { const e = H(); let t = M; if (e === "<" && !i.supportsLookbehinds()) { throw new Error("Node.js v10 or higher is required for regex lookbehinds") } if (N.value === "(" && !/[!=<:]/.test(e) || e === "<" && !/<([!=]|\w+>)/.test(remaining())) { t = `\\${M}` } push({ type: "text", value: M, output: t }); continue } if (r.dot !== true && (N.type === "slash" || N.type === "bos")) { push({ type: "qmark", value: M, output: P }); continue } push({ type: "qmark", value: M, output: A }); continue } if (M === "!") { if (r.noextglob !== true && H() === "(") { if (H(2) !== "?" || !/[!=<:]/.test(H(3))) { extglobOpen("negate", M); continue } } if (r.nonegate !== true && j.index === 0) { negate(); continue } } if (M === "+") { if (r.noextglob !== true && H() === "(" && H(2) !== "?") { extglobOpen("plus", M); continue } if (N && N.value === "(" || r.regex === false) { push({ type: "plus", value: M, output: v }); continue } if (N && (N.type === "bracket" || N.type === "paren" || N.type === "brace") || j.parens > 0) { push({ type: "plus", value: M }); continue } push({ type: "plus", value: v }); continue } if (M === "@") { if (r.noextglob !== true && H() === "(" && H(2) !== "?") { push({ type: "at", extglob: true, value: M, output: "" }); continue } push({ type: "text", value: M }); continue } if (M !== "*") { if (M === "$" || M === "^") { M = `\\${M}` } const e = a.exec(remaining()); if (e) { M += e[0]; j.index += e[0].length } push({ type: "text", value: M }); continue } if (N && (N.type === "globstar" || N.star === true)) { N.type = "star"; N.star = true; N.value += M; N.output = F; j.backtrack = true; j.globstar = true; consume(M); continue } let t = remaining(); if (r.noextglob !== true && /^\([^?]/.test(t)) { extglobOpen("star", M); continue } if (N.type === "star") { if (r.noglobstar === true) { consume(M); continue } const n = N.prev; const i = n.prev; const s = n.type === "slash" || n.type === "bos"; const o = i && (i.type === "star" || i.type === "globstar"); if (r.bash === true && (!s || t[0] && t[0] !== "/")) { push({ type: "star", value: M, output: "" }); continue } const a = j.braces > 0 && (n.type === "comma" || n.type === "brace"); const u = L.length && (n.type === "pipe" || n.type === "paren"); if (!s && n.type !== "paren" && !a && !u) { push({ type: "star", value: M, output: "" }); continue } while (t.slice(0, 3) === "/**") { const r = e[j.index + 4]; if (r && r !== "/") { break } t = t.slice(3); consume("/**", 3) } if (n.type === "bos" && eos()) { N.type = "globstar"; N.value += M; N.output = globstar(r); j.output = N.output; j.globstar = true; consume(M); continue } if (n.type === "slash" && n.prev.type !== "bos" && !o && eos()) { j.output = j.output.slice(0, -(n.output + N.output).length); n.output = `(?:${n.output}`; N.type = "globstar"; N.output = globstar(r) + (r.strictSlashes ? ")" : "|$)"); N.value += M; j.globstar = true; j.output += n.output + N.output; consume(M); continue } if (n.type === "slash" && n.prev.type !== "bos" && t[0] === "/") { const e = t[1] !== void 0 ? "|$" : ""; j.output = j.output.slice(0, -(n.output + N.output).length); n.output = `(?:${n.output}`; N.type = "globstar"; N.output = `${globstar(r)}${w}|${w}${e})`; N.value += M; j.output += n.output + N.output; j.globstar = true; consume(M + q()); push({ type: "slash", value: "/", output: "" }); continue } if (n.type === "bos" && t[0] === "/") { N.type = "globstar"; N.value += M; N.output = `(?:^|${w}|${globstar(r)}${w})`; j.output = N.output; j.globstar = true; consume(M + q()); push({ type: "slash", value: "/", output: "" }); continue } j.output = j.output.slice(0, -N.output.length); N.type = "globstar"; N.output = globstar(r); N.value += M; j.output += N.output; j.globstar = true; consume(M); continue } const n = { type: "star", value: M, output: F }; if (r.bash === true) { n.output = ".*?"; if (N.type === "bos" || N.type === "slash") { n.output = O + n.output } push(n); continue } if (N && (N.type === "bracket" || N.type === "paren") && r.regex === true) { n.output = M; push(n); continue } if (j.index === j.start || N.type === "slash" || N.type === "dot") { if (N.type === "dot") { j.output += C; N.output += C } else if (r.dot === true) { j.output += x; N.output += x } else { j.output += O; N.output += O } if (H() !== "*") { j.output += D; N.output += D } } push(n) } while (j.brackets > 0) { if (r.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "]")); j.output = i.escapeLast(j.output, "["); decrement("brackets") } while (j.parens > 0) { if (r.strictBrackets === true) throw new SyntaxError(syntaxError("closing", ")")); j.output = i.escapeLast(j.output, "("); decrement("parens") } while (j.braces > 0) { if (r.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "}")); j.output = i.escapeLast(j.output, "{"); decrement("braces") } if (r.strictSlashes !== true && (N.type === "star" || N.type === "bracket")) { push({ type: "maybe_slash", value: "", output: `${w}?` }) } if (j.backtrack === true) { j.output = ""; for (const e of j.tokens) { j.output += e.output != null ? e.output : e.value; if (e.suffix) { j.output += e.suffix } } } return j }; parse.fastpaths = (e, t) => { const r = { ...t }; const o = typeof r.maxLength === "number" ? Math.min(s, r.maxLength) : s; const a = e.length; if (a > o) { throw new SyntaxError(`Input length: ${a}, exceeds maximum allowed length: ${o}`) } e = l[e] || e; const u = i.isWindows(t); const { DOT_LITERAL: f, SLASH_LITERAL: d, ONE_CHAR: p, DOTS_SLASH: h, NO_DOT: m, NO_DOTS: g, NO_DOTS_SLASH: y, STAR: b, START_ANCHOR: _ } = n.globChars(u); const v = r.dot ? g : m; const w = r.dot ? y : m; const D = r.capture ? "" : "?:"; const E = { negated: false, prefix: "" }; let S = r.bash === true ? ".*?" : b; if (r.capture) { S = `(${S})` } const globstar = e => { if (e.noglobstar === true) return S; return `(${D}(?:(?!${_}${e.dot ? h : f}).)*?)` }; const create = e => { switch (e) { case "*": return `${v}${p}${S}`; case ".*": return `${f}${p}${S}`; case "*.*": return `${v}${S}${f}${p}${S}`; case "*/*": return `${v}${S}${d}${p}${w}${S}`; case "**": return v + globstar(r); case "**/*": return `(?:${v}${globstar(r)}${d})?${w}${p}${S}`; case "**/*.*": return `(?:${v}${globstar(r)}${d})?${w}${S}${f}${p}${S}`; case "**/.*": return `(?:${v}${globstar(r)}${d})?${f}${p}${S}`; default: { const t = /^(.*?)\.(\w+)$/.exec(e); if (!t) return; const r = create(t[1]); if (!r) return; return r + f + t[2] } } }; const C = i.removePrefix(e, E); let x = create(C); if (x && r.strictSlashes !== true) { x += `${d}?` } return x }; e.exports = parse }, 3322: (e, t, r) => { const n = r(1017); const i = r(2429); const s = r(2139); const o = r(479); const a = r(6099); const isObject = e => e && typeof e === "object" && !Array.isArray(e); const picomatch = (e, t, r = false) => { if (Array.isArray(e)) { const n = e.map((e => picomatch(e, t, r))); const arrayMatcher = e => { for (const t of n) { const r = t(e); if (r) return r } return false }; return arrayMatcher } const n = isObject(e) && e.tokens && e.input; if (e === "" || typeof e !== "string" && !n) { throw new TypeError("Expected pattern to be a non-empty string") } const i = t || {}; const s = o.isWindows(t); const a = n ? picomatch.compileRe(e, t) : picomatch.makeRe(e, t, false, true); const u = a.state; delete a.state; let isIgnored = () => false; if (i.ignore) { const e = { ...t, ignore: null, onMatch: null, onResult: null }; isIgnored = picomatch(i.ignore, e, r) } const matcher = (r, n = false) => { const { isMatch: o, match: l, output: f } = picomatch.test(r, a, t, { glob: e, posix: s }); const d = { glob: e, state: u, regex: a, posix: s, input: r, output: f, match: l, isMatch: o }; if (typeof i.onResult === "function") { i.onResult(d) } if (o === false) { d.isMatch = false; return n ? d : false } if (isIgnored(r)) { if (typeof i.onIgnore === "function") { i.onIgnore(d) } d.isMatch = false; return n ? d : false } if (typeof i.onMatch === "function") { i.onMatch(d) } return n ? d : true }; if (r) { matcher.state = u } return matcher }; picomatch.test = (e, t, r, { glob: n, posix: i } = {}) => { if (typeof e !== "string") { throw new TypeError("Expected input to be a string") } if (e === "") { return { isMatch: false, output: "" } } const s = r || {}; const a = s.format || (i ? o.toPosixSlashes : null); let u = e === n; let l = u && a ? a(e) : e; if (u === false) { l = a ? a(e) : e; u = l === n } if (u === false || s.capture === true) { if (s.matchBase === true || s.basename === true) { u = picomatch.matchBase(e, t, r, i) } else { u = t.exec(l) } } return { isMatch: Boolean(u), match: u, output: l } }; picomatch.matchBase = (e, t, r, i = o.isWindows(r)) => { const s = t instanceof RegExp ? t : picomatch.makeRe(t, r); return s.test(n.basename(e)) }; picomatch.isMatch = (e, t, r) => picomatch(t, r)(e); picomatch.parse = (e, t) => { if (Array.isArray(e)) return e.map((e => picomatch.parse(e, t))); return s(e, { ...t, fastpaths: false }) }; picomatch.scan = (e, t) => i(e, t); picomatch.compileRe = (e, t, r = false, n = false) => { if (r === true) { return e.output } const i = t || {}; const s = i.contains ? "" : "^"; const o = i.contains ? "" : "$"; let a = `${s}(?:${e.output})${o}`; if (e && e.negated === true) { a = `^(?!${a}).*$` } const u = picomatch.toRegex(a, t); if (n === true) { u.state = e } return u }; picomatch.makeRe = (e, t = {}, r = false, n = false) => { if (!e || typeof e !== "string") { throw new TypeError("Expected a non-empty string") } let i = { negated: false, fastpaths: true }; if (t.fastpaths !== false && (e[0] === "." || e[0] === "*")) { i.output = s.fastpaths(e, t) } if (!i.output) { i = s(e, t) } return picomatch.compileRe(i, t, r, n) }; picomatch.toRegex = (e, t) => { try { const r = t || {}; return new RegExp(e, r.flags || (r.nocase ? "i" : "")) } catch (e) { if (t && t.debug === true) throw e; return /$^/ } }; picomatch.constants = a; e.exports = picomatch }, 2429: (e, t, r) => { const n = r(479); const { CHAR_ASTERISK: i, CHAR_AT: s, CHAR_BACKWARD_SLASH: o, CHAR_COMMA: a, CHAR_DOT: u, CHAR_EXCLAMATION_MARK: l, CHAR_FORWARD_SLASH: f, CHAR_LEFT_CURLY_BRACE: d, CHAR_LEFT_PARENTHESES: p, CHAR_LEFT_SQUARE_BRACKET: h, CHAR_PLUS: m, CHAR_QUESTION_MARK: g, CHAR_RIGHT_CURLY_BRACE: y, CHAR_RIGHT_PARENTHESES: b, CHAR_RIGHT_SQUARE_BRACKET: _ } = r(6099); const isPathSeparator = e => e === f || e === o; const depth = e => { if (e.isPrefix !== true) { e.depth = e.isGlobstar ? Infinity : 1 } }; const scan = (e, t) => { const r = t || {}; const v = e.length - 1; const w = r.parts === true || r.scanToEnd === true; const D = []; const E = []; const S = []; let C = e; let x = -1; let A = 0; let P = 0; let R = false; let k = false; let O = false; let T = false; let F = false; let j = false; let L = false; let I = false; let B = false; let N = false; let M = 0; let H; let q; let U = { value: "", depth: 0, isGlob: false }; const eos = () => x >= v; const peek = () => C.charCodeAt(x + 1); const advance = () => { H = q; return C.charCodeAt(++x) }; while (x < v) { q = advance(); let e; if (q === o) { L = U.backslashes = true; q = advance(); if (q === d) { j = true } continue } if (j === true || q === d) { M++; while (eos() !== true && (q = advance())) { if (q === o) { L = U.backslashes = true; advance(); continue } if (q === d) { M++; continue } if (j !== true && q === u && (q = advance()) === u) { R = U.isBrace = true; O = U.isGlob = true; N = true; if (w === true) { continue } break } if (j !== true && q === a) { R = U.isBrace = true; O = U.isGlob = true; N = true; if (w === true) { continue } break } if (q === y) { M--; if (M === 0) { j = false; R = U.isBrace = true; N = true; break } } } if (w === true) { continue } break } if (q === f) { D.push(x); E.push(U); U = { value: "", depth: 0, isGlob: false }; if (N === true) continue; if (H === u && x === A + 1) { A += 2; continue } P = x + 1; continue } if (r.noext !== true) { const e = q === m || q === s || q === i || q === g || q === l; if (e === true && peek() === p) { O = U.isGlob = true; T = U.isExtglob = true; N = true; if (q === l && x === A) { B = true } if (w === true) { while (eos() !== true && (q = advance())) { if (q === o) { L = U.backslashes = true; q = advance(); continue } if (q === b) { O = U.isGlob = true; N = true; break } } continue } break } } if (q === i) { if (H === i) F = U.isGlobstar = true; O = U.isGlob = true; N = true; if (w === true) { continue } break } if (q === g) { O = U.isGlob = true; N = true; if (w === true) { continue } break } if (q === h) { while (eos() !== true && (e = advance())) { if (e === o) { L = U.backslashes = true; advance(); continue } if (e === _) { k = U.isBracket = true; O = U.isGlob = true; N = true; break } } if (w === true) { continue } break } if (r.nonegate !== true && q === l && x === A) { I = U.negated = true; A++; continue } if (r.noparen !== true && q === p) { O = U.isGlob = true; if (w === true) { while (eos() !== true && (q = advance())) { if (q === p) { L = U.backslashes = true; q = advance(); continue } if (q === b) { N = true; break } } continue } break } if (O === true) { N = true; if (w === true) { continue } break } } if (r.noext === true) { T = false; O = false } let W = C; let G = ""; let z = ""; if (A > 0) { G = C.slice(0, A); C = C.slice(A); P -= A } if (W && O === true && P > 0) { W = C.slice(0, P); z = C.slice(P) } else if (O === true) { W = ""; z = C } else { W = C } if (W && W !== "" && W !== "/" && W !== C) { if (isPathSeparator(W.charCodeAt(W.length - 1))) { W = W.slice(0, -1) } } if (r.unescape === true) { if (z) z = n.removeBackslashes(z); if (W && L === true) { W = n.removeBackslashes(W) } } const V = { prefix: G, input: e, start: A, base: W, glob: z, isBrace: R, isBracket: k, isGlob: O, isExtglob: T, isGlobstar: F, negated: I, negatedExtglob: B }; if (r.tokens === true) { V.maxDepth = 0; if (!isPathSeparator(q)) { E.push(U) } V.tokens = E } if (r.parts === true || r.tokens === true) { let t; for (let n = 0; n < D.length; n++) { const i = t ? t + 1 : A; const s = D[n]; const o = e.slice(i, s); if (r.tokens) { if (n === 0 && A !== 0) { E[n].isPrefix = true; E[n].value = G } else { E[n].value = o } depth(E[n]); V.maxDepth += E[n].depth } if (n !== 0 || o !== "") { S.push(o) } t = s } if (t && t + 1 < e.length) { const n = e.slice(t + 1); S.push(n); if (r.tokens) { E[E.length - 1].value = n; depth(E[E.length - 1]); V.maxDepth += E[E.length - 1].depth } } V.slashes = D; V.parts = S } return V }; e.exports = scan }, 479: (e, t, r) => { const n = r(1017); const i = process.platform === "win32"; const { REGEX_BACKSLASH: s, REGEX_REMOVE_BACKSLASH: o, REGEX_SPECIAL_CHARS: a, REGEX_SPECIAL_CHARS_GLOBAL: u } = r(6099); t.isObject = e => e !== null && typeof e === "object" && !Array.isArray(e); t.hasRegexChars = e => a.test(e); t.isRegexChar = e => e.length === 1 && t.hasRegexChars(e); t.escapeRegex = e => e.replace(u, "\\$1"); t.toPosixSlashes = e => e.replace(s, "/"); t.removeBackslashes = e => e.replace(o, (e => e === "\\" ? "" : e)); t.supportsLookbehinds = () => { const e = process.version.slice(1).split(".").map(Number); if (e.length === 3 && e[0] >= 9 || e[0] === 8 && e[1] >= 10) { return true } return false }; t.isWindows = e => { if (e && typeof e.windows === "boolean") { return e.windows } return i === true || n.sep === "\\" }; t.escapeLast = (e, r, n) => { const i = e.lastIndexOf(r, n); if (i === -1) return e; if (e[i - 1] === "\\") return t.escapeLast(e, r, i - 1); return `${e.slice(0, i)}\\${e.slice(i)}` }; t.removePrefix = (e, t = {}) => { let r = e; if (r.startsWith("./")) { r = r.slice(2); t.prefix = "./" } return r }; t.wrapOutput = (e, t = {}, r = {}) => { const n = r.contains ? "" : "^"; const i = r.contains ? "" : "$"; let s = `${n}(?:${e})${i}`; if (t.negated === true) { s = `(?:^(?!${s}).*$)` } return s } }, 9795: e => {
    /*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
    let t; e.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : global) : e => (t || (t = Promise.resolve())).then(e).catch((e => setTimeout((() => { throw e }), 0)))
  }, 9273: e => { class QuickLRU { constructor(e = {}) { if (!(e.maxSize && e.maxSize > 0)) { throw new TypeError("`maxSize` must be a number greater than 0") } this.maxSize = e.maxSize; this.onEviction = e.onEviction; this.cache = new Map; this.oldCache = new Map; this._size = 0 } _set(e, t) { this.cache.set(e, t); this._size++; if (this._size >= this.maxSize) { this._size = 0; if (typeof this.onEviction === "function") { for (const [e, t] of this.oldCache.entries()) { this.onEviction(e, t) } } this.oldCache = this.cache; this.cache = new Map } } get(e) { if (this.cache.has(e)) { return this.cache.get(e) } if (this.oldCache.has(e)) { const t = this.oldCache.get(e); this.oldCache.delete(e); this._set(e, t); return t } } set(e, t) { if (this.cache.has(e)) { this.cache.set(e, t) } else { this._set(e, t) } return this } has(e) { return this.cache.has(e) || this.oldCache.has(e) } peek(e) { if (this.cache.has(e)) { return this.cache.get(e) } if (this.oldCache.has(e)) { return this.oldCache.get(e) } } delete(e) { const t = this.cache.delete(e); if (t) { this._size-- } return this.oldCache.delete(e) || t } clear() { this.cache.clear(); this.oldCache.clear(); this._size = 0 } *keys() { for (const [e] of this) { yield e } } *values() { for (const [, e] of this) { yield e } } *[Symbol.iterator]() { for (const e of this.cache) { yield e } for (const e of this.oldCache) { const [t] = e; if (!this.cache.has(t)) { yield e } } } get size() { let e = 0; for (const t of this.oldCache.keys()) { if (!this.cache.has(t)) { e++ } } return Math.min(this._size + e, this.maxSize) } } e.exports = QuickLRU }, 7214: e => { const t = {}; function createErrorType(e, r, n) { if (!n) { n = Error } function getMessage(e, t, n) { if (typeof r === "string") { return r } else { return r(e, t, n) } } class NodeError extends n { constructor(e, t, r) { super(getMessage(e, t, r)) } } NodeError.prototype.name = n.name; NodeError.prototype.code = e; t[e] = NodeError } function oneOf(e, t) { if (Array.isArray(e)) { const r = e.length; e = e.map((e => String(e))); if (r > 2) { return `one of ${t} ${e.slice(0, r - 1).join(", ")}, or ` + e[r - 1] } else if (r === 2) { return `one of ${t} ${e[0]} or ${e[1]}` } else { return `of ${t} ${e[0]}` } } else { return `of ${t} ${String(e)}` } } function startsWith(e, t, r) { return e.substr(!r || r < 0 ? 0 : +r, t.length) === t } function endsWith(e, t, r) { if (r === undefined || r > e.length) { r = e.length } return e.substring(r - t.length, r) === t } function includes(e, t, r) { if (typeof r !== "number") { r = 0 } if (r + t.length > e.length) { return false } else { return e.indexOf(t, r) !== -1 } } createErrorType("ERR_INVALID_OPT_VALUE", (function (e, t) { return 'The value "' + t + '" is invalid for option "' + e + '"' }), TypeError); createErrorType("ERR_INVALID_ARG_TYPE", (function (e, t, r) { let n; if (typeof t === "string" && startsWith(t, "not ")) { n = "must not be"; t = t.replace(/^not /, "") } else { n = "must be" } let i; if (endsWith(e, " argument")) { i = `The ${e} ${n} ${oneOf(t, "type")}` } else { const r = includes(e, ".") ? "property" : "argument"; i = `The "${e}" ${r} ${n} ${oneOf(t, "type")}` } i += `. Received type ${typeof r}`; return i }), TypeError); createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"); createErrorType("ERR_METHOD_NOT_IMPLEMENTED", (function (e) { return "The " + e + " method is not implemented" })); createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close"); createErrorType("ERR_STREAM_DESTROYED", (function (e) { return "Cannot call " + e + " after a stream was destroyed" })); createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"); createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"); createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end"); createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError); createErrorType("ERR_UNKNOWN_ENCODING", (function (e) { return "Unknown encoding: " + e }), TypeError); createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"); e.exports.q = t }, 1359: (e, t, r) => { var n = Object.keys || function (e) { var t = []; for (var r in e) t.push(r); return t }; e.exports = Duplex; var i = r(1433); var s = r(6993); r(4124)(Duplex, i); { var o = n(s.prototype); for (var a = 0; a < o.length; a++) { var u = o[a]; if (!Duplex.prototype[u]) Duplex.prototype[u] = s.prototype[u] } } function Duplex(e) { if (!(this instanceof Duplex)) return new Duplex(e); i.call(this, e); s.call(this, e); this.allowHalfOpen = true; if (e) { if (e.readable === false) this.readable = false; if (e.writable === false) this.writable = false; if (e.allowHalfOpen === false) { this.allowHalfOpen = false; this.once("end", onend) } } } Object.defineProperty(Duplex.prototype, "writableHighWaterMark", { enumerable: false, get: function get() { return this._writableState.highWaterMark } }); Object.defineProperty(Duplex.prototype, "writableBuffer", { enumerable: false, get: function get() { return this._writableState && this._writableState.getBuffer() } }); Object.defineProperty(Duplex.prototype, "writableLength", { enumerable: false, get: function get() { return this._writableState.length } }); function onend() { if (this._writableState.ended) return; process.nextTick(onEndNT, this) } function onEndNT(e) { e.end() } Object.defineProperty(Duplex.prototype, "destroyed", { enumerable: false, get: function get() { if (this._readableState === undefined || this._writableState === undefined) { return false } return this._readableState.destroyed && this._writableState.destroyed }, set: function set(e) { if (this._readableState === undefined || this._writableState === undefined) { return } this._readableState.destroyed = e; this._writableState.destroyed = e } }) }, 1542: (e, t, r) => { e.exports = PassThrough; var n = r(4415); r(4124)(PassThrough, n); function PassThrough(e) { if (!(this instanceof PassThrough)) return new PassThrough(e); n.call(this, e) } PassThrough.prototype._transform = function (e, t, r) { r(null, e) } }, 1433: (e, t, r) => { e.exports = Readable; var n; Readable.ReadableState = ReadableState; var i = r(2361).EventEmitter; var s = function EElistenerCount(e, t) { return e.listeners(t).length }; var o = r(2387); var a = r(4300).Buffer; var u = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function () { }; function _uint8ArrayToBuffer(e) { return a.from(e) } function _isUint8Array(e) { return a.isBuffer(e) || e instanceof u } var l = r(3837); var f; if (l && l.debuglog) { f = l.debuglog("stream") } else { f = function debug() { } } var d = r(6522); var p = r(7049); var h = r(9948), m = h.getHighWaterMark; var g = r(7214).q, y = g.ERR_INVALID_ARG_TYPE, b = g.ERR_STREAM_PUSH_AFTER_EOF, _ = g.ERR_METHOD_NOT_IMPLEMENTED, v = g.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; var w; var D; var E; r(4124)(Readable, o); var S = p.errorOrDestroy; var C = ["error", "close", "destroy", "pause", "resume"]; function prependListener(e, t, r) { if (typeof e.prependListener === "function") return e.prependListener(t, r); if (!e._events || !e._events[t]) e.on(t, r); else if (Array.isArray(e._events[t])) e._events[t].unshift(r); else e._events[t] = [r, e._events[t]] } function ReadableState(e, t, i) { n = n || r(1359); e = e || {}; if (typeof i !== "boolean") i = t instanceof n; this.objectMode = !!e.objectMode; if (i) this.objectMode = this.objectMode || !!e.readableObjectMode; this.highWaterMark = m(this, e, "readableHighWaterMark", i); this.buffer = new d; this.length = 0; this.pipes = null; this.pipesCount = 0; this.flowing = null; this.ended = false; this.endEmitted = false; this.reading = false; this.sync = true; this.needReadable = false; this.emittedReadable = false; this.readableListening = false; this.resumeScheduled = false; this.paused = true; this.emitClose = e.emitClose !== false; this.autoDestroy = !!e.autoDestroy; this.destroyed = false; this.defaultEncoding = e.defaultEncoding || "utf8"; this.awaitDrain = 0; this.readingMore = false; this.decoder = null; this.encoding = null; if (e.encoding) { if (!w) w = r(4841).s; this.decoder = new w(e.encoding); this.encoding = e.encoding } } function Readable(e) { n = n || r(1359); if (!(this instanceof Readable)) return new Readable(e); var t = this instanceof n; this._readableState = new ReadableState(e, this, t); this.readable = true; if (e) { if (typeof e.read === "function") this._read = e.read; if (typeof e.destroy === "function") this._destroy = e.destroy } o.call(this) } Object.defineProperty(Readable.prototype, "destroyed", { enumerable: false, get: function get() { if (this._readableState === undefined) { return false } return this._readableState.destroyed }, set: function set(e) { if (!this._readableState) { return } this._readableState.destroyed = e } }); Readable.prototype.destroy = p.destroy; Readable.prototype._undestroy = p.undestroy; Readable.prototype._destroy = function (e, t) { t(e) }; Readable.prototype.push = function (e, t) { var r = this._readableState; var n; if (!r.objectMode) { if (typeof e === "string") { t = t || r.defaultEncoding; if (t !== r.encoding) { e = a.from(e, t); t = "" } n = true } } else { n = true } return readableAddChunk(this, e, t, false, n) }; Readable.prototype.unshift = function (e) { return readableAddChunk(this, e, null, true, false) }; function readableAddChunk(e, t, r, n, i) { f("readableAddChunk", t); var s = e._readableState; if (t === null) { s.reading = false; onEofChunk(e, s) } else { var o; if (!i) o = chunkInvalid(s, t); if (o) { S(e, o) } else if (s.objectMode || t && t.length > 0) { if (typeof t !== "string" && !s.objectMode && Object.getPrototypeOf(t) !== a.prototype) { t = _uint8ArrayToBuffer(t) } if (n) { if (s.endEmitted) S(e, new v); else addChunk(e, s, t, true) } else if (s.ended) { S(e, new b) } else if (s.destroyed) { return false } else { s.reading = false; if (s.decoder && !r) { t = s.decoder.write(t); if (s.objectMode || t.length !== 0) addChunk(e, s, t, false); else maybeReadMore(e, s) } else { addChunk(e, s, t, false) } } } else if (!n) { s.reading = false; maybeReadMore(e, s) } } return !s.ended && (s.length < s.highWaterMark || s.length === 0) } function addChunk(e, t, r, n) { if (t.flowing && t.length === 0 && !t.sync) { t.awaitDrain = 0; e.emit("data", r) } else { t.length += t.objectMode ? 1 : r.length; if (n) t.buffer.unshift(r); else t.buffer.push(r); if (t.needReadable) emitReadable(e) } maybeReadMore(e, t) } function chunkInvalid(e, t) { var r; if (!_isUint8Array(t) && typeof t !== "string" && t !== undefined && !e.objectMode) { r = new y("chunk", ["string", "Buffer", "Uint8Array"], t) } return r } Readable.prototype.isPaused = function () { return this._readableState.flowing === false }; Readable.prototype.setEncoding = function (e) { if (!w) w = r(4841).s; var t = new w(e); this._readableState.decoder = t; this._readableState.encoding = this._readableState.decoder.encoding; var n = this._readableState.buffer.head; var i = ""; while (n !== null) { i += t.write(n.data); n = n.next } this._readableState.buffer.clear(); if (i !== "") this._readableState.buffer.push(i); this._readableState.length = i.length; return this }; var x = 1073741824; function computeNewHighWaterMark(e) { if (e >= x) { e = x } else { e--; e |= e >>> 1; e |= e >>> 2; e |= e >>> 4; e |= e >>> 8; e |= e >>> 16; e++ } return e } function howMuchToRead(e, t) { if (e <= 0 || t.length === 0 && t.ended) return 0; if (t.objectMode) return 1; if (e !== e) { if (t.flowing && t.length) return t.buffer.head.data.length; else return t.length } if (e > t.highWaterMark) t.highWaterMark = computeNewHighWaterMark(e); if (e <= t.length) return e; if (!t.ended) { t.needReadable = true; return 0 } return t.length } Readable.prototype.read = function (e) { f("read", e); e = parseInt(e, 10); var t = this._readableState; var r = e; if (e !== 0) t.emittedReadable = false; if (e === 0 && t.needReadable && ((t.highWaterMark !== 0 ? t.length >= t.highWaterMark : t.length > 0) || t.ended)) { f("read: emitReadable", t.length, t.ended); if (t.length === 0 && t.ended) endReadable(this); else emitReadable(this); return null } e = howMuchToRead(e, t); if (e === 0 && t.ended) { if (t.length === 0) endReadable(this); return null } var n = t.needReadable; f("need readable", n); if (t.length === 0 || t.length - e < t.highWaterMark) { n = true; f("length less than watermark", n) } if (t.ended || t.reading) { n = false; f("reading or ended", n) } else if (n) { f("do read"); t.reading = true; t.sync = true; if (t.length === 0) t.needReadable = true; this._read(t.highWaterMark); t.sync = false; if (!t.reading) e = howMuchToRead(r, t) } var i; if (e > 0) i = fromList(e, t); else i = null; if (i === null) { t.needReadable = t.length <= t.highWaterMark; e = 0 } else { t.length -= e; t.awaitDrain = 0 } if (t.length === 0) { if (!t.ended) t.needReadable = true; if (r !== e && t.ended) endReadable(this) } if (i !== null) this.emit("data", i); return i }; function onEofChunk(e, t) { f("onEofChunk"); if (t.ended) return; if (t.decoder) { var r = t.decoder.end(); if (r && r.length) { t.buffer.push(r); t.length += t.objectMode ? 1 : r.length } } t.ended = true; if (t.sync) { emitReadable(e) } else { t.needReadable = false; if (!t.emittedReadable) { t.emittedReadable = true; emitReadable_(e) } } } function emitReadable(e) { var t = e._readableState; f("emitReadable", t.needReadable, t.emittedReadable); t.needReadable = false; if (!t.emittedReadable) { f("emitReadable", t.flowing); t.emittedReadable = true; process.nextTick(emitReadable_, e) } } function emitReadable_(e) { var t = e._readableState; f("emitReadable_", t.destroyed, t.length, t.ended); if (!t.destroyed && (t.length || t.ended)) { e.emit("readable"); t.emittedReadable = false } t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark; flow(e) } function maybeReadMore(e, t) { if (!t.readingMore) { t.readingMore = true; process.nextTick(maybeReadMore_, e, t) } } function maybeReadMore_(e, t) { while (!t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && t.length === 0)) { var r = t.length; f("maybeReadMore read 0"); e.read(0); if (r === t.length) break } t.readingMore = false } Readable.prototype._read = function (e) { S(this, new _("_read()")) }; Readable.prototype.pipe = function (e, t) { var r = this; var n = this._readableState; switch (n.pipesCount) { case 0: n.pipes = e; break; case 1: n.pipes = [n.pipes, e]; break; default: n.pipes.push(e); break }n.pipesCount += 1; f("pipe count=%d opts=%j", n.pipesCount, t); var i = (!t || t.end !== false) && e !== process.stdout && e !== process.stderr; var o = i ? onend : unpipe; if (n.endEmitted) process.nextTick(o); else r.once("end", o); e.on("unpipe", onunpipe); function onunpipe(e, t) { f("onunpipe"); if (e === r) { if (t && t.hasUnpiped === false) { t.hasUnpiped = true; cleanup() } } } function onend() { f("onend"); e.end() } var a = pipeOnDrain(r); e.on("drain", a); var u = false; function cleanup() { f("cleanup"); e.removeListener("close", onclose); e.removeListener("finish", onfinish); e.removeListener("drain", a); e.removeListener("error", onerror); e.removeListener("unpipe", onunpipe); r.removeListener("end", onend); r.removeListener("end", unpipe); r.removeListener("data", ondata); u = true; if (n.awaitDrain && (!e._writableState || e._writableState.needDrain)) a() } r.on("data", ondata); function ondata(t) { f("ondata"); var i = e.write(t); f("dest.write", i); if (i === false) { if ((n.pipesCount === 1 && n.pipes === e || n.pipesCount > 1 && indexOf(n.pipes, e) !== -1) && !u) { f("false write response, pause", n.awaitDrain); n.awaitDrain++ } r.pause() } } function onerror(t) { f("onerror", t); unpipe(); e.removeListener("error", onerror); if (s(e, "error") === 0) S(e, t) } prependListener(e, "error", onerror); function onclose() { e.removeListener("finish", onfinish); unpipe() } e.once("close", onclose); function onfinish() { f("onfinish"); e.removeListener("close", onclose); unpipe() } e.once("finish", onfinish); function unpipe() { f("unpipe"); r.unpipe(e) } e.emit("pipe", r); if (!n.flowing) { f("pipe resume"); r.resume() } return e }; function pipeOnDrain(e) { return function pipeOnDrainFunctionResult() { var t = e._readableState; f("pipeOnDrain", t.awaitDrain); if (t.awaitDrain) t.awaitDrain--; if (t.awaitDrain === 0 && s(e, "data")) { t.flowing = true; flow(e) } } } Readable.prototype.unpipe = function (e) { var t = this._readableState; var r = { hasUnpiped: false }; if (t.pipesCount === 0) return this; if (t.pipesCount === 1) { if (e && e !== t.pipes) return this; if (!e) e = t.pipes; t.pipes = null; t.pipesCount = 0; t.flowing = false; if (e) e.emit("unpipe", this, r); return this } if (!e) { var n = t.pipes; var i = t.pipesCount; t.pipes = null; t.pipesCount = 0; t.flowing = false; for (var s = 0; s < i; s++)n[s].emit("unpipe", this, { hasUnpiped: false }); return this } var o = indexOf(t.pipes, e); if (o === -1) return this; t.pipes.splice(o, 1); t.pipesCount -= 1; if (t.pipesCount === 1) t.pipes = t.pipes[0]; e.emit("unpipe", this, r); return this }; Readable.prototype.on = function (e, t) { var r = o.prototype.on.call(this, e, t); var n = this._readableState; if (e === "data") { n.readableListening = this.listenerCount("readable") > 0; if (n.flowing !== false) this.resume() } else if (e === "readable") { if (!n.endEmitted && !n.readableListening) { n.readableListening = n.needReadable = true; n.flowing = false; n.emittedReadable = false; f("on readable", n.length, n.reading); if (n.length) { emitReadable(this) } else if (!n.reading) { process.nextTick(nReadingNextTick, this) } } } return r }; Readable.prototype.addListener = Readable.prototype.on; Readable.prototype.removeListener = function (e, t) { var r = o.prototype.removeListener.call(this, e, t); if (e === "readable") { process.nextTick(updateReadableListening, this) } return r }; Readable.prototype.removeAllListeners = function (e) { var t = o.prototype.removeAllListeners.apply(this, arguments); if (e === "readable" || e === undefined) { process.nextTick(updateReadableListening, this) } return t }; function updateReadableListening(e) { var t = e._readableState; t.readableListening = e.listenerCount("readable") > 0; if (t.resumeScheduled && !t.paused) { t.flowing = true } else if (e.listenerCount("data") > 0) { e.resume() } } function nReadingNextTick(e) { f("readable nexttick read 0"); e.read(0) } Readable.prototype.resume = function () { var e = this._readableState; if (!e.flowing) { f("resume"); e.flowing = !e.readableListening; resume(this, e) } e.paused = false; return this }; function resume(e, t) { if (!t.resumeScheduled) { t.resumeScheduled = true; process.nextTick(resume_, e, t) } } function resume_(e, t) { f("resume", t.reading); if (!t.reading) { e.read(0) } t.resumeScheduled = false; e.emit("resume"); flow(e); if (t.flowing && !t.reading) e.read(0) } Readable.prototype.pause = function () { f("call pause flowing=%j", this._readableState.flowing); if (this._readableState.flowing !== false) { f("pause"); this._readableState.flowing = false; this.emit("pause") } this._readableState.paused = true; return this }; function flow(e) { var t = e._readableState; f("flow", t.flowing); while (t.flowing && e.read() !== null); } Readable.prototype.wrap = function (e) { var t = this; var r = this._readableState; var n = false; e.on("end", (function () { f("wrapped end"); if (r.decoder && !r.ended) { var e = r.decoder.end(); if (e && e.length) t.push(e) } t.push(null) })); e.on("data", (function (i) { f("wrapped data"); if (r.decoder) i = r.decoder.write(i); if (r.objectMode && (i === null || i === undefined)) return; else if (!r.objectMode && (!i || !i.length)) return; var s = t.push(i); if (!s) { n = true; e.pause() } })); for (var i in e) { if (this[i] === undefined && typeof e[i] === "function") { this[i] = function methodWrap(t) { return function methodWrapReturnFunction() { return e[t].apply(e, arguments) } }(i) } } for (var s = 0; s < C.length; s++) { e.on(C[s], this.emit.bind(this, C[s])) } this._read = function (t) { f("wrapped _read", t); if (n) { n = false; e.resume() } }; return this }; if (typeof Symbol === "function") { Readable.prototype[Symbol.asyncIterator] = function () { if (D === undefined) { D = r(3306) } return D(this) } } Object.defineProperty(Readable.prototype, "readableHighWaterMark", { enumerable: false, get: function get() { return this._readableState.highWaterMark } }); Object.defineProperty(Readable.prototype, "readableBuffer", { enumerable: false, get: function get() { return this._readableState && this._readableState.buffer } }); Object.defineProperty(Readable.prototype, "readableFlowing", { enumerable: false, get: function get() { return this._readableState.flowing }, set: function set(e) { if (this._readableState) { this._readableState.flowing = e } } }); Readable._fromList = fromList; Object.defineProperty(Readable.prototype, "readableLength", { enumerable: false, get: function get() { return this._readableState.length } }); function fromList(e, t) { if (t.length === 0) return null; var r; if (t.objectMode) r = t.buffer.shift(); else if (!e || e >= t.length) { if (t.decoder) r = t.buffer.join(""); else if (t.buffer.length === 1) r = t.buffer.first(); else r = t.buffer.concat(t.length); t.buffer.clear() } else { r = t.buffer.consume(e, t.decoder) } return r } function endReadable(e) { var t = e._readableState; f("endReadable", t.endEmitted); if (!t.endEmitted) { t.ended = true; process.nextTick(endReadableNT, t, e) } } function endReadableNT(e, t) { f("endReadableNT", e.endEmitted, e.length); if (!e.endEmitted && e.length === 0) { e.endEmitted = true; t.readable = false; t.emit("end"); if (e.autoDestroy) { var r = t._writableState; if (!r || r.autoDestroy && r.finished) { t.destroy() } } } } if (typeof Symbol === "function") { Readable.from = function (e, t) { if (E === undefined) { E = r(9082) } return E(Readable, e, t) } } function indexOf(e, t) { for (var r = 0, n = e.length; r < n; r++) { if (e[r] === t) return r } return -1 } }, 4415: (e, t, r) => { e.exports = Transform; var n = r(7214).q, i = n.ERR_METHOD_NOT_IMPLEMENTED, s = n.ERR_MULTIPLE_CALLBACK, o = n.ERR_TRANSFORM_ALREADY_TRANSFORMING, a = n.ERR_TRANSFORM_WITH_LENGTH_0; var u = r(1359); r(4124)(Transform, u); function afterTransform(e, t) { var r = this._transformState; r.transforming = false; var n = r.writecb; if (n === null) { return this.emit("error", new s) } r.writechunk = null; r.writecb = null; if (t != null) this.push(t); n(e); var i = this._readableState; i.reading = false; if (i.needReadable || i.length < i.highWaterMark) { this._read(i.highWaterMark) } } function Transform(e) { if (!(this instanceof Transform)) return new Transform(e); u.call(this, e); this._transformState = { afterTransform: afterTransform.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }; this._readableState.needReadable = true; this._readableState.sync = false; if (e) { if (typeof e.transform === "function") this._transform = e.transform; if (typeof e.flush === "function") this._flush = e.flush } this.on("prefinish", prefinish) } function prefinish() { var e = this; if (typeof this._flush === "function" && !this._readableState.destroyed) { this._flush((function (t, r) { done(e, t, r) })) } else { done(this, null, null) } } Transform.prototype.push = function (e, t) { this._transformState.needTransform = false; return u.prototype.push.call(this, e, t) }; Transform.prototype._transform = function (e, t, r) { r(new i("_transform()")) }; Transform.prototype._write = function (e, t, r) { var n = this._transformState; n.writecb = r; n.writechunk = e; n.writeencoding = t; if (!n.transforming) { var i = this._readableState; if (n.needTransform || i.needReadable || i.length < i.highWaterMark) this._read(i.highWaterMark) } }; Transform.prototype._read = function (e) { var t = this._transformState; if (t.writechunk !== null && !t.transforming) { t.transforming = true; this._transform(t.writechunk, t.writeencoding, t.afterTransform) } else { t.needTransform = true } }; Transform.prototype._destroy = function (e, t) { u.prototype._destroy.call(this, e, (function (e) { t(e) })) }; function done(e, t, r) { if (t) return e.emit("error", t); if (r != null) e.push(r); if (e._writableState.length) throw new a; if (e._transformState.transforming) throw new o; return e.push(null) } }, 6993: (e, t, r) => { e.exports = Writable; function WriteReq(e, t, r) { this.chunk = e; this.encoding = t; this.callback = r; this.next = null } function CorkedRequest(e) { var t = this; this.next = null; this.entry = null; this.finish = function () { onCorkedFinish(t, e) } } var n; Writable.WritableState = WritableState; var i = { deprecate: r(7127) }; var s = r(2387); var o = r(4300).Buffer; var a = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function () { }; function _uint8ArrayToBuffer(e) { return o.from(e) } function _isUint8Array(e) { return o.isBuffer(e) || e instanceof a } var u = r(7049); var l = r(9948), f = l.getHighWaterMark; var d = r(7214).q, p = d.ERR_INVALID_ARG_TYPE, h = d.ERR_METHOD_NOT_IMPLEMENTED, m = d.ERR_MULTIPLE_CALLBACK, g = d.ERR_STREAM_CANNOT_PIPE, y = d.ERR_STREAM_DESTROYED, b = d.ERR_STREAM_NULL_VALUES, _ = d.ERR_STREAM_WRITE_AFTER_END, v = d.ERR_UNKNOWN_ENCODING; var w = u.errorOrDestroy; r(4124)(Writable, s); function nop() { } function WritableState(e, t, i) { n = n || r(1359); e = e || {}; if (typeof i !== "boolean") i = t instanceof n; this.objectMode = !!e.objectMode; if (i) this.objectMode = this.objectMode || !!e.writableObjectMode; this.highWaterMark = f(this, e, "writableHighWaterMark", i); this.finalCalled = false; this.needDrain = false; this.ending = false; this.ended = false; this.finished = false; this.destroyed = false; var s = e.decodeStrings === false; this.decodeStrings = !s; this.defaultEncoding = e.defaultEncoding || "utf8"; this.length = 0; this.writing = false; this.corked = 0; this.sync = true; this.bufferProcessing = false; this.onwrite = function (e) { onwrite(t, e) }; this.writecb = null; this.writelen = 0; this.bufferedRequest = null; this.lastBufferedRequest = null; this.pendingcb = 0; this.prefinished = false; this.errorEmitted = false; this.emitClose = e.emitClose !== false; this.autoDestroy = !!e.autoDestroy; this.bufferedRequestCount = 0; this.corkedRequestsFree = new CorkedRequest(this) } WritableState.prototype.getBuffer = function getBuffer() { var e = this.bufferedRequest; var t = []; while (e) { t.push(e); e = e.next } return t }; (function () { try { Object.defineProperty(WritableState.prototype, "buffer", { get: i.deprecate((function writableStateBufferGetter() { return this.getBuffer() }), "_writableState.buffer is deprecated. Use _writableState.getBuffer " + "instead.", "DEP0003") }) } catch (e) { } })(); var D; if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") { D = Function.prototype[Symbol.hasInstance]; Object.defineProperty(Writable, Symbol.hasInstance, { value: function value(e) { if (D.call(this, e)) return true; if (this !== Writable) return false; return e && e._writableState instanceof WritableState } }) } else { D = function realHasInstance(e) { return e instanceof this } } function Writable(e) { n = n || r(1359); var t = this instanceof n; if (!t && !D.call(Writable, this)) return new Writable(e); this._writableState = new WritableState(e, this, t); this.writable = true; if (e) { if (typeof e.write === "function") this._write = e.write; if (typeof e.writev === "function") this._writev = e.writev; if (typeof e.destroy === "function") this._destroy = e.destroy; if (typeof e.final === "function") this._final = e.final } s.call(this) } Writable.prototype.pipe = function () { w(this, new g) }; function writeAfterEnd(e, t) { var r = new _; w(e, r); process.nextTick(t, r) } function validChunk(e, t, r, n) { var i; if (r === null) { i = new b } else if (typeof r !== "string" && !t.objectMode) { i = new p("chunk", ["string", "Buffer"], r) } if (i) { w(e, i); process.nextTick(n, i); return false } return true } Writable.prototype.write = function (e, t, r) { var n = this._writableState; var i = false; var s = !n.objectMode && _isUint8Array(e); if (s && !o.isBuffer(e)) { e = _uint8ArrayToBuffer(e) } if (typeof t === "function") { r = t; t = null } if (s) t = "buffer"; else if (!t) t = n.defaultEncoding; if (typeof r !== "function") r = nop; if (n.ending) writeAfterEnd(this, r); else if (s || validChunk(this, n, e, r)) { n.pendingcb++; i = writeOrBuffer(this, n, s, e, t, r) } return i }; Writable.prototype.cork = function () { this._writableState.corked++ }; Writable.prototype.uncork = function () { var e = this._writableState; if (e.corked) { e.corked--; if (!e.writing && !e.corked && !e.bufferProcessing && e.bufferedRequest) clearBuffer(this, e) } }; Writable.prototype.setDefaultEncoding = function setDefaultEncoding(e) { if (typeof e === "string") e = e.toLowerCase(); if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase()) > -1)) throw new v(e); this._writableState.defaultEncoding = e; return this }; Object.defineProperty(Writable.prototype, "writableBuffer", { enumerable: false, get: function get() { return this._writableState && this._writableState.getBuffer() } }); function decodeChunk(e, t, r) { if (!e.objectMode && e.decodeStrings !== false && typeof t === "string") { t = o.from(t, r) } return t } Object.defineProperty(Writable.prototype, "writableHighWaterMark", { enumerable: false, get: function get() { return this._writableState.highWaterMark } }); function writeOrBuffer(e, t, r, n, i, s) { if (!r) { var o = decodeChunk(t, n, i); if (n !== o) { r = true; i = "buffer"; n = o } } var a = t.objectMode ? 1 : n.length; t.length += a; var u = t.length < t.highWaterMark; if (!u) t.needDrain = true; if (t.writing || t.corked) { var l = t.lastBufferedRequest; t.lastBufferedRequest = { chunk: n, encoding: i, isBuf: r, callback: s, next: null }; if (l) { l.next = t.lastBufferedRequest } else { t.bufferedRequest = t.lastBufferedRequest } t.bufferedRequestCount += 1 } else { doWrite(e, t, false, a, n, i, s) } return u } function doWrite(e, t, r, n, i, s, o) { t.writelen = n; t.writecb = o; t.writing = true; t.sync = true; if (t.destroyed) t.onwrite(new y("write")); else if (r) e._writev(i, t.onwrite); else e._write(i, s, t.onwrite); t.sync = false } function onwriteError(e, t, r, n, i) { --t.pendingcb; if (r) { process.nextTick(i, n); process.nextTick(finishMaybe, e, t); e._writableState.errorEmitted = true; w(e, n) } else { i(n); e._writableState.errorEmitted = true; w(e, n); finishMaybe(e, t) } } function onwriteStateUpdate(e) { e.writing = false; e.writecb = null; e.length -= e.writelen; e.writelen = 0 } function onwrite(e, t) { var r = e._writableState; var n = r.sync; var i = r.writecb; if (typeof i !== "function") throw new m; onwriteStateUpdate(r); if (t) onwriteError(e, r, n, t, i); else { var s = needFinish(r) || e.destroyed; if (!s && !r.corked && !r.bufferProcessing && r.bufferedRequest) { clearBuffer(e, r) } if (n) { process.nextTick(afterWrite, e, r, s, i) } else { afterWrite(e, r, s, i) } } } function afterWrite(e, t, r, n) { if (!r) onwriteDrain(e, t); t.pendingcb--; n(); finishMaybe(e, t) } function onwriteDrain(e, t) { if (t.length === 0 && t.needDrain) { t.needDrain = false; e.emit("drain") } } function clearBuffer(e, t) { t.bufferProcessing = true; var r = t.bufferedRequest; if (e._writev && r && r.next) { var n = t.bufferedRequestCount; var i = new Array(n); var s = t.corkedRequestsFree; s.entry = r; var o = 0; var a = true; while (r) { i[o] = r; if (!r.isBuf) a = false; r = r.next; o += 1 } i.allBuffers = a; doWrite(e, t, true, t.length, i, "", s.finish); t.pendingcb++; t.lastBufferedRequest = null; if (s.next) { t.corkedRequestsFree = s.next; s.next = null } else { t.corkedRequestsFree = new CorkedRequest(t) } t.bufferedRequestCount = 0 } else { while (r) { var u = r.chunk; var l = r.encoding; var f = r.callback; var d = t.objectMode ? 1 : u.length; doWrite(e, t, false, d, u, l, f); r = r.next; t.bufferedRequestCount--; if (t.writing) { break } } if (r === null) t.lastBufferedRequest = null } t.bufferedRequest = r; t.bufferProcessing = false } Writable.prototype._write = function (e, t, r) { r(new h("_write()")) }; Writable.prototype._writev = null; Writable.prototype.end = function (e, t, r) { var n = this._writableState; if (typeof e === "function") { r = e; e = null; t = null } else if (typeof t === "function") { r = t; t = null } if (e !== null && e !== undefined) this.write(e, t); if (n.corked) { n.corked = 1; this.uncork() } if (!n.ending) endWritable(this, n, r); return this }; Object.defineProperty(Writable.prototype, "writableLength", { enumerable: false, get: function get() { return this._writableState.length } }); function needFinish(e) { return e.ending && e.length === 0 && e.bufferedRequest === null && !e.finished && !e.writing } function callFinal(e, t) { e._final((function (r) { t.pendingcb--; if (r) { w(e, r) } t.prefinished = true; e.emit("prefinish"); finishMaybe(e, t) })) } function prefinish(e, t) { if (!t.prefinished && !t.finalCalled) { if (typeof e._final === "function" && !t.destroyed) { t.pendingcb++; t.finalCalled = true; process.nextTick(callFinal, e, t) } else { t.prefinished = true; e.emit("prefinish") } } } function finishMaybe(e, t) { var r = needFinish(t); if (r) { prefinish(e, t); if (t.pendingcb === 0) { t.finished = true; e.emit("finish"); if (t.autoDestroy) { var n = e._readableState; if (!n || n.autoDestroy && n.endEmitted) { e.destroy() } } } } return r } function endWritable(e, t, r) { t.ending = true; finishMaybe(e, t); if (r) { if (t.finished) process.nextTick(r); else e.once("finish", r) } t.ended = true; e.writable = false } function onCorkedFinish(e, t, r) { var n = e.entry; e.entry = null; while (n) { var i = n.callback; t.pendingcb--; i(r); n = n.next } t.corkedRequestsFree.next = e } Object.defineProperty(Writable.prototype, "destroyed", { enumerable: false, get: function get() { if (this._writableState === undefined) { return false } return this._writableState.destroyed }, set: function set(e) { if (!this._writableState) { return } this._writableState.destroyed = e } }); Writable.prototype.destroy = u.destroy; Writable.prototype._undestroy = u.undestroy; Writable.prototype._destroy = function (e, t) { t(e) } }, 3306: (e, t, r) => { var n; function _defineProperty(e, t, r) { t = _toPropertyKey(t); if (t in e) { Object.defineProperty(e, t, { value: r, enumerable: true, configurable: true, writable: true }) } else { e[t] = r } return e } function _toPropertyKey(e) { var t = _toPrimitive(e, "string"); return typeof t === "symbol" ? t : String(t) } function _toPrimitive(e, t) { if (typeof e !== "object" || e === null) return e; var r = e[Symbol.toPrimitive]; if (r !== undefined) { var n = r.call(e, t || "default"); if (typeof n !== "object") return n; throw new TypeError("@@toPrimitive must return a primitive value.") } return (t === "string" ? String : Number)(e) } var i = r(6080); var s = Symbol("lastResolve"); var o = Symbol("lastReject"); var a = Symbol("error"); var u = Symbol("ended"); var l = Symbol("lastPromise"); var f = Symbol("handlePromise"); var d = Symbol("stream"); function createIterResult(e, t) { return { value: e, done: t } } function readAndResolve(e) { var t = e[s]; if (t !== null) { var r = e[d].read(); if (r !== null) { e[l] = null; e[s] = null; e[o] = null; t(createIterResult(r, false)) } } } function onReadable(e) { process.nextTick(readAndResolve, e) } function wrapForNext(e, t) { return function (r, n) { e.then((function () { if (t[u]) { r(createIterResult(undefined, true)); return } t[f](r, n) }), n) } } var p = Object.getPrototypeOf((function () { })); var h = Object.setPrototypeOf((n = { get stream() { return this[d] }, next: function next() { var e = this; var t = this[a]; if (t !== null) { return Promise.reject(t) } if (this[u]) { return Promise.resolve(createIterResult(undefined, true)) } if (this[d].destroyed) { return new Promise((function (t, r) { process.nextTick((function () { if (e[a]) { r(e[a]) } else { t(createIterResult(undefined, true)) } })) })) } var r = this[l]; var n; if (r) { n = new Promise(wrapForNext(r, this)) } else { var i = this[d].read(); if (i !== null) { return Promise.resolve(createIterResult(i, false)) } n = new Promise(this[f]) } this[l] = n; return n } }, _defineProperty(n, Symbol.asyncIterator, (function () { return this })), _defineProperty(n, "return", (function _return() { var e = this; return new Promise((function (t, r) { e[d].destroy(null, (function (e) { if (e) { r(e); return } t(createIterResult(undefined, true)) })) })) })), n), p); var m = function createReadableStreamAsyncIterator(e) { var t; var r = Object.create(h, (t = {}, _defineProperty(t, d, { value: e, writable: true }), _defineProperty(t, s, { value: null, writable: true }), _defineProperty(t, o, { value: null, writable: true }), _defineProperty(t, a, { value: null, writable: true }), _defineProperty(t, u, { value: e._readableState.endEmitted, writable: true }), _defineProperty(t, f, { value: function value(e, t) { var n = r[d].read(); if (n) { r[l] = null; r[s] = null; r[o] = null; e(createIterResult(n, false)) } else { r[s] = e; r[o] = t } }, writable: true }), t)); r[l] = null; i(e, (function (e) { if (e && e.code !== "ERR_STREAM_PREMATURE_CLOSE") { var t = r[o]; if (t !== null) { r[l] = null; r[s] = null; r[o] = null; t(e) } r[a] = e; return } var n = r[s]; if (n !== null) { r[l] = null; r[s] = null; r[o] = null; n(createIterResult(undefined, true)) } r[u] = true })); e.on("readable", onReadable.bind(null, r)); return r }; e.exports = m }, 6522: (e, t, r) => { function ownKeys(e, t) { var r = Object.keys(e); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); t && (n = n.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), r.push.apply(r, n) } return r } function _objectSpread(e) { for (var t = 1; t < arguments.length; t++) { var r = null != arguments[t] ? arguments[t] : {}; t % 2 ? ownKeys(Object(r), !0).forEach((function (t) { _defineProperty(e, t, r[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : ownKeys(Object(r)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t)) })) } return e } function _defineProperty(e, t, r) { t = _toPropertyKey(t); if (t in e) { Object.defineProperty(e, t, { value: r, enumerable: true, configurable: true, writable: true }) } else { e[t] = r } return e } function _classCallCheck(e, t) { if (!(e instanceof t)) { throw new TypeError("Cannot call a class as a function") } } function _defineProperties(e, t) { for (var r = 0; r < t.length; r++) { var n = t[r]; n.enumerable = n.enumerable || false; n.configurable = true; if ("value" in n) n.writable = true; Object.defineProperty(e, _toPropertyKey(n.key), n) } } function _createClass(e, t, r) { if (t) _defineProperties(e.prototype, t); if (r) _defineProperties(e, r); Object.defineProperty(e, "prototype", { writable: false }); return e } function _toPropertyKey(e) { var t = _toPrimitive(e, "string"); return typeof t === "symbol" ? t : String(t) } function _toPrimitive(e, t) { if (typeof e !== "object" || e === null) return e; var r = e[Symbol.toPrimitive]; if (r !== undefined) { var n = r.call(e, t || "default"); if (typeof n !== "object") return n; throw new TypeError("@@toPrimitive must return a primitive value.") } return (t === "string" ? String : Number)(e) } var n = r(4300), i = n.Buffer; var s = r(3837), o = s.inspect; var a = o && o.custom || "inspect"; function copyBuffer(e, t, r) { i.prototype.copy.call(e, t, r) } e.exports = function () { function BufferList() { _classCallCheck(this, BufferList); this.head = null; this.tail = null; this.length = 0 } _createClass(BufferList, [{ key: "push", value: function push(e) { var t = { data: e, next: null }; if (this.length > 0) this.tail.next = t; else this.head = t; this.tail = t; ++this.length } }, { key: "unshift", value: function unshift(e) { var t = { data: e, next: this.head }; if (this.length === 0) this.tail = t; this.head = t; ++this.length } }, { key: "shift", value: function shift() { if (this.length === 0) return; var e = this.head.data; if (this.length === 1) this.head = this.tail = null; else this.head = this.head.next; --this.length; return e } }, { key: "clear", value: function clear() { this.head = this.tail = null; this.length = 0 } }, { key: "join", value: function join(e) { if (this.length === 0) return ""; var t = this.head; var r = "" + t.data; while (t = t.next) r += e + t.data; return r } }, { key: "concat", value: function concat(e) { if (this.length === 0) return i.alloc(0); var t = i.allocUnsafe(e >>> 0); var r = this.head; var n = 0; while (r) { copyBuffer(r.data, t, n); n += r.data.length; r = r.next } return t } }, { key: "consume", value: function consume(e, t) { var r; if (e < this.head.data.length) { r = this.head.data.slice(0, e); this.head.data = this.head.data.slice(e) } else if (e === this.head.data.length) { r = this.shift() } else { r = t ? this._getString(e) : this._getBuffer(e) } return r } }, { key: "first", value: function first() { return this.head.data } }, { key: "_getString", value: function _getString(e) { var t = this.head; var r = 1; var n = t.data; e -= n.length; while (t = t.next) { var i = t.data; var s = e > i.length ? i.length : e; if (s === i.length) n += i; else n += i.slice(0, e); e -= s; if (e === 0) { if (s === i.length) { ++r; if (t.next) this.head = t.next; else this.head = this.tail = null } else { this.head = t; t.data = i.slice(s) } break } ++r } this.length -= r; return n } }, { key: "_getBuffer", value: function _getBuffer(e) { var t = i.allocUnsafe(e); var r = this.head; var n = 1; r.data.copy(t); e -= r.data.length; while (r = r.next) { var s = r.data; var o = e > s.length ? s.length : e; s.copy(t, t.length - e, 0, o); e -= o; if (e === 0) { if (o === s.length) { ++n; if (r.next) this.head = r.next; else this.head = this.tail = null } else { this.head = r; r.data = s.slice(o) } break } ++n } this.length -= n; return t } }, { key: a, value: function value(e, t) { return o(this, _objectSpread(_objectSpread({}, t), {}, { depth: 0, customInspect: false })) } }]); return BufferList }() }, 7049: e => { function destroy(e, t) { var r = this; var n = this._readableState && this._readableState.destroyed; var i = this._writableState && this._writableState.destroyed; if (n || i) { if (t) { t(e) } else if (e) { if (!this._writableState) { process.nextTick(emitErrorNT, this, e) } else if (!this._writableState.errorEmitted) { this._writableState.errorEmitted = true; process.nextTick(emitErrorNT, this, e) } } return this } if (this._readableState) { this._readableState.destroyed = true } if (this._writableState) { this._writableState.destroyed = true } this._destroy(e || null, (function (e) { if (!t && e) { if (!r._writableState) { process.nextTick(emitErrorAndCloseNT, r, e) } else if (!r._writableState.errorEmitted) { r._writableState.errorEmitted = true; process.nextTick(emitErrorAndCloseNT, r, e) } else { process.nextTick(emitCloseNT, r) } } else if (t) { process.nextTick(emitCloseNT, r); t(e) } else { process.nextTick(emitCloseNT, r) } })); return this } function emitErrorAndCloseNT(e, t) { emitErrorNT(e, t); emitCloseNT(e) } function emitCloseNT(e) { if (e._writableState && !e._writableState.emitClose) return; if (e._readableState && !e._readableState.emitClose) return; e.emit("close") } function undestroy() { if (this._readableState) { this._readableState.destroyed = false; this._readableState.reading = false; this._readableState.ended = false; this._readableState.endEmitted = false } if (this._writableState) { this._writableState.destroyed = false; this._writableState.ended = false; this._writableState.ending = false; this._writableState.finalCalled = false; this._writableState.prefinished = false; this._writableState.finished = false; this._writableState.errorEmitted = false } } function emitErrorNT(e, t) { e.emit("error", t) } function errorOrDestroy(e, t) { var r = e._readableState; var n = e._writableState; if (r && r.autoDestroy || n && n.autoDestroy) e.destroy(t); else e.emit("error", t) } e.exports = { destroy: destroy, undestroy: undestroy, errorOrDestroy: errorOrDestroy } }, 6080: (e, t, r) => { var n = r(7214).q.ERR_STREAM_PREMATURE_CLOSE; function once(e) { var t = false; return function () { if (t) return; t = true; for (var r = arguments.length, n = new Array(r), i = 0; i < r; i++) { n[i] = arguments[i] } e.apply(this, n) } } function noop() { } function isRequest(e) { return e.setHeader && typeof e.abort === "function" } function eos(e, t, r) { if (typeof t === "function") return eos(e, null, t); if (!t) t = {}; r = once(r || noop); var i = t.readable || t.readable !== false && e.readable; var s = t.writable || t.writable !== false && e.writable; var o = function onlegacyfinish() { if (!e.writable) u() }; var a = e._writableState && e._writableState.finished; var u = function onfinish() { s = false; a = true; if (!i) r.call(e) }; var l = e._readableState && e._readableState.endEmitted; var f = function onend() { i = false; l = true; if (!s) r.call(e) }; var d = function onerror(t) { r.call(e, t) }; var p = function onclose() { var t; if (i && !l) { if (!e._readableState || !e._readableState.ended) t = new n; return r.call(e, t) } if (s && !a) { if (!e._writableState || !e._writableState.ended) t = new n; return r.call(e, t) } }; var h = function onrequest() { e.req.on("finish", u) }; if (isRequest(e)) { e.on("complete", u); e.on("abort", p); if (e.req) h(); else e.on("request", h) } else if (s && !e._writableState) { e.on("end", o); e.on("close", o) } e.on("end", f); e.on("finish", u); if (t.error !== false) e.on("error", d); e.on("close", p); return function () { e.removeListener("complete", u); e.removeListener("abort", p); e.removeListener("request", h); if (e.req) e.req.removeListener("finish", u); e.removeListener("end", o); e.removeListener("close", o); e.removeListener("finish", u); e.removeListener("end", f); e.removeListener("error", d); e.removeListener("close", p) } } e.exports = eos }, 9082: (e, t, r) => { function asyncGeneratorStep(e, t, r, n, i, s, o) { try { var a = e[s](o); var u = a.value } catch (e) { r(e); return } if (a.done) { t(u) } else { Promise.resolve(u).then(n, i) } } function _asyncToGenerator(e) { return function () { var t = this, r = arguments; return new Promise((function (n, i) { var s = e.apply(t, r); function _next(e) { asyncGeneratorStep(s, n, i, _next, _throw, "next", e) } function _throw(e) { asyncGeneratorStep(s, n, i, _next, _throw, "throw", e) } _next(undefined) })) } } function ownKeys(e, t) { var r = Object.keys(e); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); t && (n = n.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), r.push.apply(r, n) } return r } function _objectSpread(e) { for (var t = 1; t < arguments.length; t++) { var r = null != arguments[t] ? arguments[t] : {}; t % 2 ? ownKeys(Object(r), !0).forEach((function (t) { _defineProperty(e, t, r[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : ownKeys(Object(r)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t)) })) } return e } function _defineProperty(e, t, r) { t = _toPropertyKey(t); if (t in e) { Object.defineProperty(e, t, { value: r, enumerable: true, configurable: true, writable: true }) } else { e[t] = r } return e } function _toPropertyKey(e) { var t = _toPrimitive(e, "string"); return typeof t === "symbol" ? t : String(t) } function _toPrimitive(e, t) { if (typeof e !== "object" || e === null) return e; var r = e[Symbol.toPrimitive]; if (r !== undefined) { var n = r.call(e, t || "default"); if (typeof n !== "object") return n; throw new TypeError("@@toPrimitive must return a primitive value.") } return (t === "string" ? String : Number)(e) } var n = r(7214).q.ERR_INVALID_ARG_TYPE; function from(e, t, r) { var i; if (t && typeof t.next === "function") { i = t } else if (t && t[Symbol.asyncIterator]) i = t[Symbol.asyncIterator](); else if (t && t[Symbol.iterator]) i = t[Symbol.iterator](); else throw new n("iterable", ["Iterable"], t); var s = new e(_objectSpread({ objectMode: true }, r)); var o = false; s._read = function () { if (!o) { o = true; next() } }; function next() { return _next2.apply(this, arguments) } function _next2() { _next2 = _asyncToGenerator((function* () { try { var e = yield i.next(), t = e.value, r = e.done; if (r) { s.push(null) } else if (s.push(yield t)) { next() } else { o = false } } catch (e) { s.destroy(e) } })); return _next2.apply(this, arguments) } return s } e.exports = from }, 6989: (e, t, r) => { var n; function once(e) { var t = false; return function () { if (t) return; t = true; e.apply(void 0, arguments) } } var i = r(7214).q, s = i.ERR_MISSING_ARGS, o = i.ERR_STREAM_DESTROYED; function noop(e) { if (e) throw e } function isRequest(e) { return e.setHeader && typeof e.abort === "function" } function destroyer(e, t, i, s) { s = once(s); var a = false; e.on("close", (function () { a = true })); if (n === undefined) n = r(6080); n(e, { readable: t, writable: i }, (function (e) { if (e) return s(e); a = true; s() })); var u = false; return function (t) { if (a) return; if (u) return; u = true; if (isRequest(e)) return e.abort(); if (typeof e.destroy === "function") return e.destroy(); s(t || new o("pipe")) } } function call(e) { e() } function pipe(e, t) { return e.pipe(t) } function popCallback(e) { if (!e.length) return noop; if (typeof e[e.length - 1] !== "function") return noop; return e.pop() } function pipeline() { for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) { t[r] = arguments[r] } var n = popCallback(t); if (Array.isArray(t[0])) t = t[0]; if (t.length < 2) { throw new s("streams") } var i; var o = t.map((function (e, r) { var s = r < t.length - 1; var a = r > 0; return destroyer(e, s, a, (function (e) { if (!i) i = e; if (e) o.forEach(call); if (s) return; o.forEach(call); n(i) })) })); return t.reduce(pipe) } e.exports = pipeline }, 9948: (e, t, r) => { var n = r(7214).q.ERR_INVALID_OPT_VALUE; function highWaterMarkFrom(e, t, r) { return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null } function getHighWaterMark(e, t, r, i) { var s = highWaterMarkFrom(t, i, r); if (s != null) { if (!(isFinite(s) && Math.floor(s) === s) || s < 0) { var o = i ? r : "highWaterMark"; throw new n(o, s) } return Math.floor(s) } return e.objectMode ? 16 : 16 * 1024 } e.exports = { getHighWaterMark: getHighWaterMark } }, 2387: (e, t, r) => { e.exports = r(2781) }, 1642: (e, t, r) => { var n = r(2781); if (process.env.READABLE_STREAM === "disable" && n) { e.exports = n.Readable; Object.assign(e.exports, n); e.exports.Stream = n } else { t = e.exports = r(1433); t.Stream = n || t; t.Readable = t; t.Writable = r(6993); t.Duplex = r(1359); t.Transform = r(4415); t.PassThrough = r(1542); t.finished = r(6080); t.pipeline = r(6989) } }, 6624: (e, t, r) => { const n = r(4404); e.exports = (e = {}, t = n.connect) => new Promise(((r, n) => { let i = false; let s; const callback = async () => { await o; s.off("timeout", onTimeout); s.off("error", n); if (e.resolveSocket) { r({ alpnProtocol: s.alpnProtocol, socket: s, timeout: i }); if (i) { await Promise.resolve(); s.emit("timeout") } } else { s.destroy(); r({ alpnProtocol: s.alpnProtocol, timeout: i }) } }; const onTimeout = async () => { i = true; callback() }; const o = (async () => { try { s = await t(e, callback); s.on("error", n); s.once("timeout", onTimeout) } catch (e) { n(e) } })() })) }, 8786: e => { const mimicFn = (e, t) => { for (const r of Reflect.ownKeys(t)) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)) } return e }; e.exports = mimicFn; e.exports["default"] = mimicFn }, 4536: (e, t, r) => { const n = r(8786); const i = new WeakMap; const onetime = (e, t = {}) => { if (typeof e !== "function") { throw new TypeError("Expected a function") } let r; let s = 0; const o = e.displayName || e.name || "<anonymous>"; const onetime = function (...n) { i.set(onetime, ++s); if (s === 1) { r = e.apply(this, n); e = null } else if (t.throw === true) { throw new Error(`Function \`${o}\` can only be called once`) } return r }; n(onetime, e); i.set(onetime, s); return onetime }; e.exports = onetime; e.exports["default"] = onetime; e.exports.callCount = e => { if (!i.has(e)) { throw new Error(`The given function \`${e.name}\` is not wrapped by the \`onetime\` package`) } return i.get(e) } }, 2113: e => { function reusify(e) { var t = new e; var r = t; function get() { var n = t; if (n.next) { t = n.next } else { t = new e; r = t } n.next = null; return n } function release(e) { r.next = e; r = e } return { get: get, release: release } } e.exports = reusify }, 5288: (e, t, r) => {
    /*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
    e.exports = runParallel; const n = r(9795); function runParallel(e, t) { let r, i, s; let o = true; if (Array.isArray(e)) { r = []; i = e.length } else { s = Object.keys(e); r = {}; i = s.length } function done(e) { function end() { if (t) t(e, r); t = null } if (o) n(end); else end() } function each(e, t, n) { r[e] = n; if (--i === 0 || t) { done(t) } } if (!i) { done(null) } else if (s) { s.forEach((function (t) { e[t]((function (e, r) { each(t, e, r) })) })) } else { e.forEach((function (e, t) { e((function (e, r) { each(t, e, r) })) })) } o = false }
  }, 1867: (e, t, r) => {
    /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
    var n = r(4300); var i = n.Buffer; function copyProps(e, t) { for (var r in e) { t[r] = e[r] } } if (i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow) { e.exports = n } else { copyProps(n, t); t.Buffer = SafeBuffer } function SafeBuffer(e, t, r) { return i(e, t, r) } SafeBuffer.prototype = Object.create(i.prototype); copyProps(i, SafeBuffer); SafeBuffer.from = function (e, t, r) { if (typeof e === "number") { throw new TypeError("Argument must not be a number") } return i(e, t, r) }; SafeBuffer.alloc = function (e, t, r) { if (typeof e !== "number") { throw new TypeError("Argument must be a number") } var n = i(e); if (t !== undefined) { if (typeof r === "string") { n.fill(t, r) } else { n.fill(t) } } else { n.fill(0) } return n }; SafeBuffer.allocUnsafe = function (e) { if (typeof e !== "number") { throw new TypeError("Argument must be a number") } return i(e) }; SafeBuffer.allocUnsafeSlow = function (e) { if (typeof e !== "number") { throw new TypeError("Argument must be a number") } return n.SlowBuffer(e) }
  }, 1762: (e, t, r) => { var n = r(6961); var i = r(7512); e.exports = function (e, t) { if (typeof t === "function") { t = { parse: t } } var r = toObject(e); var n = { section_delimiter: "---", parse: identity }; var s = i({}, n, t); var o = s.section_delimiter; var a = r.content.split(/\r?\n/); var u = null; var l = createSection(); var f = []; var d = []; function initSections(e) { r.content = e; u = []; f = [] } function closeSection(e) { if (d.length) { l.key = getKey(d[0], o); l.content = e; s.parse(l, u); u.push(l); l = createSection(); f = []; d = [] } } for (var p = 0; p < a.length; p++) { var h = a[p]; var m = d.length; var g = h.trim(); if (isDelimiter(g, o)) { if (g.length === 3 && p !== 0) { if (m === 0 || m === 2) { f.push(h); continue } d.push(g); l.data = f.join("\n"); f = []; continue } if (u === null) { initSections(f.join("\n")) } if (m === 2) { closeSection(f.join("\n")) } d.push(g); continue } f.push(h) } if (u === null) { initSections(f.join("\n")) } else { closeSection(f.join("\n")) } r.sections = u; return r }; function isDelimiter(e, t) { if (e.slice(0, t.length) !== t) { return false } if (e.charAt(t.length + 1) === t.slice(-1)) { return false } return true } function toObject(e) { if (n(e) !== "object") { e = { content: e } } if (typeof e.content !== "string" && !isBuffer(e.content)) { throw new TypeError("expected a buffer or string") } e.content = e.content.toString(); e.sections = []; return e } function getKey(e, t) { return e ? e.slice(t.length).trim() : "" } function createSection() { return { key: "", data: "", content: "" } } function identity(e) { return e } function isBuffer(e) { if (e && e.constructor && typeof e.constructor.isBuffer === "function") { return e.constructor.isBuffer(e) } return false } }, 7032: (e, t, r) => { const n = r(2638); e.exports = (e = "") => { const t = e.match(n); if (!t) { return null } const [r, i] = t[0].replace(/#! ?/, "").split(" "); const s = r.split("/").pop(); if (s === "env") { return i } return i ? `${s} ${i}` : s } }, 2638: e => { e.exports = /^#!(.*)/ }, 4931: (e, t, r) => { var n = global.process; const processOk = function (e) { return e && typeof e === "object" && typeof e.removeListener === "function" && typeof e.emit === "function" && typeof e.reallyExit === "function" && typeof e.listeners === "function" && typeof e.kill === "function" && typeof e.pid === "number" && typeof e.on === "function" }; if (!processOk(n)) { e.exports = function () { return function () { } } } else { var i = r(9491); var s = r(3710); var o = /^win/i.test(n.platform); var a = r(2361); if (typeof a !== "function") { a = a.EventEmitter } var u; if (n.__signal_exit_emitter__) { u = n.__signal_exit_emitter__ } else { u = n.__signal_exit_emitter__ = new a; u.count = 0; u.emitted = {} } if (!u.infinite) { u.setMaxListeners(Infinity); u.infinite = true } e.exports = function (e, t) { if (!processOk(global.process)) { return function () { } } i.equal(typeof e, "function", "a callback must be provided for exit handler"); if (p === false) { h() } var r = "exit"; if (t && t.alwaysLast) { r = "afterexit" } var remove = function () { u.removeListener(r, e); if (u.listeners("exit").length === 0 && u.listeners("afterexit").length === 0) { l() } }; u.on(r, e); return remove }; var l = function unload() { if (!p || !processOk(global.process)) { return } p = false; s.forEach((function (e) { try { n.removeListener(e, d[e]) } catch (e) { } })); n.emit = y; n.reallyExit = m; u.count -= 1 }; e.exports.unload = l; var f = function emit(e, t, r) { if (u.emitted[e]) { return } u.emitted[e] = true; u.emit(e, t, r) }; var d = {}; s.forEach((function (e) { d[e] = function listener() { if (!processOk(global.process)) { return } var t = n.listeners(e); if (t.length === u.count) { l(); f("exit", null, e); f("afterexit", null, e); if (o && e === "SIGHUP") { e = "SIGINT" } n.kill(n.pid, e) } } })); e.exports.signals = function () { return s }; var p = false; var h = function load() { if (p || !processOk(global.process)) { return } p = true; u.count += 1; s = s.filter((function (e) { try { n.on(e, d[e]); return true } catch (e) { return false } })); n.emit = b; n.reallyExit = g }; e.exports.load = h; var m = n.reallyExit; var g = function processReallyExit(e) { if (!processOk(global.process)) { return } n.exitCode = e || 0; f("exit", n.exitCode, null); f("afterexit", n.exitCode, null); m.call(n, n.exitCode) }; var y = n.emit; var b = function processEmit(e, t) { if (e === "exit" && processOk(global.process)) { if (t !== undefined) { n.exitCode = t } var r = y.apply(this, arguments); f("exit", n.exitCode, null); f("afterexit", n.exitCode, null); return r } else { return y.apply(this, arguments) } } } }, 3710: e => { e.exports = ["SIGABRT", "SIGALRM", "SIGHUP", "SIGINT", "SIGTERM"]; if (process.platform !== "win32") { e.exports.push("SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT") } if (process.platform === "linux") { e.exports.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT", "SIGUNUSED") } }, 2931: (e, t, r) => { const n = r(4882); const i = r(8287); const s = r(2068); const o = ["", ""]; const wrapAnsi = e => `${o[0]}[${e}m`; const checkAnsi = (e, t, r) => { let n = []; e = [...e]; for (let r of e) { const i = r; if (r.includes(";")) { r = r.split(";")[0][0] + "0" } const o = s.codes.get(Number.parseInt(r, 10)); if (o) { const r = e.indexOf(o.toString()); if (r === -1) { n.push(wrapAnsi(t ? o : i)) } else { e.splice(r, 1) } } else if (t) { n.push(wrapAnsi(0)); break } else { n.push(wrapAnsi(i)) } } if (t) { n = n.filter(((e, t) => n.indexOf(e) === t)); if (r !== undefined) { const e = wrapAnsi(s.codes.get(Number.parseInt(r, 10))); n = n.reduce(((t, r) => r === e ? [r, ...t] : [...t, r]), []) } } return n.join("") }; e.exports = (e, t, r) => { const s = [...e]; const a = []; let u = typeof r === "number" ? r : s.length; let l = false; let f; let d = 0; let p = ""; for (const [h, m] of s.entries()) { let s = false; if (o.includes(m)) { const t = /\d[^m]*/.exec(e.slice(h, h + 18)); f = t && t.length > 0 ? t[0] : undefined; if (d < u) { l = true; if (f !== undefined) { a.push(f) } } } else if (l && m === "m") { l = false; s = true } if (!l && !s) { d++ } if (!i({ exact: true }).test(m) && n(m.codePointAt())) { d++; if (typeof r !== "number") { u++ } } if (d > t && d <= u) { p += m } else if (d === t && !l && f !== undefined) { p = checkAnsi(a) } else if (d >= u) { p += checkAnsi(a, true, f); break } } return p } }, 9481: function (e) { (function (t, r, n) { if (true) { e.exports = n(); e.exports["default"] = n() } else { } })("slugify", this, (function () { var e = JSON.parse('{"$":"dollar","%":"percent","&":"and","<":"less",">":"greater","|":"or","¢":"cent","£":"pound","¤":"currency","¥":"yen","©":"(c)","ª":"a","®":"(r)","º":"o","À":"A","Á":"A","Â":"A","Ã":"A","Ä":"A","Å":"A","Æ":"AE","Ç":"C","È":"E","É":"E","Ê":"E","Ë":"E","Ì":"I","Í":"I","Î":"I","Ï":"I","Ð":"D","Ñ":"N","Ò":"O","Ó":"O","Ô":"O","Õ":"O","Ö":"O","Ø":"O","Ù":"U","Ú":"U","Û":"U","Ü":"U","Ý":"Y","Þ":"TH","ß":"ss","à":"a","á":"a","â":"a","ã":"a","ä":"a","å":"a","æ":"ae","ç":"c","è":"e","é":"e","ê":"e","ë":"e","ì":"i","í":"i","î":"i","ï":"i","ð":"d","ñ":"n","ò":"o","ó":"o","ô":"o","õ":"o","ö":"o","ø":"o","ù":"u","ú":"u","û":"u","ü":"u","ý":"y","þ":"th","ÿ":"y","Ā":"A","ā":"a","Ă":"A","ă":"a","Ą":"A","ą":"a","Ć":"C","ć":"c","Č":"C","č":"c","Ď":"D","ď":"d","Đ":"DJ","đ":"dj","Ē":"E","ē":"e","Ė":"E","ė":"e","Ę":"e","ę":"e","Ě":"E","ě":"e","Ğ":"G","ğ":"g","Ģ":"G","ģ":"g","Ĩ":"I","ĩ":"i","Ī":"i","ī":"i","Į":"I","į":"i","İ":"I","ı":"i","Ķ":"k","ķ":"k","Ļ":"L","ļ":"l","Ľ":"L","ľ":"l","Ł":"L","ł":"l","Ń":"N","ń":"n","Ņ":"N","ņ":"n","Ň":"N","ň":"n","Ō":"O","ō":"o","Ő":"O","ő":"o","Œ":"OE","œ":"oe","Ŕ":"R","ŕ":"r","Ř":"R","ř":"r","Ś":"S","ś":"s","Ş":"S","ş":"s","Š":"S","š":"s","Ţ":"T","ţ":"t","Ť":"T","ť":"t","Ũ":"U","ũ":"u","Ū":"u","ū":"u","Ů":"U","ů":"u","Ű":"U","ű":"u","Ų":"U","ų":"u","Ŵ":"W","ŵ":"w","Ŷ":"Y","ŷ":"y","Ÿ":"Y","Ź":"Z","ź":"z","Ż":"Z","ż":"z","Ž":"Z","ž":"z","Ə":"E","ƒ":"f","Ơ":"O","ơ":"o","Ư":"U","ư":"u","ǈ":"LJ","ǉ":"lj","ǋ":"NJ","ǌ":"nj","Ș":"S","ș":"s","Ț":"T","ț":"t","ə":"e","˚":"o","Ά":"A","Έ":"E","Ή":"H","Ί":"I","Ό":"O","Ύ":"Y","Ώ":"W","ΐ":"i","Α":"A","Β":"B","Γ":"G","Δ":"D","Ε":"E","Ζ":"Z","Η":"H","Θ":"8","Ι":"I","Κ":"K","Λ":"L","Μ":"M","Ν":"N","Ξ":"3","Ο":"O","Π":"P","Ρ":"R","Σ":"S","Τ":"T","Υ":"Y","Φ":"F","Χ":"X","Ψ":"PS","Ω":"W","Ϊ":"I","Ϋ":"Y","ά":"a","έ":"e","ή":"h","ί":"i","ΰ":"y","α":"a","β":"b","γ":"g","δ":"d","ε":"e","ζ":"z","η":"h","θ":"8","ι":"i","κ":"k","λ":"l","μ":"m","ν":"n","ξ":"3","ο":"o","π":"p","ρ":"r","ς":"s","σ":"s","τ":"t","υ":"y","φ":"f","χ":"x","ψ":"ps","ω":"w","ϊ":"i","ϋ":"y","ό":"o","ύ":"y","ώ":"w","Ё":"Yo","Ђ":"DJ","Є":"Ye","І":"I","Ї":"Yi","Ј":"J","Љ":"LJ","Њ":"NJ","Ћ":"C","Џ":"DZ","А":"A","Б":"B","В":"V","Г":"G","Д":"D","Е":"E","Ж":"Zh","З":"Z","И":"I","Й":"J","К":"K","Л":"L","М":"M","Н":"N","О":"O","П":"P","Р":"R","С":"S","Т":"T","У":"U","Ф":"F","Х":"H","Ц":"C","Ч":"Ch","Ш":"Sh","Щ":"Sh","Ъ":"U","Ы":"Y","Ь":"","Э":"E","Ю":"Yu","Я":"Ya","а":"a","б":"b","в":"v","г":"g","д":"d","е":"e","ж":"zh","з":"z","и":"i","й":"j","к":"k","л":"l","м":"m","н":"n","о":"o","п":"p","р":"r","с":"s","т":"t","у":"u","ф":"f","х":"h","ц":"c","ч":"ch","ш":"sh","щ":"sh","ъ":"u","ы":"y","ь":"","э":"e","ю":"yu","я":"ya","ё":"yo","ђ":"dj","є":"ye","і":"i","ї":"yi","ј":"j","љ":"lj","њ":"nj","ћ":"c","ѝ":"u","џ":"dz","Ґ":"G","ґ":"g","Ғ":"GH","ғ":"gh","Қ":"KH","қ":"kh","Ң":"NG","ң":"ng","Ү":"UE","ү":"ue","Ұ":"U","ұ":"u","Һ":"H","һ":"h","Ә":"AE","ә":"ae","Ө":"OE","ө":"oe","Ա":"A","Բ":"B","Գ":"G","Դ":"D","Ե":"E","Զ":"Z","Է":"E\'","Ը":"Y\'","Թ":"T\'","Ժ":"JH","Ի":"I","Լ":"L","Խ":"X","Ծ":"C\'","Կ":"K","Հ":"H","Ձ":"D\'","Ղ":"GH","Ճ":"TW","Մ":"M","Յ":"Y","Ն":"N","Շ":"SH","Չ":"CH","Պ":"P","Ջ":"J","Ռ":"R\'","Ս":"S","Վ":"V","Տ":"T","Ր":"R","Ց":"C","Փ":"P\'","Ք":"Q\'","Օ":"O\'\'","Ֆ":"F","և":"EV","ء":"a","آ":"aa","أ":"a","ؤ":"u","إ":"i","ئ":"e","ا":"a","ب":"b","ة":"h","ت":"t","ث":"th","ج":"j","ح":"h","خ":"kh","د":"d","ذ":"th","ر":"r","ز":"z","س":"s","ش":"sh","ص":"s","ض":"dh","ط":"t","ظ":"z","ع":"a","غ":"gh","ف":"f","ق":"q","ك":"k","ل":"l","م":"m","ن":"n","ه":"h","و":"w","ى":"a","ي":"y","ً":"an","ٌ":"on","ٍ":"en","َ":"a","ُ":"u","ِ":"e","ْ":"","٠":"0","١":"1","٢":"2","٣":"3","٤":"4","٥":"5","٦":"6","٧":"7","٨":"8","٩":"9","پ":"p","چ":"ch","ژ":"zh","ک":"k","گ":"g","ی":"y","۰":"0","۱":"1","۲":"2","۳":"3","۴":"4","۵":"5","۶":"6","۷":"7","۸":"8","۹":"9","฿":"baht","ა":"a","ბ":"b","გ":"g","დ":"d","ე":"e","ვ":"v","ზ":"z","თ":"t","ი":"i","კ":"k","ლ":"l","მ":"m","ნ":"n","ო":"o","პ":"p","ჟ":"zh","რ":"r","ს":"s","ტ":"t","უ":"u","ფ":"f","ქ":"k","ღ":"gh","ყ":"q","შ":"sh","ჩ":"ch","ც":"ts","ძ":"dz","წ":"ts","ჭ":"ch","ხ":"kh","ჯ":"j","ჰ":"h","Ṣ":"S","ṣ":"s","Ẁ":"W","ẁ":"w","Ẃ":"W","ẃ":"w","Ẅ":"W","ẅ":"w","ẞ":"SS","Ạ":"A","ạ":"a","Ả":"A","ả":"a","Ấ":"A","ấ":"a","Ầ":"A","ầ":"a","Ẩ":"A","ẩ":"a","Ẫ":"A","ẫ":"a","Ậ":"A","ậ":"a","Ắ":"A","ắ":"a","Ằ":"A","ằ":"a","Ẳ":"A","ẳ":"a","Ẵ":"A","ẵ":"a","Ặ":"A","ặ":"a","Ẹ":"E","ẹ":"e","Ẻ":"E","ẻ":"e","Ẽ":"E","ẽ":"e","Ế":"E","ế":"e","Ề":"E","ề":"e","Ể":"E","ể":"e","Ễ":"E","ễ":"e","Ệ":"E","ệ":"e","Ỉ":"I","ỉ":"i","Ị":"I","ị":"i","Ọ":"O","ọ":"o","Ỏ":"O","ỏ":"o","Ố":"O","ố":"o","Ồ":"O","ồ":"o","Ổ":"O","ổ":"o","Ỗ":"O","ỗ":"o","Ộ":"O","ộ":"o","Ớ":"O","ớ":"o","Ờ":"O","ờ":"o","Ở":"O","ở":"o","Ỡ":"O","ỡ":"o","Ợ":"O","ợ":"o","Ụ":"U","ụ":"u","Ủ":"U","ủ":"u","Ứ":"U","ứ":"u","Ừ":"U","ừ":"u","Ử":"U","ử":"u","Ữ":"U","ữ":"u","Ự":"U","ự":"u","Ỳ":"Y","ỳ":"y","Ỵ":"Y","ỵ":"y","Ỷ":"Y","ỷ":"y","Ỹ":"Y","ỹ":"y","–":"-","‘":"\'","’":"\'","“":"\\"","”":"\\"","„":"\\"","†":"+","•":"*","…":"...","₠":"ecu","₢":"cruzeiro","₣":"french franc","₤":"lira","₥":"mill","₦":"naira","₧":"peseta","₨":"rupee","₩":"won","₪":"new shequel","₫":"dong","€":"euro","₭":"kip","₮":"tugrik","₯":"drachma","₰":"penny","₱":"peso","₲":"guarani","₳":"austral","₴":"hryvnia","₵":"cedi","₸":"kazakhstani tenge","₹":"indian rupee","₺":"turkish lira","₽":"russian ruble","₿":"bitcoin","℠":"sm","™":"tm","∂":"d","∆":"delta","∑":"sum","∞":"infinity","♥":"love","元":"yuan","円":"yen","﷼":"rial","ﻵ":"laa","ﻷ":"laa","ﻹ":"lai","ﻻ":"la"}'); var t = JSON.parse('{"bg":{"Й":"Y","Ц":"Ts","Щ":"Sht","Ъ":"A","Ь":"Y","й":"y","ц":"ts","щ":"sht","ъ":"a","ь":"y"},"de":{"Ä":"AE","ä":"ae","Ö":"OE","ö":"oe","Ü":"UE","ü":"ue","ß":"ss","%":"prozent","&":"und","|":"oder","∑":"summe","∞":"unendlich","♥":"liebe"},"es":{"%":"por ciento","&":"y","<":"menor que",">":"mayor que","|":"o","¢":"centavos","£":"libras","¤":"moneda","₣":"francos","∑":"suma","∞":"infinito","♥":"amor"},"fr":{"%":"pourcent","&":"et","<":"plus petit",">":"plus grand","|":"ou","¢":"centime","£":"livre","¤":"devise","₣":"franc","∑":"somme","∞":"infini","♥":"amour"},"pt":{"%":"porcento","&":"e","<":"menor",">":"maior","|":"ou","¢":"centavo","∑":"soma","£":"libra","∞":"infinito","♥":"amor"},"uk":{"И":"Y","и":"y","Й":"Y","й":"y","Ц":"Ts","ц":"ts","Х":"Kh","х":"kh","Щ":"Shch","щ":"shch","Г":"H","г":"h"},"vi":{"Đ":"D","đ":"d"},"da":{"Ø":"OE","ø":"oe","Å":"AA","å":"aa","%":"procent","&":"og","|":"eller","$":"dollar","<":"mindre end",">":"større end"},"nb":{"&":"og","Å":"AA","Æ":"AE","Ø":"OE","å":"aa","æ":"ae","ø":"oe"},"it":{"&":"e"},"nl":{"&":"en"},"sv":{"&":"och","Å":"AA","Ä":"AE","Ö":"OE","å":"aa","ä":"ae","ö":"oe"}}'); function replace(r, n) { if (typeof r !== "string") { throw new Error("slugify: string argument expected") } n = typeof n === "string" ? { replacement: n } : n || {}; var i = t[n.locale] || {}; var s = n.replacement === undefined ? "-" : n.replacement; var o = n.trim === undefined ? true : n.trim; var a = r.normalize().split("").reduce((function (t, r) { var o = i[r]; if (o === undefined) o = e[r]; if (o === undefined) o = r; if (o === s) o = " "; return t + o.replace(n.remove || /[^\w\s$*_+~.()'"!\-:@]+/g, "") }), ""); if (n.strict) { a = a.replace(/[^A-Za-z0-9\s]/g, "") } if (o) { a = a.trim() } a = a.replace(/\s+/g, s); if (n.lower) { a = a.toLowerCase() } return a } replace.extend = function (t) { Object.assign(e, t) }; return replace })) }, 2577: (e, t, r) => { const n = r(3520); const i = r(4882); const s = r(8212); const stringWidth = e => { if (typeof e !== "string" || e.length === 0) { return 0 } e = n(e); if (e.length === 0) { return 0 } e = e.replace(s(), "  "); let t = 0; for (let r = 0; r < e.length; r++) { const n = e.codePointAt(r); if (n <= 31 || n >= 127 && n <= 159) { continue } if (n >= 768 && n <= 879) { continue } if (n > 65535) { r++ } t += i(n) ? 2 : 1 } return t }; e.exports = stringWidth; e.exports["default"] = stringWidth }, 9139: e => { e.exports = ({ onlyFirst: e = false } = {}) => { const t = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|"); return new RegExp(t, e ? undefined : "g") } }, 3520: (e, t, r) => { const n = r(9139); e.exports = e => typeof e === "string" ? e.replace(n(), "") : e }, 4841: (e, t, r) => { var n = r(1867).Buffer; var i = n.isEncoding || function (e) { e = "" + e; switch (e && e.toLowerCase()) { case "hex": case "utf8": case "utf-8": case "ascii": case "binary": case "base64": case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": case "raw": return true; default: return false } }; function _normalizeEncoding(e) { if (!e) return "utf8"; var t; while (true) { switch (e) { case "utf8": case "utf-8": return "utf8"; case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return "utf16le"; case "latin1": case "binary": return "latin1"; case "base64": case "ascii": case "hex": return e; default: if (t) return; e = ("" + e).toLowerCase(); t = true } } } function normalizeEncoding(e) { var t = _normalizeEncoding(e); if (typeof t !== "string" && (n.isEncoding === i || !i(e))) throw new Error("Unknown encoding: " + e); return t || e } t.s = StringDecoder; function StringDecoder(e) { this.encoding = normalizeEncoding(e); var t; switch (this.encoding) { case "utf16le": this.text = utf16Text; this.end = utf16End; t = 4; break; case "utf8": this.fillLast = utf8FillLast; t = 4; break; case "base64": this.text = base64Text; this.end = base64End; t = 3; break; default: this.write = simpleWrite; this.end = simpleEnd; return }this.lastNeed = 0; this.lastTotal = 0; this.lastChar = n.allocUnsafe(t) } StringDecoder.prototype.write = function (e) { if (e.length === 0) return ""; var t; var r; if (this.lastNeed) { t = this.fillLast(e); if (t === undefined) return ""; r = this.lastNeed; this.lastNeed = 0 } else { r = 0 } if (r < e.length) return t ? t + this.text(e, r) : this.text(e, r); return t || "" }; StringDecoder.prototype.end = utf8End; StringDecoder.prototype.text = utf8Text; StringDecoder.prototype.fillLast = function (e) { if (this.lastNeed <= e.length) { e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed); return this.lastChar.toString(this.encoding, 0, this.lastTotal) } e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e.length); this.lastNeed -= e.length }; function utf8CheckByte(e) { if (e <= 127) return 0; else if (e >> 5 === 6) return 2; else if (e >> 4 === 14) return 3; else if (e >> 3 === 30) return 4; return e >> 6 === 2 ? -1 : -2 } function utf8CheckIncomplete(e, t, r) { var n = t.length - 1; if (n < r) return 0; var i = utf8CheckByte(t[n]); if (i >= 0) { if (i > 0) e.lastNeed = i - 1; return i } if (--n < r || i === -2) return 0; i = utf8CheckByte(t[n]); if (i >= 0) { if (i > 0) e.lastNeed = i - 2; return i } if (--n < r || i === -2) return 0; i = utf8CheckByte(t[n]); if (i >= 0) { if (i > 0) { if (i === 2) i = 0; else e.lastNeed = i - 3 } return i } return 0 } function utf8CheckExtraBytes(e, t, r) { if ((t[0] & 192) !== 128) { e.lastNeed = 0; return "�" } if (e.lastNeed > 1 && t.length > 1) { if ((t[1] & 192) !== 128) { e.lastNeed = 1; return "�" } if (e.lastNeed > 2 && t.length > 2) { if ((t[2] & 192) !== 128) { e.lastNeed = 2; return "�" } } } } function utf8FillLast(e) { var t = this.lastTotal - this.lastNeed; var r = utf8CheckExtraBytes(this, e, t); if (r !== undefined) return r; if (this.lastNeed <= e.length) { e.copy(this.lastChar, t, 0, this.lastNeed); return this.lastChar.toString(this.encoding, 0, this.lastTotal) } e.copy(this.lastChar, t, 0, e.length); this.lastNeed -= e.length } function utf8Text(e, t) { var r = utf8CheckIncomplete(this, e, t); if (!this.lastNeed) return e.toString("utf8", t); this.lastTotal = r; var n = e.length - (r - this.lastNeed); e.copy(this.lastChar, 0, n); return e.toString("utf8", t, n) } function utf8End(e) { var t = e && e.length ? this.write(e) : ""; if (this.lastNeed) return t + "�"; return t } function utf16Text(e, t) { if ((e.length - t) % 2 === 0) { var r = e.toString("utf16le", t); if (r) { var n = r.charCodeAt(r.length - 1); if (n >= 55296 && n <= 56319) { this.lastNeed = 2; this.lastTotal = 4; this.lastChar[0] = e[e.length - 2]; this.lastChar[1] = e[e.length - 1]; return r.slice(0, -1) } } return r } this.lastNeed = 1; this.lastTotal = 2; this.lastChar[0] = e[e.length - 1]; return e.toString("utf16le", t, e.length - 1) } function utf16End(e) { var t = e && e.length ? this.write(e) : ""; if (this.lastNeed) { var r = this.lastTotal - this.lastNeed; return t + this.lastChar.toString("utf16le", 0, r) } return t } function base64Text(e, t) { var r = (e.length - t) % 3; if (r === 0) return e.toString("base64", t); this.lastNeed = 3 - r; this.lastTotal = 3; if (r === 1) { this.lastChar[0] = e[e.length - 1] } else { this.lastChar[0] = e[e.length - 2]; this.lastChar[1] = e[e.length - 1] } return e.toString("base64", t, e.length - r) } function base64End(e) { var t = e && e.length ? this.write(e) : ""; if (this.lastNeed) return t + this.lastChar.toString("base64", 0, 3 - this.lastNeed); return t } function simpleWrite(e) { return e.toString(this.encoding) } function simpleEnd(e) { return e && e.length ? this.write(e) : "" } }, 6550: e => {
    /*!
     * strip-bom-string <https://github.com/jonschlinkert/strip-bom-string>
     *
     * Copyright (c) 2015, 2017, Jon Schlinkert.
     * Released under the MIT License.
     */
    e.exports = function (e) { if (typeof e === "string" && e.charAt(0) === "\ufeff") { return e.slice(1) } return e }
  }, 9318: (e, t, r) => { const n = r(2037); const i = r(6224); const s = r(1621); const { env: o } = process; let a; if (s("no-color") || s("no-colors") || s("color=false") || s("color=never")) { a = 0 } else if (s("color") || s("colors") || s("color=true") || s("color=always")) { a = 1 } if ("FORCE_COLOR" in o) { if (o.FORCE_COLOR === "true") { a = 1 } else if (o.FORCE_COLOR === "false") { a = 0 } else { a = o.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(o.FORCE_COLOR, 10), 3) } } function translateLevel(e) { if (e === 0) { return false } return { level: e, hasBasic: true, has256: e >= 2, has16m: e >= 3 } } function supportsColor(e, t) { if (a === 0) { return 0 } if (s("color=16m") || s("color=full") || s("color=truecolor")) { return 3 } if (s("color=256")) { return 2 } if (e && !t && a === undefined) { return 0 } const r = a || 0; if (o.TERM === "dumb") { return r } if (process.platform === "win32") { const e = n.release().split("."); if (Number(e[0]) >= 10 && Number(e[2]) >= 10586) { return Number(e[2]) >= 14931 ? 3 : 2 } return 1 } if ("CI" in o) { if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((e => e in o)) || o.CI_NAME === "codeship") { return 1 } return r } if ("TEAMCITY_VERSION" in o) { return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(o.TEAMCITY_VERSION) ? 1 : 0 } if (o.COLORTERM === "truecolor") { return 3 } if ("TERM_PROGRAM" in o) { const e = parseInt((o.TERM_PROGRAM_VERSION || "").split(".")[0], 10); switch (o.TERM_PROGRAM) { case "iTerm.app": return e >= 3 ? 3 : 2; case "Apple_Terminal": return 2 } } if (/-256(color)?$/i.test(o.TERM)) { return 2 } if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(o.TERM)) { return 1 } if ("COLORTERM" in o) { return 1 } return r } function getSupportLevel(e) { const t = supportsColor(e, e && e.isTTY); return translateLevel(t) } e.exports = { supportsColor: getSupportLevel, stdout: translateLevel(supportsColor(true, i.isatty(1))), stderr: translateLevel(supportsColor(true, i.isatty(2))) } }, 9556: function (e, t, r) { var n = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: true }); t.alignVerticalRangeContent = t.wrapRangeContent = void 0; const i = n(r(2577)); const s = r(8118); const o = r(9156); const a = r(1285); const u = r(134); const l = r(6500); const f = r(3442); const wrapRangeContent = (e, t, r) => { const { topLeft: n, paddingRight: i, paddingLeft: o, truncate: l, wrapWord: d, alignment: p } = e; const h = r.rows[n.row][n.col]; const m = t - o - i; return (0, f.wrapCell)((0, u.truncateString)(h, l), m, d).map((e => { const t = (0, s.alignString)(e, m, p); return (0, a.padString)(t, o, i) })) }; t.wrapRangeContent = wrapRangeContent; const alignVerticalRangeContent = (e, t, r) => { const { rows: n, drawHorizontalLine: s, rowHeights: a } = r; const { topLeft: u, bottomRight: f, verticalAlignment: d } = e; if (a.length === 0) { return [] } const p = (0, l.sumArray)(a.slice(u.row, f.row + 1)); const h = f.row - u.row; const m = (0, l.sequence)(u.row + 1, f.row).filter((e => !s(e, n.length))).length; const g = p + h - m; return (0, o.padCellVertically)(t, g, d).map((e => { if (e.length === 0) { return " ".repeat((0, i.default)(t[0])) } return e })) }; t.alignVerticalRangeContent = alignVerticalRangeContent }, 8118: function (e, t, r) { var n = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: true }); t.alignString = void 0; const i = n(r(2577)); const s = r(6500); const alignLeft = (e, t) => e + " ".repeat(t); const alignRight = (e, t) => " ".repeat(t) + e; const alignCenter = (e, t) => " ".repeat(Math.floor(t / 2)) + e + " ".repeat(Math.ceil(t / 2)); const alignJustify = (e, t) => { const r = (0, s.countSpaceSequence)(e); if (r === 0) { return alignLeft(e, t) } const n = (0, s.distributeUnevenly)(t, r); if (Math.max(...n) > 3) { return alignLeft(e, t) } let i = 0; return e.replace(/\s+/g, (e => e + " ".repeat(n[i++]))) }; const alignString = (e, t, r) => { const n = (0, i.default)(e); if (n === t) { return e } if (n > t) { throw new Error("Subject parameter value width cannot be greater than the container width.") } if (n === 0) { return " ".repeat(t) } const s = t - n; if (r === "left") { return alignLeft(e, s) } if (r === "right") { return alignRight(e, s) } if (r === "justify") { return alignJustify(e, s) } return alignCenter(e, s) }; t.alignString = alignString }, 8439: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t.alignTableData = void 0; const n = r(8118); const alignTableData = (e, t) => e.map(((e, r) => e.map(((e, i) => { var s; const { width: o, alignment: a } = t.columns[i]; const u = (s = t.spanningCellManager) === null || s === void 0 ? void 0 : s.getContainingRange({ col: i, row: r }, { mapped: true }); if (u) { return e } return (0, n.alignString)(e, o, a) })))); t.alignTableData = alignTableData }, 6891: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t.calculateCellHeight = void 0; const n = r(3442); const calculateCellHeight = (e, t, r = false) => (0, n.wrapCell)(e, t, r).length; t.calculateCellHeight = calculateCellHeight }, 1605: function (e, t, r) { var n = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: true }); t.calculateMaximumColumnWidths = t.calculateMaximumCellWidth = void 0; const i = n(r(2577)); const s = r(6500); const calculateMaximumCellWidth = e => Math.max(...e.split("\n").map(i.default)); t.calculateMaximumCellWidth = calculateMaximumCellWidth; const calculateMaximumColumnWidths = (e, r = []) => { const n = new Array(e[0].length).fill(0); const i = r.map(s.calculateRangeCoordinate); const isSpanningCell = (e, t) => i.some((r => (0, s.isCellInRange)({ col: t, row: e }, r))); e.forEach(((e, r) => { e.forEach(((e, i) => { if (isSpanningCell(r, i)) { return } n[i] = Math.max(n[i], (0, t.calculateMaximumCellWidth)(e)) })) })); return n }; t.calculateMaximumColumnWidths = calculateMaximumColumnWidths }, 4197: (e, t) => { Object.defineProperty(t, "__esModule", { value: true }); t.calculateOutputColumnWidths = void 0; const calculateOutputColumnWidths = e => e.columns.map((e => e.paddingLeft + e.width + e.paddingRight)); t.calculateOutputColumnWidths = calculateOutputColumnWidths }, 5358: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t.calculateRowHeights = void 0; const n = r(6891); const i = r(6500); const calculateRowHeights = (e, t) => { const r = []; for (const [s, o] of e.entries()) { let a = 1; o.forEach(((o, u) => { var l; const f = (l = t.spanningCellManager) === null || l === void 0 ? void 0 : l.getContainingRange({ col: u, row: s }); if (!f) { const e = (0, n.calculateCellHeight)(o, t.columns[u].width, t.columns[u].wrapWord); a = Math.max(a, e); return } const { topLeft: d, bottomRight: p, height: h } = f; if (s === p.row) { const n = (0, i.sumArray)(r.slice(d.row)); const s = p.row - d.row; const o = (0, i.sequence)(d.row + 1, p.row).filter((r => { var n; return !((n = t.drawHorizontalLine) === null || n === void 0 ? void 0 : n.call(t, r, e.length)) })).length; const u = h - n - s + o; a = Math.max(a, u) } })); r.push(a) } return r }; t.calculateRowHeights = calculateRowHeights }, 1102: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t.calculateSpanningCellWidth = void 0; const n = r(6500); const calculateSpanningCellWidth = (e, t) => { const { columnsConfig: r, drawVerticalLine: i } = t; const { topLeft: s, bottomRight: o } = e; const a = (0, n.sumArray)(r.slice(s.col, o.col + 1).map((({ width: e }) => e))); const u = s.col === o.col ? r[s.col].paddingRight + r[o.col].paddingLeft : (0, n.sumArray)(r.slice(s.col, o.col + 1).map((({ paddingLeft: e, paddingRight: t }) => e + t))); const l = o.col - s.col; const f = (0, n.sequence)(s.col + 1, o.col).filter((e => !i(e, r.length))).length; return a + u + l - f }; t.calculateSpanningCellWidth = calculateSpanningCellWidth }, 7627: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t.createStream = void 0; const n = r(8439); const i = r(5358); const s = r(2523); const o = r(9885); const a = r(7922); const u = r(9156); const l = r(1285); const f = r(4969); const d = r(134); const p = r(6500); const prepareData = (e, t) => { let r = (0, f.stringifyTableData)(e); r = (0, d.truncateTableData)(r, (0, p.extractTruncates)(t)); const s = (0, i.calculateRowHeights)(r, t); r = (0, u.mapDataUsingRowHeights)(r, s, t); r = (0, n.alignTableData)(r, t); r = (0, l.padTableData)(r, t); return r }; const create = (e, t, r) => { const n = prepareData([e], r); const i = n.map((e => (0, o.drawRow)(e, r))).join(""); let a; a = ""; a += (0, s.drawBorderTop)(t, r); a += i; a += (0, s.drawBorderBottom)(t, r); a = a.trimEnd(); process.stdout.write(a) }; const append = (e, t, r) => { const n = prepareData([e], r); const i = n.map((e => (0, o.drawRow)(e, r))).join(""); let a = ""; const u = (0, s.drawBorderBottom)(t, r); if (u !== "\n") { a = "\r[K" } a += (0, s.drawBorderJoin)(t, r); a += i; a += u; a = a.trimEnd(); process.stdout.write(a) }; const createStream = e => { const t = (0, a.makeStreamConfig)(e); const r = Object.values(t.columns).map((e => e.width + e.paddingLeft + e.paddingRight)); let n = true; return { write: e => { if (e.length !== t.columnCount) { throw new Error("Row cell count does not match the config.columnCount.") } if (n) { n = false; create(e, r, t) } else { append(e, r, t) } } } }; t.createStream = createStream }, 2523: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t.createTableBorderGetter = t.drawBorderBottom = t.drawBorderJoin = t.drawBorderTop = t.drawBorder = t.createSeparatorGetter = t.drawBorderSegments = void 0; const n = r(2019); const drawBorderSegments = (e, t) => { const { separator: r, horizontalBorderIndex: n, spanningCellManager: i } = t; return e.map(((e, t) => { const s = r.body.repeat(e); if (n === undefined) { return s } const o = i === null || i === void 0 ? void 0 : i.getContainingRange({ col: t, row: n }); if (!o) { return s } const { topLeft: a } = o; if (n === a.row) { return s } if (t !== a.col) { return "" } return o.extractBorderContent(n) })) }; t.drawBorderSegments = drawBorderSegments; const createSeparatorGetter = e => { const { separator: t, spanningCellManager: r, horizontalBorderIndex: n, rowCount: i } = e; return (e, s) => { const o = r === null || r === void 0 ? void 0 : r.inSameRange; if (n !== undefined && o) { const r = { col: e, row: n - 1 }; const a = { col: e - 1, row: n }; const u = { col: e - 1, row: n - 1 }; const l = { col: e, row: n }; const f = [[u, r], [r, l], [l, a], [a, u]]; if (e === 0) { if (o(l, r) && t.bodyJoinOuter) { return t.bodyJoinOuter } return t.left } if (e === s) { if (o(u, a) && t.bodyJoinOuter) { return t.bodyJoinOuter } return t.right } if (n === 0) { if (o(l, a)) { return t.body } return t.join } if (n === i) { if (o(r, u)) { return t.body } return t.join } const d = f.map((e => o(...e))).filter(Boolean).length; if (d === 0) { return t.join } if (d === 4) { return "" } if (d === 2) { if (o(...f[1]) && o(...f[3]) && t.bodyJoinInner) { return t.bodyJoinInner } return t.body } if (d === 1) { if (!t.joinRight || !t.joinLeft || !t.joinUp || !t.joinDown) { throw new Error(`Can not get border separator for position [${n}, ${e}]`) } if (o(...f[0])) { return t.joinDown } if (o(...f[1])) { return t.joinLeft } if (o(...f[2])) { return t.joinUp } return t.joinRight } throw new Error("Invalid case") } if (e === 0) { return t.left } if (e === s) { return t.right } return t.join } }; t.createSeparatorGetter = createSeparatorGetter; const drawBorder = (e, r) => { const i = (0, t.drawBorderSegments)(e, r); const { drawVerticalLine: s, horizontalBorderIndex: o, spanningCellManager: a } = r; return (0, n.drawContent)({ contents: i, drawSeparator: s, elementType: "border", rowIndex: o, separatorGetter: (0, t.createSeparatorGetter)(r), spanningCellManager: a }) + "\n" }; t.drawBorder = drawBorder; const drawBorderTop = (e, r) => { const { border: n } = r; const i = (0, t.drawBorder)(e, { ...r, separator: { body: n.topBody, join: n.topJoin, left: n.topLeft, right: n.topRight } }); if (i === "\n") { return "" } return i }; t.drawBorderTop = drawBorderTop; const drawBorderJoin = (e, r) => { const { border: n } = r; return (0, t.drawBorder)(e, { ...r, separator: { body: n.joinBody, bodyJoinInner: n.bodyJoin, bodyJoinOuter: n.bodyLeft, join: n.joinJoin, joinDown: n.joinMiddleDown, joinLeft: n.joinMiddleLeft, joinRight: n.joinMiddleRight, joinUp: n.joinMiddleUp, left: n.joinLeft, right: n.joinRight } }) }; t.drawBorderJoin = drawBorderJoin; const drawBorderBottom = (e, r) => { const { border: n } = r; return (0, t.drawBorder)(e, { ...r, separator: { body: n.bottomBody, join: n.bottomJoin, left: n.bottomLeft, right: n.bottomRight } }) }; t.drawBorderBottom = drawBorderBottom; const createTableBorderGetter = (e, r) => (n, i) => { const s = { ...r, horizontalBorderIndex: n }; if (n === 0) { return (0, t.drawBorderTop)(e, s) } else if (n === i) { return (0, t.drawBorderBottom)(e, s) } return (0, t.drawBorderJoin)(e, s) }; t.createTableBorderGetter = createTableBorderGetter }, 2019: (e, t) => { Object.defineProperty(t, "__esModule", { value: true }); t.drawContent = void 0; const drawContent = e => { const { contents: t, separatorGetter: r, drawSeparator: n, spanningCellManager: i, rowIndex: s, elementType: o } = e; const a = t.length; const u = []; if (n(0, a)) { u.push(r(0, a)) } t.forEach(((e, t) => { if (!o || o === "border" || o === "row") { u.push(e) } if (o === "cell" && s === undefined) { u.push(e) } if (o === "cell" && s !== undefined) { const r = i === null || i === void 0 ? void 0 : i.getContainingRange({ col: t, row: s }); if (!r || t === r.topLeft.col) { u.push(e) } } if (t + 1 < a && n(t + 1, a)) { const e = r(t + 1, a); if (o === "cell" && s !== undefined) { const r = { col: t + 1, row: s }; const n = i === null || i === void 0 ? void 0 : i.getContainingRange(r); if (!n || n.topLeft.col === r.col) { u.push(e) } } else { u.push(e) } } })); if (n(a, a)) { u.push(r(a, a)) } return u.join("") }; t.drawContent = drawContent }, 9885: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t.drawRow = void 0; const n = r(2019); const drawRow = (e, t) => { const { border: r, drawVerticalLine: i, rowIndex: s, spanningCellManager: o } = t; return (0, n.drawContent)({ contents: e, drawSeparator: i, elementType: "cell", rowIndex: s, separatorGetter: (e, t) => { if (e === 0) { return r.bodyLeft } if (e === t) { return r.bodyRight } return r.bodyJoin }, spanningCellManager: o }) + "\n" }; t.drawRow = drawRow }, 2458: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t.drawTable = void 0; const n = r(2523); const i = r(2019); const s = r(9885); const o = r(6500); const drawTable = (e, t, r, a) => { const { drawHorizontalLine: u, singleLine: l } = a; const f = (0, o.groupBySizes)(e, r).map(((e, t) => e.map((e => (0, s.drawRow)(e, { ...a, rowIndex: t }))).join(""))); return (0, i.drawContent)({ contents: f, drawSeparator: (e, t) => { if (e === 0 || e === t) { return u(e, t) } return !l && u(e, t) }, elementType: "row", rowIndex: -1, separatorGetter: (0, n.createTableBorderGetter)(t, { ...a, rowCount: f.length }), spanningCellManager: a.spanningCellManager }) }; t.drawTable = drawTable }, 5951: (e, t, r) => { t["config.json"] = validate43; const n = { $id: "config.json", $schema: "http://json-schema.org/draft-07/schema#", type: "object", properties: { border: { $ref: "shared.json#/definitions/borders" }, header: { type: "object", properties: { content: { type: "string" }, alignment: { $ref: "shared.json#/definitions/alignment" }, wrapWord: { type: "boolean" }, truncate: { type: "integer" }, paddingLeft: { type: "integer" }, paddingRight: { type: "integer" } }, required: ["content"], additionalProperties: false }, columns: { $ref: "shared.json#/definitions/columns" }, columnDefault: { $ref: "shared.json#/definitions/column" }, drawVerticalLine: { typeof: "function" }, drawHorizontalLine: { typeof: "function" }, singleLine: { typeof: "boolean" }, spanningCells: { type: "array", items: { type: "object", properties: { col: { type: "integer", minimum: 0 }, row: { type: "integer", minimum: 0 }, colSpan: { type: "integer", minimum: 1 }, rowSpan: { type: "integer", minimum: 1 }, alignment: { $ref: "shared.json#/definitions/alignment" }, verticalAlignment: { $ref: "shared.json#/definitions/verticalAlignment" }, wrapWord: { type: "boolean" }, truncate: { type: "integer" }, paddingLeft: { type: "integer" }, paddingRight: { type: "integer" } }, required: ["row", "col"], additionalProperties: false } } }, additionalProperties: false }; const i = { type: "object", properties: { topBody: { $ref: "#/definitions/border" }, topJoin: { $ref: "#/definitions/border" }, topLeft: { $ref: "#/definitions/border" }, topRight: { $ref: "#/definitions/border" }, bottomBody: { $ref: "#/definitions/border" }, bottomJoin: { $ref: "#/definitions/border" }, bottomLeft: { $ref: "#/definitions/border" }, bottomRight: { $ref: "#/definitions/border" }, bodyLeft: { $ref: "#/definitions/border" }, bodyRight: { $ref: "#/definitions/border" }, bodyJoin: { $ref: "#/definitions/border" }, headerJoin: { $ref: "#/definitions/border" }, joinBody: { $ref: "#/definitions/border" }, joinLeft: { $ref: "#/definitions/border" }, joinRight: { $ref: "#/definitions/border" }, joinJoin: { $ref: "#/definitions/border" }, joinMiddleUp: { $ref: "#/definitions/border" }, joinMiddleDown: { $ref: "#/definitions/border" }, joinMiddleLeft: { $ref: "#/definitions/border" }, joinMiddleRight: { $ref: "#/definitions/border" } }, additionalProperties: false }; const s = Object.prototype.hasOwnProperty; const o = { type: "string" }; function validate46(e, { instancePath: t = "", parentData: r, parentDataProperty: n, rootData: i = e } = {}) { let s = null; let o = 0; if (typeof e !== "string") { const e = { instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: "string" }, message: "must be string" }; if (s === null) { s = [e] } else { s.push(e) } o++ } validate46.errors = s; return o === 0 } function validate45(e, { instancePath: t = "", parentData: r, parentDataProperty: n, rootData: o = e } = {}) { let a = null; let u = 0; if (e && typeof e == "object" && !Array.isArray(e)) { for (const r in e) { if (!s.call(i.properties, r)) { const e = { instancePath: t, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: r }, message: "must NOT have additional properties" }; if (a === null) { a = [e] } else { a.push(e) } u++ } } if (e.topBody !== undefined) { if (!validate46(e.topBody, { instancePath: t + "/topBody", parentData: e, parentDataProperty: "topBody", rootData: o })) { a = a === null ? validate46.errors : a.concat(validate46.errors); u = a.length } } if (e.topJoin !== undefined) { if (!validate46(e.topJoin, { instancePath: t + "/topJoin", parentData: e, parentDataProperty: "topJoin", rootData: o })) { a = a === null ? validate46.errors : a.concat(validate46.errors); u = a.length } } if (e.topLeft !== undefined) { if (!validate46(e.topLeft, { instancePath: t + "/topLeft", parentData: e, parentDataProperty: "topLeft", rootData: o })) { a = a === null ? validate46.errors : a.concat(validate46.errors); u = a.length } } if (e.topRight !== undefined) { if (!validate46(e.topRight, { instancePath: t + "/topRight", parentData: e, parentDataProperty: "topRight", rootData: o })) { a = a === null ? validate46.errors : a.concat(validate46.errors); u = a.length } } if (e.bottomBody !== undefined) { if (!validate46(e.bottomBody, { instancePath: t + "/bottomBody", parentData: e, parentDataProperty: "bottomBody", rootData: o })) { a = a === null ? validate46.errors : a.concat(validate46.errors); u = a.length } } if (e.bottomJoin !== undefined) { if (!validate46(e.bottomJoin, { instancePath: t + "/bottomJoin", parentData: e, parentDataProperty: "bottomJoin", rootData: o })) { a = a === null ? validate46.errors : a.concat(validate46.errors); u = a.length } } if (e.bottomLeft !== undefined) { if (!validate46(e.bottomLeft, { instancePath: t + "/bottomLeft", parentData: e, parentDataProperty: "bottomLeft", rootData: o })) { a = a === null ? validate46.errors : a.concat(validate46.errors); u = a.length } } if (e.bottomRight !== undefined) { if (!validate46(e.bottomRight, { instancePath: t + "/bottomRight", parentData: e, parentDataProperty: "bottomRight", rootData: o })) { a = a === null ? validate46.errors : a.concat(validate46.errors); u = a.length } } if (e.bodyLeft !== undefined) { if (!validate46(e.bodyLeft, { instancePath: t + "/bodyLeft", parentData: e, parentDataProperty: "bodyLeft", rootData: o })) { a = a === null ? validate46.errors : a.concat(validate46.errors); u = a.length } } if (e.bodyRight !== undefined) { if (!validate46(e.bodyRight, { instancePath: t + "/bodyRight", parentData: e, parentDataProperty: "bodyRight", rootData: o })) { a = a === null ? validate46.errors : a.concat(validate46.errors); u = a.length } } if (e.bodyJoin !== undefined) { if (!validate46(e.bodyJoin, { instancePath: t + "/bodyJoin", parentData: e, parentDataProperty: "bodyJoin", rootData: o })) { a = a === null ? validate46.errors : a.concat(validate46.errors); u = a.length } } if (e.headerJoin !== undefined) { if (!validate46(e.headerJoin, { instancePath: t + "/headerJoin", parentData: e, parentDataProperty: "headerJoin", rootData: o })) { a = a === null ? validate46.errors : a.concat(validate46.errors); u = a.length } } if (e.joinBody !== undefined) { if (!validate46(e.joinBody, { instancePath: t + "/joinBody", parentData: e, parentDataProperty: "joinBody", rootData: o })) { a = a === null ? validate46.errors : a.concat(validate46.errors); u = a.length } } if (e.joinLeft !== undefined) { if (!validate46(e.joinLeft, { instancePath: t + "/joinLeft", parentData: e, parentDataProperty: "joinLeft", rootData: o })) { a = a === null ? validate46.errors : a.concat(validate46.errors); u = a.length } } if (e.joinRight !== undefined) { if (!validate46(e.joinRight, { instancePath: t + "/joinRight", parentData: e, parentDataProperty: "joinRight", rootData: o })) { a = a === null ? validate46.errors : a.concat(validate46.errors); u = a.length } } if (e.joinJoin !== undefined) { if (!validate46(e.joinJoin, { instancePath: t + "/joinJoin", parentData: e, parentDataProperty: "joinJoin", rootData: o })) { a = a === null ? validate46.errors : a.concat(validate46.errors); u = a.length } } if (e.joinMiddleUp !== undefined) { if (!validate46(e.joinMiddleUp, { instancePath: t + "/joinMiddleUp", parentData: e, parentDataProperty: "joinMiddleUp", rootData: o })) { a = a === null ? validate46.errors : a.concat(validate46.errors); u = a.length } } if (e.joinMiddleDown !== undefined) { if (!validate46(e.joinMiddleDown, { instancePath: t + "/joinMiddleDown", parentData: e, parentDataProperty: "joinMiddleDown", rootData: o })) { a = a === null ? validate46.errors : a.concat(validate46.errors); u = a.length } } if (e.joinMiddleLeft !== undefined) { if (!validate46(e.joinMiddleLeft, { instancePath: t + "/joinMiddleLeft", parentData: e, parentDataProperty: "joinMiddleLeft", rootData: o })) { a = a === null ? validate46.errors : a.concat(validate46.errors); u = a.length } } if (e.joinMiddleRight !== undefined) { if (!validate46(e.joinMiddleRight, { instancePath: t + "/joinMiddleRight", parentData: e, parentDataProperty: "joinMiddleRight", rootData: o })) { a = a === null ? validate46.errors : a.concat(validate46.errors); u = a.length } } } else { const e = { instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }; if (a === null) { a = [e] } else { a.push(e) } u++ } validate45.errors = a; return u === 0 } const a = { type: "string", enum: ["left", "right", "center", "justify"] }; const u = r(3809).Z; function validate68(e, { instancePath: t = "", parentData: r, parentDataProperty: n, rootData: i = e } = {}) { let s = null; let o = 0; if (typeof e !== "string") { const e = { instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: "string" }, message: "must be string" }; if (s === null) { s = [e] } else { s.push(e) } o++ } if (!(e === "left" || e === "right" || e === "center" || e === "justify")) { const e = { instancePath: t, schemaPath: "#/enum", keyword: "enum", params: { allowedValues: a.enum }, message: "must be equal to one of the allowed values" }; if (s === null) { s = [e] } else { s.push(e) } o++ } validate68.errors = s; return o === 0 } const l = { oneOf: [{ type: "object", patternProperties: { "^[0-9]+$": { $ref: "#/definitions/column" } }, additionalProperties: false }, { type: "array", items: { $ref: "#/definitions/column" } }] }; const f = new RegExp("^[0-9]+$", "u"); const d = { type: "object", properties: { alignment: { $ref: "#/definitions/alignment" }, verticalAlignment: { $ref: "#/definitions/verticalAlignment" }, width: { type: "integer", minimum: 1 }, wrapWord: { type: "boolean" }, truncate: { type: "integer" }, paddingLeft: { type: "integer" }, paddingRight: { type: "integer" } }, additionalProperties: false }; function validate72(e, { instancePath: t = "", parentData: r, parentDataProperty: n, rootData: i = e } = {}) { let s = null; let o = 0; if (typeof e !== "string") { const e = { instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: "string" }, message: "must be string" }; if (s === null) { s = [e] } else { s.push(e) } o++ } if (!(e === "left" || e === "right" || e === "center" || e === "justify")) { const e = { instancePath: t, schemaPath: "#/enum", keyword: "enum", params: { allowedValues: a.enum }, message: "must be equal to one of the allowed values" }; if (s === null) { s = [e] } else { s.push(e) } o++ } validate72.errors = s; return o === 0 } const p = { type: "string", enum: ["top", "middle", "bottom"] }; function validate74(e, { instancePath: t = "", parentData: r, parentDataProperty: n, rootData: i = e } = {}) { let s = null; let o = 0; if (typeof e !== "string") { const e = { instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: "string" }, message: "must be string" }; if (s === null) { s = [e] } else { s.push(e) } o++ } if (!(e === "top" || e === "middle" || e === "bottom")) { const e = { instancePath: t, schemaPath: "#/enum", keyword: "enum", params: { allowedValues: p.enum }, message: "must be equal to one of the allowed values" }; if (s === null) { s = [e] } else { s.push(e) } o++ } validate74.errors = s; return o === 0 } function validate71(e, { instancePath: t = "", parentData: r, parentDataProperty: n, rootData: i = e } = {}) { let s = null; let o = 0; if (e && typeof e == "object" && !Array.isArray(e)) { for (const r in e) { if (!(r === "alignment" || r === "verticalAlignment" || r === "width" || r === "wrapWord" || r === "truncate" || r === "paddingLeft" || r === "paddingRight")) { const e = { instancePath: t, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: r }, message: "must NOT have additional properties" }; if (s === null) { s = [e] } else { s.push(e) } o++ } } if (e.alignment !== undefined) { if (!validate72(e.alignment, { instancePath: t + "/alignment", parentData: e, parentDataProperty: "alignment", rootData: i })) { s = s === null ? validate72.errors : s.concat(validate72.errors); o = s.length } } if (e.verticalAlignment !== undefined) { if (!validate74(e.verticalAlignment, { instancePath: t + "/verticalAlignment", parentData: e, parentDataProperty: "verticalAlignment", rootData: i })) { s = s === null ? validate74.errors : s.concat(validate74.errors); o = s.length } } if (e.width !== undefined) { let r = e.width; if (!(typeof r == "number" && (!(r % 1) && !isNaN(r)) && isFinite(r))) { const e = { instancePath: t + "/width", schemaPath: "#/properties/width/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }; if (s === null) { s = [e] } else { s.push(e) } o++ } if (typeof r == "number" && isFinite(r)) { if (r < 1 || isNaN(r)) { const e = { instancePath: t + "/width", schemaPath: "#/properties/width/minimum", keyword: "minimum", params: { comparison: ">=", limit: 1 }, message: "must be >= 1" }; if (s === null) { s = [e] } else { s.push(e) } o++ } } } if (e.wrapWord !== undefined) { if (typeof e.wrapWord !== "boolean") { const e = { instancePath: t + "/wrapWord", schemaPath: "#/properties/wrapWord/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }; if (s === null) { s = [e] } else { s.push(e) } o++ } } if (e.truncate !== undefined) { let r = e.truncate; if (!(typeof r == "number" && (!(r % 1) && !isNaN(r)) && isFinite(r))) { const e = { instancePath: t + "/truncate", schemaPath: "#/properties/truncate/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }; if (s === null) { s = [e] } else { s.push(e) } o++ } } if (e.paddingLeft !== undefined) { let r = e.paddingLeft; if (!(typeof r == "number" && (!(r % 1) && !isNaN(r)) && isFinite(r))) { const e = { instancePath: t + "/paddingLeft", schemaPath: "#/properties/paddingLeft/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }; if (s === null) { s = [e] } else { s.push(e) } o++ } } if (e.paddingRight !== undefined) { let r = e.paddingRight; if (!(typeof r == "number" && (!(r % 1) && !isNaN(r)) && isFinite(r))) { const e = { instancePath: t + "/paddingRight", schemaPath: "#/properties/paddingRight/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }; if (s === null) { s = [e] } else { s.push(e) } o++ } } } else { const e = { instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }; if (s === null) { s = [e] } else { s.push(e) } o++ } validate71.errors = s; return o === 0 } function validate70(e, { instancePath: t = "", parentData: r, parentDataProperty: n, rootData: i = e } = {}) { let s = null; let o = 0; const a = o; let u = false; let l = null; const d = o; if (e && typeof e == "object" && !Array.isArray(e)) { for (const r in e) { if (!f.test(r)) { const e = { instancePath: t, schemaPath: "#/oneOf/0/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: r }, message: "must NOT have additional properties" }; if (s === null) { s = [e] } else { s.push(e) } o++ } } for (const r in e) { if (f.test(r)) { if (!validate71(e[r], { instancePath: t + "/" + r.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: e, parentDataProperty: r, rootData: i })) { s = s === null ? validate71.errors : s.concat(validate71.errors); o = s.length } } } } else { const e = { instancePath: t, schemaPath: "#/oneOf/0/type", keyword: "type", params: { type: "object" }, message: "must be object" }; if (s === null) { s = [e] } else { s.push(e) } o++ } var p = d === o; if (p) { u = true; l = 0 } const h = o; if (Array.isArray(e)) { const r = e.length; for (let n = 0; n < r; n++) { if (!validate71(e[n], { instancePath: t + "/" + n, parentData: e, parentDataProperty: n, rootData: i })) { s = s === null ? validate71.errors : s.concat(validate71.errors); o = s.length } } } else { const e = { instancePath: t, schemaPath: "#/oneOf/1/type", keyword: "type", params: { type: "array" }, message: "must be array" }; if (s === null) { s = [e] } else { s.push(e) } o++ } var p = h === o; if (p && u) { u = false; l = [l, 1] } else { if (p) { u = true; l = 1 } } if (!u) { const e = { instancePath: t, schemaPath: "#/oneOf", keyword: "oneOf", params: { passingSchemas: l }, message: "must match exactly one schema in oneOf" }; if (s === null) { s = [e] } else { s.push(e) } o++ } else { o = a; if (s !== null) { if (a) { s.length = a } else { s = null } } } validate70.errors = s; return o === 0 } function validate79(e, { instancePath: t = "", parentData: r, parentDataProperty: n, rootData: i = e } = {}) { let s = null; let o = 0; if (e && typeof e == "object" && !Array.isArray(e)) { for (const r in e) { if (!(r === "alignment" || r === "verticalAlignment" || r === "width" || r === "wrapWord" || r === "truncate" || r === "paddingLeft" || r === "paddingRight")) { const e = { instancePath: t, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: r }, message: "must NOT have additional properties" }; if (s === null) { s = [e] } else { s.push(e) } o++ } } if (e.alignment !== undefined) { if (!validate72(e.alignment, { instancePath: t + "/alignment", parentData: e, parentDataProperty: "alignment", rootData: i })) { s = s === null ? validate72.errors : s.concat(validate72.errors); o = s.length } } if (e.verticalAlignment !== undefined) { if (!validate74(e.verticalAlignment, { instancePath: t + "/verticalAlignment", parentData: e, parentDataProperty: "verticalAlignment", rootData: i })) { s = s === null ? validate74.errors : s.concat(validate74.errors); o = s.length } } if (e.width !== undefined) { let r = e.width; if (!(typeof r == "number" && (!(r % 1) && !isNaN(r)) && isFinite(r))) { const e = { instancePath: t + "/width", schemaPath: "#/properties/width/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }; if (s === null) { s = [e] } else { s.push(e) } o++ } if (typeof r == "number" && isFinite(r)) { if (r < 1 || isNaN(r)) { const e = { instancePath: t + "/width", schemaPath: "#/properties/width/minimum", keyword: "minimum", params: { comparison: ">=", limit: 1 }, message: "must be >= 1" }; if (s === null) { s = [e] } else { s.push(e) } o++ } } } if (e.wrapWord !== undefined) { if (typeof e.wrapWord !== "boolean") { const e = { instancePath: t + "/wrapWord", schemaPath: "#/properties/wrapWord/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }; if (s === null) { s = [e] } else { s.push(e) } o++ } } if (e.truncate !== undefined) { let r = e.truncate; if (!(typeof r == "number" && (!(r % 1) && !isNaN(r)) && isFinite(r))) { const e = { instancePath: t + "/truncate", schemaPath: "#/properties/truncate/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }; if (s === null) { s = [e] } else { s.push(e) } o++ } } if (e.paddingLeft !== undefined) { let r = e.paddingLeft; if (!(typeof r == "number" && (!(r % 1) && !isNaN(r)) && isFinite(r))) { const e = { instancePath: t + "/paddingLeft", schemaPath: "#/properties/paddingLeft/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }; if (s === null) { s = [e] } else { s.push(e) } o++ } } if (e.paddingRight !== undefined) { let r = e.paddingRight; if (!(typeof r == "number" && (!(r % 1) && !isNaN(r)) && isFinite(r))) { const e = { instancePath: t + "/paddingRight", schemaPath: "#/properties/paddingRight/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }; if (s === null) { s = [e] } else { s.push(e) } o++ } } } else { const e = { instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }; if (s === null) { s = [e] } else { s.push(e) } o++ } validate79.errors = s; return o === 0 } function validate84(e, { instancePath: t = "", parentData: r, parentDataProperty: n, rootData: i = e } = {}) { let s = null; let o = 0; if (typeof e !== "string") { const e = { instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: "string" }, message: "must be string" }; if (s === null) { s = [e] } else { s.push(e) } o++ } if (!(e === "top" || e === "middle" || e === "bottom")) { const e = { instancePath: t, schemaPath: "#/enum", keyword: "enum", params: { allowedValues: p.enum }, message: "must be equal to one of the allowed values" }; if (s === null) { s = [e] } else { s.push(e) } o++ } validate84.errors = s; return o === 0 } function validate43(e, { instancePath: t = "", parentData: r, parentDataProperty: i, rootData: o = e } = {}) { let a = null; let u = 0; if (e && typeof e == "object" && !Array.isArray(e)) { for (const r in e) { if (!(r === "border" || r === "header" || r === "columns" || r === "columnDefault" || r === "drawVerticalLine" || r === "drawHorizontalLine" || r === "singleLine" || r === "spanningCells")) { const e = { instancePath: t, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: r }, message: "must NOT have additional properties" }; if (a === null) { a = [e] } else { a.push(e) } u++ } } if (e.border !== undefined) { if (!validate45(e.border, { instancePath: t + "/border", parentData: e, parentDataProperty: "border", rootData: o })) { a = a === null ? validate45.errors : a.concat(validate45.errors); u = a.length } } if (e.header !== undefined) { let r = e.header; if (r && typeof r == "object" && !Array.isArray(r)) { if (r.content === undefined) { const e = { instancePath: t + "/header", schemaPath: "#/properties/header/required", keyword: "required", params: { missingProperty: "content" }, message: "must have required property '" + "content" + "'" }; if (a === null) { a = [e] } else { a.push(e) } u++ } for (const e in r) { if (!(e === "content" || e === "alignment" || e === "wrapWord" || e === "truncate" || e === "paddingLeft" || e === "paddingRight")) { const r = { instancePath: t + "/header", schemaPath: "#/properties/header/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: e }, message: "must NOT have additional properties" }; if (a === null) { a = [r] } else { a.push(r) } u++ } } if (r.content !== undefined) { if (typeof r.content !== "string") { const e = { instancePath: t + "/header/content", schemaPath: "#/properties/header/properties/content/type", keyword: "type", params: { type: "string" }, message: "must be string" }; if (a === null) { a = [e] } else { a.push(e) } u++ } } if (r.alignment !== undefined) { if (!validate68(r.alignment, { instancePath: t + "/header/alignment", parentData: r, parentDataProperty: "alignment", rootData: o })) { a = a === null ? validate68.errors : a.concat(validate68.errors); u = a.length } } if (r.wrapWord !== undefined) { if (typeof r.wrapWord !== "boolean") { const e = { instancePath: t + "/header/wrapWord", schemaPath: "#/properties/header/properties/wrapWord/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }; if (a === null) { a = [e] } else { a.push(e) } u++ } } if (r.truncate !== undefined) { let e = r.truncate; if (!(typeof e == "number" && (!(e % 1) && !isNaN(e)) && isFinite(e))) { const e = { instancePath: t + "/header/truncate", schemaPath: "#/properties/header/properties/truncate/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }; if (a === null) { a = [e] } else { a.push(e) } u++ } } if (r.paddingLeft !== undefined) { let e = r.paddingLeft; if (!(typeof e == "number" && (!(e % 1) && !isNaN(e)) && isFinite(e))) { const e = { instancePath: t + "/header/paddingLeft", schemaPath: "#/properties/header/properties/paddingLeft/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }; if (a === null) { a = [e] } else { a.push(e) } u++ } } if (r.paddingRight !== undefined) { let e = r.paddingRight; if (!(typeof e == "number" && (!(e % 1) && !isNaN(e)) && isFinite(e))) { const e = { instancePath: t + "/header/paddingRight", schemaPath: "#/properties/header/properties/paddingRight/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }; if (a === null) { a = [e] } else { a.push(e) } u++ } } } else { const e = { instancePath: t + "/header", schemaPath: "#/properties/header/type", keyword: "type", params: { type: "object" }, message: "must be object" }; if (a === null) { a = [e] } else { a.push(e) } u++ } } if (e.columns !== undefined) { if (!validate70(e.columns, { instancePath: t + "/columns", parentData: e, parentDataProperty: "columns", rootData: o })) { a = a === null ? validate70.errors : a.concat(validate70.errors); u = a.length } } if (e.columnDefault !== undefined) { if (!validate79(e.columnDefault, { instancePath: t + "/columnDefault", parentData: e, parentDataProperty: "columnDefault", rootData: o })) { a = a === null ? validate79.errors : a.concat(validate79.errors); u = a.length } } if (e.drawVerticalLine !== undefined) { if (typeof e.drawVerticalLine != "function") { const e = { instancePath: t + "/drawVerticalLine", schemaPath: "#/properties/drawVerticalLine/typeof", keyword: "typeof", params: {}, message: 'must pass "typeof" keyword validation' }; if (a === null) { a = [e] } else { a.push(e) } u++ } } if (e.drawHorizontalLine !== undefined) { if (typeof e.drawHorizontalLine != "function") { const e = { instancePath: t + "/drawHorizontalLine", schemaPath: "#/properties/drawHorizontalLine/typeof", keyword: "typeof", params: {}, message: 'must pass "typeof" keyword validation' }; if (a === null) { a = [e] } else { a.push(e) } u++ } } if (e.singleLine !== undefined) { if (typeof e.singleLine != "boolean") { const e = { instancePath: t + "/singleLine", schemaPath: "#/properties/singleLine/typeof", keyword: "typeof", params: {}, message: 'must pass "typeof" keyword validation' }; if (a === null) { a = [e] } else { a.push(e) } u++ } } if (e.spanningCells !== undefined) { let r = e.spanningCells; if (Array.isArray(r)) { const e = r.length; for (let i = 0; i < e; i++) { let e = r[i]; if (e && typeof e == "object" && !Array.isArray(e)) { if (e.row === undefined) { const e = { instancePath: t + "/spanningCells/" + i, schemaPath: "#/properties/spanningCells/items/required", keyword: "required", params: { missingProperty: "row" }, message: "must have required property '" + "row" + "'" }; if (a === null) { a = [e] } else { a.push(e) } u++ } if (e.col === undefined) { const e = { instancePath: t + "/spanningCells/" + i, schemaPath: "#/properties/spanningCells/items/required", keyword: "required", params: { missingProperty: "col" }, message: "must have required property '" + "col" + "'" }; if (a === null) { a = [e] } else { a.push(e) } u++ } for (const r in e) { if (!s.call(n.properties.spanningCells.items.properties, r)) { const e = { instancePath: t + "/spanningCells/" + i, schemaPath: "#/properties/spanningCells/items/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: r }, message: "must NOT have additional properties" }; if (a === null) { a = [e] } else { a.push(e) } u++ } } if (e.col !== undefined) { let r = e.col; if (!(typeof r == "number" && (!(r % 1) && !isNaN(r)) && isFinite(r))) { const e = { instancePath: t + "/spanningCells/" + i + "/col", schemaPath: "#/properties/spanningCells/items/properties/col/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }; if (a === null) { a = [e] } else { a.push(e) } u++ } if (typeof r == "number" && isFinite(r)) { if (r < 0 || isNaN(r)) { const e = { instancePath: t + "/spanningCells/" + i + "/col", schemaPath: "#/properties/spanningCells/items/properties/col/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }; if (a === null) { a = [e] } else { a.push(e) } u++ } } } if (e.row !== undefined) { let r = e.row; if (!(typeof r == "number" && (!(r % 1) && !isNaN(r)) && isFinite(r))) { const e = { instancePath: t + "/spanningCells/" + i + "/row", schemaPath: "#/properties/spanningCells/items/properties/row/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }; if (a === null) { a = [e] } else { a.push(e) } u++ } if (typeof r == "number" && isFinite(r)) { if (r < 0 || isNaN(r)) { const e = { instancePath: t + "/spanningCells/" + i + "/row", schemaPath: "#/properties/spanningCells/items/properties/row/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }; if (a === null) { a = [e] } else { a.push(e) } u++ } } } if (e.colSpan !== undefined) { let r = e.colSpan; if (!(typeof r == "number" && (!(r % 1) && !isNaN(r)) && isFinite(r))) { const e = { instancePath: t + "/spanningCells/" + i + "/colSpan", schemaPath: "#/properties/spanningCells/items/properties/colSpan/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }; if (a === null) { a = [e] } else { a.push(e) } u++ } if (typeof r == "number" && isFinite(r)) { if (r < 1 || isNaN(r)) { const e = { instancePath: t + "/spanningCells/" + i + "/colSpan", schemaPath: "#/properties/spanningCells/items/properties/colSpan/minimum", keyword: "minimum", params: { comparison: ">=", limit: 1 }, message: "must be >= 1" }; if (a === null) { a = [e] } else { a.push(e) } u++ } } } if (e.rowSpan !== undefined) { let r = e.rowSpan; if (!(typeof r == "number" && (!(r % 1) && !isNaN(r)) && isFinite(r))) { const e = { instancePath: t + "/spanningCells/" + i + "/rowSpan", schemaPath: "#/properties/spanningCells/items/properties/rowSpan/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }; if (a === null) { a = [e] } else { a.push(e) } u++ } if (typeof r == "number" && isFinite(r)) { if (r < 1 || isNaN(r)) { const e = { instancePath: t + "/spanningCells/" + i + "/rowSpan", schemaPath: "#/properties/spanningCells/items/properties/rowSpan/minimum", keyword: "minimum", params: { comparison: ">=", limit: 1 }, message: "must be >= 1" }; if (a === null) { a = [e] } else { a.push(e) } u++ } } } if (e.alignment !== undefined) { if (!validate68(e.alignment, { instancePath: t + "/spanningCells/" + i + "/alignment", parentData: e, parentDataProperty: "alignment", rootData: o })) { a = a === null ? validate68.errors : a.concat(validate68.errors); u = a.length } } if (e.verticalAlignment !== undefined) { if (!validate84(e.verticalAlignment, { instancePath: t + "/spanningCells/" + i + "/verticalAlignment", parentData: e, parentDataProperty: "verticalAlignment", rootData: o })) { a = a === null ? validate84.errors : a.concat(validate84.errors); u = a.length } } if (e.wrapWord !== undefined) { if (typeof e.wrapWord !== "boolean") { const e = { instancePath: t + "/spanningCells/" + i + "/wrapWord", schemaPath: "#/properties/spanningCells/items/properties/wrapWord/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }; if (a === null) { a = [e] } else { a.push(e) } u++ } } if (e.truncate !== undefined) { let r = e.truncate; if (!(typeof r == "number" && (!(r % 1) && !isNaN(r)) && isFinite(r))) { const e = { instancePath: t + "/spanningCells/" + i + "/truncate", schemaPath: "#/properties/spanningCells/items/properties/truncate/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }; if (a === null) { a = [e] } else { a.push(e) } u++ } } if (e.paddingLeft !== undefined) { let r = e.paddingLeft; if (!(typeof r == "number" && (!(r % 1) && !isNaN(r)) && isFinite(r))) { const e = { instancePath: t + "/spanningCells/" + i + "/paddingLeft", schemaPath: "#/properties/spanningCells/items/properties/paddingLeft/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }; if (a === null) { a = [e] } else { a.push(e) } u++ } } if (e.paddingRight !== undefined) { let r = e.paddingRight; if (!(typeof r == "number" && (!(r % 1) && !isNaN(r)) && isFinite(r))) { const e = { instancePath: t + "/spanningCells/" + i + "/paddingRight", schemaPath: "#/properties/spanningCells/items/properties/paddingRight/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }; if (a === null) { a = [e] } else { a.push(e) } u++ } } } else { const e = { instancePath: t + "/spanningCells/" + i, schemaPath: "#/properties/spanningCells/items/type", keyword: "type", params: { type: "object" }, message: "must be object" }; if (a === null) { a = [e] } else { a.push(e) } u++ } } } else { const e = { instancePath: t + "/spanningCells", schemaPath: "#/properties/spanningCells/type", keyword: "type", params: { type: "array" }, message: "must be array" }; if (a === null) { a = [e] } else { a.push(e) } u++ } } } else { const e = { instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }; if (a === null) { a = [e] } else { a.push(e) } u++ } validate43.errors = a; return u === 0 } t["streamConfig.json"] = validate86; const h = { $id: "streamConfig.json", $schema: "http://json-schema.org/draft-07/schema#", type: "object", properties: { border: { $ref: "shared.json#/definitions/borders" }, columns: { $ref: "shared.json#/definitions/columns" }, columnDefault: { $ref: "shared.json#/definitions/column" }, columnCount: { type: "integer", minimum: 1 }, drawVerticalLine: { typeof: "function" } }, required: ["columnDefault", "columnCount"], additionalProperties: false }; function validate87(e, { instancePath: t = "", parentData: r, parentDataProperty: n, rootData: o = e } = {}) { let a = null; let u = 0; if (e && typeof e == "object" && !Array.isArray(e)) { for (const r in e) { if (!s.call(i.properties, r)) { const e = { instancePath: t, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: r }, message: "must NOT have additional properties" }; if (a === null) { a = [e] } else { a.push(e) } u++ } } if (e.topBody !== undefined) { if (!validate46(e.topBody, { instancePath: t + "/topBody", parentData: e, parentDataProperty: "topBody", rootData: o })) { a = a === null ? validate46.errors : a.concat(validate46.errors); u = a.length } } if (e.topJoin !== undefined) { if (!validate46(e.topJoin, { instancePath: t + "/topJoin", parentData: e, parentDataProperty: "topJoin", rootData: o })) { a = a === null ? validate46.errors : a.concat(validate46.errors); u = a.length } } if (e.topLeft !== undefined) { if (!validate46(e.topLeft, { instancePath: t + "/topLeft", parentData: e, parentDataProperty: "topLeft", rootData: o })) { a = a === null ? validate46.errors : a.concat(validate46.errors); u = a.length } } if (e.topRight !== undefined) { if (!validate46(e.topRight, { instancePath: t + "/topRight", parentData: e, parentDataProperty: "topRight", rootData: o })) { a = a === null ? validate46.errors : a.concat(validate46.errors); u = a.length } } if (e.bottomBody !== undefined) { if (!validate46(e.bottomBody, { instancePath: t + "/bottomBody", parentData: e, parentDataProperty: "bottomBody", rootData: o })) { a = a === null ? validate46.errors : a.concat(validate46.errors); u = a.length } } if (e.bottomJoin !== undefined) { if (!validate46(e.bottomJoin, { instancePath: t + "/bottomJoin", parentData: e, parentDataProperty: "bottomJoin", rootData: o })) { a = a === null ? validate46.errors : a.concat(validate46.errors); u = a.length } } if (e.bottomLeft !== undefined) { if (!validate46(e.bottomLeft, { instancePath: t + "/bottomLeft", parentData: e, parentDataProperty: "bottomLeft", rootData: o })) { a = a === null ? validate46.errors : a.concat(validate46.errors); u = a.length } } if (e.bottomRight !== undefined) { if (!validate46(e.bottomRight, { instancePath: t + "/bottomRight", parentData: e, parentDataProperty: "bottomRight", rootData: o })) { a = a === null ? validate46.errors : a.concat(validate46.errors); u = a.length } } if (e.bodyLeft !== undefined) { if (!validate46(e.bodyLeft, { instancePath: t + "/bodyLeft", parentData: e, parentDataProperty: "bodyLeft", rootData: o })) { a = a === null ? validate46.errors : a.concat(validate46.errors); u = a.length } } if (e.bodyRight !== undefined) { if (!validate46(e.bodyRight, { instancePath: t + "/bodyRight", parentData: e, parentDataProperty: "bodyRight", rootData: o })) { a = a === null ? validate46.errors : a.concat(validate46.errors); u = a.length } } if (e.bodyJoin !== undefined) { if (!validate46(e.bodyJoin, { instancePath: t + "/bodyJoin", parentData: e, parentDataProperty: "bodyJoin", rootData: o })) { a = a === null ? validate46.errors : a.concat(validate46.errors); u = a.length } } if (e.headerJoin !== undefined) { if (!validate46(e.headerJoin, { instancePath: t + "/headerJoin", parentData: e, parentDataProperty: "headerJoin", rootData: o })) { a = a === null ? validate46.errors : a.concat(validate46.errors); u = a.length } } if (e.joinBody !== undefined) { if (!validate46(e.joinBody, { instancePath: t + "/joinBody", parentData: e, parentDataProperty: "joinBody", rootData: o })) { a = a === null ? validate46.errors : a.concat(validate46.errors); u = a.length } } if (e.joinLeft !== undefined) { if (!validate46(e.joinLeft, { instancePath: t + "/joinLeft", parentData: e, parentDataProperty: "joinLeft", rootData: o })) { a = a === null ? validate46.errors : a.concat(validate46.errors); u = a.length } } if (e.joinRight !== undefined) { if (!validate46(e.joinRight, { instancePath: t + "/joinRight", parentData: e, parentDataProperty: "joinRight", rootData: o })) { a = a === null ? validate46.errors : a.concat(validate46.errors); u = a.length } } if (e.joinJoin !== undefined) { if (!validate46(e.joinJoin, { instancePath: t + "/joinJoin", parentData: e, parentDataProperty: "joinJoin", rootData: o })) { a = a === null ? validate46.errors : a.concat(validate46.errors); u = a.length } } if (e.joinMiddleUp !== undefined) { if (!validate46(e.joinMiddleUp, { instancePath: t + "/joinMiddleUp", parentData: e, parentDataProperty: "joinMiddleUp", rootData: o })) { a = a === null ? validate46.errors : a.concat(validate46.errors); u = a.length } } if (e.joinMiddleDown !== undefined) { if (!validate46(e.joinMiddleDown, { instancePath: t + "/joinMiddleDown", parentData: e, parentDataProperty: "joinMiddleDown", rootData: o })) { a = a === null ? validate46.errors : a.concat(validate46.errors); u = a.length } } if (e.joinMiddleLeft !== undefined) { if (!validate46(e.joinMiddleLeft, { instancePath: t + "/joinMiddleLeft", parentData: e, parentDataProperty: "joinMiddleLeft", rootData: o })) { a = a === null ? validate46.errors : a.concat(validate46.errors); u = a.length } } if (e.joinMiddleRight !== undefined) { if (!validate46(e.joinMiddleRight, { instancePath: t + "/joinMiddleRight", parentData: e, parentDataProperty: "joinMiddleRight", rootData: o })) { a = a === null ? validate46.errors : a.concat(validate46.errors); u = a.length } } } else { const e = { instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }; if (a === null) { a = [e] } else { a.push(e) } u++ } validate87.errors = a; return u === 0 } function validate109(e, { instancePath: t = "", parentData: r, parentDataProperty: n, rootData: i = e } = {}) { let s = null; let o = 0; const a = o; let u = false; let l = null; const d = o; if (e && typeof e == "object" && !Array.isArray(e)) { for (const r in e) { if (!f.test(r)) { const e = { instancePath: t, schemaPath: "#/oneOf/0/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: r }, message: "must NOT have additional properties" }; if (s === null) { s = [e] } else { s.push(e) } o++ } } for (const r in e) { if (f.test(r)) { if (!validate71(e[r], { instancePath: t + "/" + r.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: e, parentDataProperty: r, rootData: i })) { s = s === null ? validate71.errors : s.concat(validate71.errors); o = s.length } } } } else { const e = { instancePath: t, schemaPath: "#/oneOf/0/type", keyword: "type", params: { type: "object" }, message: "must be object" }; if (s === null) { s = [e] } else { s.push(e) } o++ } var p = d === o; if (p) { u = true; l = 0 } const h = o; if (Array.isArray(e)) { const r = e.length; for (let n = 0; n < r; n++) { if (!validate71(e[n], { instancePath: t + "/" + n, parentData: e, parentDataProperty: n, rootData: i })) { s = s === null ? validate71.errors : s.concat(validate71.errors); o = s.length } } } else { const e = { instancePath: t, schemaPath: "#/oneOf/1/type", keyword: "type", params: { type: "array" }, message: "must be array" }; if (s === null) { s = [e] } else { s.push(e) } o++ } var p = h === o; if (p && u) { u = false; l = [l, 1] } else { if (p) { u = true; l = 1 } } if (!u) { const e = { instancePath: t, schemaPath: "#/oneOf", keyword: "oneOf", params: { passingSchemas: l }, message: "must match exactly one schema in oneOf" }; if (s === null) { s = [e] } else { s.push(e) } o++ } else { o = a; if (s !== null) { if (a) { s.length = a } else { s = null } } } validate109.errors = s; return o === 0 } function validate113(e, { instancePath: t = "", parentData: r, parentDataProperty: n, rootData: i = e } = {}) { let s = null; let o = 0; if (e && typeof e == "object" && !Array.isArray(e)) { for (const r in e) { if (!(r === "alignment" || r === "verticalAlignment" || r === "width" || r === "wrapWord" || r === "truncate" || r === "paddingLeft" || r === "paddingRight")) { const e = { instancePath: t, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: r }, message: "must NOT have additional properties" }; if (s === null) { s = [e] } else { s.push(e) } o++ } } if (e.alignment !== undefined) { if (!validate72(e.alignment, { instancePath: t + "/alignment", parentData: e, parentDataProperty: "alignment", rootData: i })) { s = s === null ? validate72.errors : s.concat(validate72.errors); o = s.length } } if (e.verticalAlignment !== undefined) { if (!validate74(e.verticalAlignment, { instancePath: t + "/verticalAlignment", parentData: e, parentDataProperty: "verticalAlignment", rootData: i })) { s = s === null ? validate74.errors : s.concat(validate74.errors); o = s.length } } if (e.width !== undefined) { let r = e.width; if (!(typeof r == "number" && (!(r % 1) && !isNaN(r)) && isFinite(r))) { const e = { instancePath: t + "/width", schemaPath: "#/properties/width/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }; if (s === null) { s = [e] } else { s.push(e) } o++ } if (typeof r == "number" && isFinite(r)) { if (r < 1 || isNaN(r)) { const e = { instancePath: t + "/width", schemaPath: "#/properties/width/minimum", keyword: "minimum", params: { comparison: ">=", limit: 1 }, message: "must be >= 1" }; if (s === null) { s = [e] } else { s.push(e) } o++ } } } if (e.wrapWord !== undefined) { if (typeof e.wrapWord !== "boolean") { const e = { instancePath: t + "/wrapWord", schemaPath: "#/properties/wrapWord/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }; if (s === null) { s = [e] } else { s.push(e) } o++ } } if (e.truncate !== undefined) { let r = e.truncate; if (!(typeof r == "number" && (!(r % 1) && !isNaN(r)) && isFinite(r))) { const e = { instancePath: t + "/truncate", schemaPath: "#/properties/truncate/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }; if (s === null) { s = [e] } else { s.push(e) } o++ } } if (e.paddingLeft !== undefined) { let r = e.paddingLeft; if (!(typeof r == "number" && (!(r % 1) && !isNaN(r)) && isFinite(r))) { const e = { instancePath: t + "/paddingLeft", schemaPath: "#/properties/paddingLeft/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }; if (s === null) { s = [e] } else { s.push(e) } o++ } } if (e.paddingRight !== undefined) { let r = e.paddingRight; if (!(typeof r == "number" && (!(r % 1) && !isNaN(r)) && isFinite(r))) { const e = { instancePath: t + "/paddingRight", schemaPath: "#/properties/paddingRight/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }; if (s === null) { s = [e] } else { s.push(e) } o++ } } } else { const e = { instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }; if (s === null) { s = [e] } else { s.push(e) } o++ } validate113.errors = s; return o === 0 } function validate86(e, { instancePath: t = "", parentData: r, parentDataProperty: n, rootData: i = e } = {}) { let s = null; let o = 0; if (e && typeof e == "object" && !Array.isArray(e)) { if (e.columnDefault === undefined) { const e = { instancePath: t, schemaPath: "#/required", keyword: "required", params: { missingProperty: "columnDefault" }, message: "must have required property '" + "columnDefault" + "'" }; if (s === null) { s = [e] } else { s.push(e) } o++ } if (e.columnCount === undefined) { const e = { instancePath: t, schemaPath: "#/required", keyword: "required", params: { missingProperty: "columnCount" }, message: "must have required property '" + "columnCount" + "'" }; if (s === null) { s = [e] } else { s.push(e) } o++ } for (const r in e) { if (!(r === "border" || r === "columns" || r === "columnDefault" || r === "columnCount" || r === "drawVerticalLine")) { const e = { instancePath: t, schemaPath: "#/additionalProperties", keyword: "additionalProperties", params: { additionalProperty: r }, message: "must NOT have additional properties" }; if (s === null) { s = [e] } else { s.push(e) } o++ } } if (e.border !== undefined) { if (!validate87(e.border, { instancePath: t + "/border", parentData: e, parentDataProperty: "border", rootData: i })) { s = s === null ? validate87.errors : s.concat(validate87.errors); o = s.length } } if (e.columns !== undefined) { if (!validate109(e.columns, { instancePath: t + "/columns", parentData: e, parentDataProperty: "columns", rootData: i })) { s = s === null ? validate109.errors : s.concat(validate109.errors); o = s.length } } if (e.columnDefault !== undefined) { if (!validate113(e.columnDefault, { instancePath: t + "/columnDefault", parentData: e, parentDataProperty: "columnDefault", rootData: i })) { s = s === null ? validate113.errors : s.concat(validate113.errors); o = s.length } } if (e.columnCount !== undefined) { let r = e.columnCount; if (!(typeof r == "number" && (!(r % 1) && !isNaN(r)) && isFinite(r))) { const e = { instancePath: t + "/columnCount", schemaPath: "#/properties/columnCount/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }; if (s === null) { s = [e] } else { s.push(e) } o++ } if (typeof r == "number" && isFinite(r)) { if (r < 1 || isNaN(r)) { const e = { instancePath: t + "/columnCount", schemaPath: "#/properties/columnCount/minimum", keyword: "minimum", params: { comparison: ">=", limit: 1 }, message: "must be >= 1" }; if (s === null) { s = [e] } else { s.push(e) } o++ } } } if (e.drawVerticalLine !== undefined) { if (typeof e.drawVerticalLine != "function") { const e = { instancePath: t + "/drawVerticalLine", schemaPath: "#/properties/drawVerticalLine/typeof", keyword: "typeof", params: {}, message: 'must pass "typeof" keyword validation' }; if (s === null) { s = [e] } else { s.push(e) } o++ } } } else { const e = { instancePath: t, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }; if (s === null) { s = [e] } else { s.push(e) } o++ } validate86.errors = s; return o === 0 } }, 1726: (e, t) => { Object.defineProperty(t, "__esModule", { value: true }); t.getBorderCharacters = void 0; const getBorderCharacters = e => { if (e === "honeywell") { return { topBody: "═", topJoin: "╤", topLeft: "╔", topRight: "╗", bottomBody: "═", bottomJoin: "╧", bottomLeft: "╚", bottomRight: "╝", bodyLeft: "║", bodyRight: "║", bodyJoin: "│", headerJoin: "┬", joinBody: "─", joinLeft: "╟", joinRight: "╢", joinJoin: "┼", joinMiddleDown: "┬", joinMiddleUp: "┴", joinMiddleLeft: "┤", joinMiddleRight: "├" } } if (e === "norc") { return { topBody: "─", topJoin: "┬", topLeft: "┌", topRight: "┐", bottomBody: "─", bottomJoin: "┴", bottomLeft: "└", bottomRight: "┘", bodyLeft: "│", bodyRight: "│", bodyJoin: "│", headerJoin: "┬", joinBody: "─", joinLeft: "├", joinRight: "┤", joinJoin: "┼", joinMiddleDown: "┬", joinMiddleUp: "┴", joinMiddleLeft: "┤", joinMiddleRight: "├" } } if (e === "ramac") { return { topBody: "-", topJoin: "+", topLeft: "+", topRight: "+", bottomBody: "-", bottomJoin: "+", bottomLeft: "+", bottomRight: "+", bodyLeft: "|", bodyRight: "|", bodyJoin: "|", headerJoin: "+", joinBody: "-", joinLeft: "|", joinRight: "|", joinJoin: "|", joinMiddleDown: "+", joinMiddleUp: "+", joinMiddleLeft: "+", joinMiddleRight: "+" } } if (e === "void") { return { topBody: "", topJoin: "", topLeft: "", topRight: "", bottomBody: "", bottomJoin: "", bottomLeft: "", bottomRight: "", bodyLeft: "", bodyRight: "", bodyJoin: "", headerJoin: "", joinBody: "", joinLeft: "", joinRight: "", joinJoin: "", joinMiddleDown: "", joinMiddleUp: "", joinMiddleLeft: "", joinMiddleRight: "" } } throw new Error('Unknown border template "' + e + '".') }; t.getBorderCharacters = getBorderCharacters }, 3756: function (e, t, r) { var n = this && this.__createBinding || (Object.create ? function (e, t, r, n) { if (n === undefined) n = r; Object.defineProperty(e, n, { enumerable: true, get: function () { return t[r] } }) } : function (e, t, r, n) { if (n === undefined) n = r; e[n] = t[r] }); var i = this && this.__exportStar || function (e, t) { for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r) }; Object.defineProperty(t, "__esModule", { value: true }); t.getBorderCharacters = t.createStream = t.table = void 0; const s = r(7627); Object.defineProperty(t, "createStream", { enumerable: true, get: function () { return s.createStream } }); const o = r(1726); Object.defineProperty(t, "getBorderCharacters", { enumerable: true, get: function () { return o.getBorderCharacters } }); const a = r(2676); Object.defineProperty(t, "table", { enumerable: true, get: function () { return a.table } }); i(r(4935), t) }, 9522: (e, t) => { Object.defineProperty(t, "__esModule", { value: true }); t.injectHeaderConfig = void 0; const injectHeaderConfig = (e, t) => { var r; let n = (r = t.spanningCells) !== null && r !== void 0 ? r : []; const i = t.header; const s = [...e]; if (i) { n = n.map((({ row: e, ...t }) => ({ ...t, row: e + 1 }))); const { content: t, ...r } = i; n.unshift({ alignment: "center", col: 0, colSpan: e[0].length, paddingLeft: 1, paddingRight: 1, row: 0, wrapWord: false, ...r }); s.unshift([t, ...Array.from({ length: e[0].length - 1 }).fill("")]) } return [s, n] }; t.injectHeaderConfig = injectHeaderConfig }, 774: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t.makeRangeConfig = void 0; const n = r(6500); const makeRangeConfig = (e, t) => { var r; const { topLeft: i, bottomRight: s } = (0, n.calculateRangeCoordinate)(e); const o = { ...t[i.col], ...e, paddingRight: (r = e.paddingRight) !== null && r !== void 0 ? r : t[s.col].paddingRight }; return { ...o, bottomRight: s, topLeft: i } }; t.makeRangeConfig = makeRangeConfig }, 7922: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t.makeStreamConfig = void 0; const n = r(6500); const i = r(2683); const makeColumnsConfig = (e, t = {}, r) => Array.from({ length: e }).map(((e, n) => ({ alignment: "left", paddingLeft: 1, paddingRight: 1, truncate: Number.POSITIVE_INFINITY, verticalAlignment: "top", wrapWord: false, ...r, ...t[n] }))); const makeStreamConfig = e => { (0, i.validateConfig)("streamConfig.json", e); if (e.columnDefault.width === undefined) { throw new Error("Must provide config.columnDefault.width when creating a stream.") } return { drawVerticalLine: () => true, ...e, border: (0, n.makeBorderConfig)(e.border), columns: makeColumnsConfig(e.columnCount, e.columns, e.columnDefault) } }; t.makeStreamConfig = makeStreamConfig }, 7667: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t.makeTableConfig = void 0; const n = r(1605); const i = r(7860); const s = r(6500); const o = r(2683); const a = r(1342); const makeColumnsConfig = (e, t, r, i) => { const s = (0, n.calculateMaximumColumnWidths)(e, i); return e[0].map(((e, n) => ({ alignment: "left", paddingLeft: 1, paddingRight: 1, truncate: Number.POSITIVE_INFINITY, verticalAlignment: "top", width: s[n], wrapWord: false, ...r, ...t === null || t === void 0 ? void 0 : t[n] }))) }; const makeTableConfig = (e, t = {}, r) => { var n, u, l, f, d; (0, o.validateConfig)("config.json", t); (0, a.validateSpanningCellConfig)(e, (n = t.spanningCells) !== null && n !== void 0 ? n : []); const p = (u = r !== null && r !== void 0 ? r : t.spanningCells) !== null && u !== void 0 ? u : []; const h = makeColumnsConfig(e, t.columns, t.columnDefault, p); const m = (l = t.drawVerticalLine) !== null && l !== void 0 ? l : () => true; const g = (f = t.drawHorizontalLine) !== null && f !== void 0 ? f : () => true; return { ...t, border: (0, s.makeBorderConfig)(t.border), columns: h, drawHorizontalLine: g, drawVerticalLine: m, singleLine: (d = t.singleLine) !== null && d !== void 0 ? d : false, spanningCellManager: (0, i.createSpanningCellManager)({ columnsConfig: h, drawHorizontalLine: g, drawVerticalLine: m, rows: e, spanningCellConfigs: p }) } }; t.makeTableConfig = makeTableConfig }, 9156: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t.mapDataUsingRowHeights = t.padCellVertically = void 0; const n = r(6500); const i = r(3442); const createEmptyStrings = e => new Array(e).fill(""); const padCellVertically = (e, t, r) => { const n = t - e.length; if (r === "top") { return [...e, ...createEmptyStrings(n)] } if (r === "bottom") { return [...createEmptyStrings(n), ...e] } return [...createEmptyStrings(Math.floor(n / 2)), ...e, ...createEmptyStrings(Math.ceil(n / 2))] }; t.padCellVertically = padCellVertically; const mapDataUsingRowHeights = (e, r, s) => { const o = e[0].length; const a = e.map(((e, n) => { const a = r[n]; const u = Array.from({ length: a }, (() => new Array(o).fill(""))); e.forEach(((e, r) => { var o; const l = (o = s.spanningCellManager) === null || o === void 0 ? void 0 : o.getContainingRange({ col: r, row: n }); if (l) { l.extractCellContent(n).forEach(((e, t) => { u[t][r] = e })); return } const f = (0, i.wrapCell)(e, s.columns[r].width, s.columns[r].wrapWord); const d = (0, t.padCellVertically)(f, a, s.columns[r].verticalAlignment); d.forEach(((e, t) => { u[t][r] = e })) })); return u })); return (0, n.flatten)(a) }; t.mapDataUsingRowHeights = mapDataUsingRowHeights }, 1285: (e, t) => { Object.defineProperty(t, "__esModule", { value: true }); t.padTableData = t.padString = void 0; const padString = (e, t, r) => " ".repeat(t) + e + " ".repeat(r); t.padString = padString; const padTableData = (e, r) => e.map(((e, n) => e.map(((e, i) => { var s; const o = (s = r.spanningCellManager) === null || s === void 0 ? void 0 : s.getContainingRange({ col: i, row: n }, { mapped: true }); if (o) { return e } const { paddingLeft: a, paddingRight: u } = r.columns[i]; return (0, t.padString)(e, a, u) })))); t.padTableData = padTableData }, 7860: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t.createSpanningCellManager = void 0; const n = r(9556); const i = r(1102); const s = r(774); const o = r(6500); const findRangeConfig = (e, t) => t.find((t => (0, o.isCellInRange)(e, t))); const getContainingRange = (e, t) => { const r = (0, i.calculateSpanningCellWidth)(e, t); const s = (0, n.wrapRangeContent)(e, r, t); const a = (0, n.alignVerticalRangeContent)(e, s, t); const getCellContent = r => { const { topLeft: n } = e; const { drawHorizontalLine: i, rowHeights: s } = t; const u = r - n.row; const l = (0, o.sequence)(n.row + 1, r).filter((e => !(i === null || i === void 0 ? void 0 : i(e, s.length)))).length; const f = (0, o.sumArray)(s.slice(n.row, r)) + u - l; return a.slice(f, f + s[r]) }; const getBorderContent = r => { const { topLeft: n } = e; const i = (0, o.sumArray)(t.rowHeights.slice(n.row, r)) + (r - n.row - 1); return a[i] }; return { ...e, extractBorderContent: getBorderContent, extractCellContent: getCellContent, height: s.length, width: r } }; const inSameRange = (e, t, r) => { const n = findRangeConfig(e, r); const i = findRangeConfig(t, r); if (n && i) { return (0, o.areCellEqual)(n.topLeft, i.topLeft) } return false }; const hashRange = e => { const { row: t, col: r } = e.topLeft; return `${t}/${r}` }; const createSpanningCellManager = e => { const { spanningCellConfigs: t, columnsConfig: r } = e; const n = t.map((e => (0, s.makeRangeConfig)(e, r))); const i = {}; let a = []; return { getContainingRange: (t, r) => { var s; const u = (r === null || r === void 0 ? void 0 : r.mapped) ? (0, o.findOriginalRowIndex)(a, t.row) : t.row; const l = findRangeConfig({ ...t, row: u }, n); if (!l) { return undefined } if (a.length === 0) { return getContainingRange(l, { ...e, rowHeights: a }) } const f = hashRange(l); (s = i[f]) !== null && s !== void 0 ? s : i[f] = getContainingRange(l, { ...e, rowHeights: a }); return i[f] }, inSameRange: (e, t) => inSameRange(e, t, n), rowHeights: a, setRowHeights: e => { a = e } } }; t.createSpanningCellManager = createSpanningCellManager }, 4969: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t.stringifyTableData = void 0; const n = r(6500); const stringifyTableData = e => e.map((e => e.map((e => (0, n.normalizeString)(String(e)))))); t.stringifyTableData = stringifyTableData }, 2676: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t.table = void 0; const n = r(8439); const i = r(4197); const s = r(5358); const o = r(2458); const a = r(9522); const u = r(7667); const l = r(9156); const f = r(1285); const d = r(4969); const p = r(134); const h = r(6500); const m = r(375); const table = (e, t = {}) => { (0, m.validateTableData)(e); let r = (0, d.stringifyTableData)(e); const [g, y] = (0, a.injectHeaderConfig)(r, t); const b = (0, u.makeTableConfig)(g, t, y); r = (0, p.truncateTableData)(g, (0, h.extractTruncates)(b)); const _ = (0, s.calculateRowHeights)(r, b); b.spanningCellManager.setRowHeights(_); r = (0, l.mapDataUsingRowHeights)(r, _, b); r = (0, n.alignTableData)(r, b); r = (0, f.padTableData)(r, b); const v = (0, i.calculateOutputColumnWidths)(b); return (0, o.drawTable)(r, v, _, b) }; t.table = table }, 134: function (e, t, r) { var n = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: true }); t.truncateTableData = t.truncateString = void 0; const i = n(r(4436)); const truncateString = (e, t) => (0, i.default)(e, { length: t, omission: "…" }); t.truncateString = truncateString; const truncateTableData = (e, r) => e.map((e => e.map(((e, n) => (0, t.truncateString)(e, r[n]))))); t.truncateTableData = truncateTableData }, 4935: (e, t) => { Object.defineProperty(t, "__esModule", { value: true }) }, 6500: function (e, t, r) { var n = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: true }); t.isCellInRange = t.areCellEqual = t.calculateRangeCoordinate = t.findOriginalRowIndex = t.flatten = t.extractTruncates = t.sumArray = t.sequence = t.distributeUnevenly = t.countSpaceSequence = t.groupBySizes = t.makeBorderConfig = t.splitAnsi = t.normalizeString = void 0; const i = n(r(2931)); const s = n(r(2577)); const o = n(r(4743)); const a = r(1726); const normalizeString = e => e.replace(/\r\n/g, "\n"); t.normalizeString = normalizeString; const splitAnsi = e => { const t = (0, o.default)(e).split("\n").map(s.default); const r = []; let n = 0; t.forEach((t => { r.push(t === 0 ? "" : (0, i.default)(e, n, n + t)); n += t + 1 })); return r }; t.splitAnsi = splitAnsi; const makeBorderConfig = e => ({ ...(0, a.getBorderCharacters)("honeywell"), ...e }); t.makeBorderConfig = makeBorderConfig; const groupBySizes = (e, t) => { let r = 0; return t.map((t => { const n = e.slice(r, r + t); r += t; return n })) }; t.groupBySizes = groupBySizes; const countSpaceSequence = e => { var t, r; return (r = (t = e.match(/\s+/g)) === null || t === void 0 ? void 0 : t.length) !== null && r !== void 0 ? r : 0 }; t.countSpaceSequence = countSpaceSequence; const distributeUnevenly = (e, t) => { const r = Array.from({ length: t }).fill(Math.floor(e / t)); return r.map(((r, n) => r + (n < e % t ? 1 : 0))) }; t.distributeUnevenly = distributeUnevenly; const sequence = (e, t) => Array.from({ length: t - e + 1 }, ((t, r) => r + e)); t.sequence = sequence; const sumArray = e => e.reduce(((e, t) => e + t), 0); t.sumArray = sumArray; const extractTruncates = e => e.columns.map((({ truncate: e }) => e)); t.extractTruncates = extractTruncates; const flatten = e => [].concat(...e); t.flatten = flatten; const findOriginalRowIndex = (e, r) => { const n = (0, t.flatten)(e.map(((e, t) => Array.from({ length: e }, (() => t))))); return n[r] }; t.findOriginalRowIndex = findOriginalRowIndex; const calculateRangeCoordinate = e => { const { row: t, col: r, colSpan: n = 1, rowSpan: i = 1 } = e; return { bottomRight: { col: r + n - 1, row: t + i - 1 }, topLeft: { col: r, row: t } } }; t.calculateRangeCoordinate = calculateRangeCoordinate; const areCellEqual = (e, t) => e.row === t.row && e.col === t.col; t.areCellEqual = areCellEqual; const isCellInRange = (e, { topLeft: t, bottomRight: r }) => t.row <= e.row && e.row <= r.row && t.col <= e.col && e.col <= r.col; t.isCellInRange = isCellInRange }, 2683: function (e, t, r) { var n = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: true }); t.validateConfig = void 0; const i = n(r(5951)); const validateConfig = (e, t) => { const r = i.default[e]; if (!r(t) && r.errors) { const e = r.errors.map((e => ({ message: e.message, params: e.params, schemaPath: e.schemaPath }))); console.log("config", t); console.log("errors", e); throw new Error("Invalid config.") } }; t.validateConfig = validateConfig }, 1342: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t.validateSpanningCellConfig = void 0; const n = r(6500); const inRange = (e, t, r) => e <= r && r <= t; const validateSpanningCellConfig = (e, t) => { const [r, i] = [e.length, e[0].length]; t.forEach(((e, t) => { const { colSpan: r, rowSpan: n } = e; if (r === undefined && n === undefined) { throw new Error(`Expect at least colSpan or rowSpan is provided in config.spanningCells[${t}]`) } if (r !== undefined && r < 1) { throw new Error(`Expect colSpan is not equal zero, instead got: ${r} in config.spanningCells[${t}]`) } if (n !== undefined && n < 1) { throw new Error(`Expect rowSpan is not equal zero, instead got: ${n} in config.spanningCells[${t}]`) } })); const s = t.map(n.calculateRangeCoordinate); s.forEach((({ topLeft: e, bottomRight: t }, n) => { if (!inRange(0, i - 1, e.col) || !inRange(0, r - 1, e.row) || !inRange(0, i - 1, t.col) || !inRange(0, r - 1, t.row)) { throw new Error(`Some cells in config.spanningCells[${n}] are out of the table`) } })); const o = Array.from({ length: r }, (() => Array.from({ length: i }))); s.forEach((({ topLeft: e, bottomRight: t }, r) => { (0, n.sequence)(e.row, t.row).forEach((i => { (0, n.sequence)(e.col, t.col).forEach((e => { if (o[i][e] !== undefined) { throw new Error(`Spanning cells in config.spanningCells[${o[i][e]}] and config.spanningCells[${r}] are overlap each other`) } o[i][e] = r })) })) })) }; t.validateSpanningCellConfig = validateSpanningCellConfig }, 375: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t.validateTableData = void 0; const n = r(6500); const validateTableData = e => { if (!Array.isArray(e)) { throw new TypeError("Table data must be an array.") } if (e.length === 0) { throw new Error("Table must define at least one row.") } if (e[0].length === 0) { throw new Error("Table must define at least one column.") } const t = e[0].length; for (const r of e) { if (!Array.isArray(r)) { throw new TypeError("Table row data must be an array.") } if (r.length !== t) { throw new Error("Table must have a consistent number of cells.") } for (const e of r) { if (/[\u0001-\u0006\u0008\u0009\u000B-\u001A]/.test((0, n.normalizeString)(String(e)))) { throw new Error("Table data must not contain control characters.") } } } }; t.validateTableData = validateTableData }, 3442: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t.wrapCell = void 0; const n = r(6500); const i = r(9466); const s = r(2561); const wrapCell = (e, t, r) => { const o = (0, n.splitAnsi)(e); for (let e = 0; e < o.length;) { let n; if (r) { n = (0, s.wrapWord)(o[e], t) } else { n = (0, i.wrapString)(o[e], t) } o.splice(e, 1, ...n); e += n.length } return o }; t.wrapCell = wrapCell }, 9466: function (e, t, r) { var n = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: true }); t.wrapString = void 0; const i = n(r(2931)); const s = n(r(2577)); const wrapString = (e, t) => { let r = e; const n = []; do { n.push((0, i.default)(r, 0, t)); r = (0, i.default)(r, t).trim() } while ((0, s.default)(r)); return n }; t.wrapString = wrapString }, 2561: function (e, t, r) { var n = this && this.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(t, "__esModule", { value: true }); t.wrapWord = void 0; const i = n(r(2931)); const s = n(r(4743)); const calculateStringLengths = (e, t) => { let r = (0, s.default)(e); const n = []; const i = new RegExp("(^.{1," + String(Math.max(t, 1)) + "}(\\s+|$))|(^.{1," + String(Math.max(t - 1, 1)) + "}(\\\\|/|_|\\.|,|;|-))"); do { let e; const s = i.exec(r); if (s) { e = s[0]; r = r.slice(e.length); const t = e.trim().length; const i = e.length - t; n.push([t, i]) } else { e = r.slice(0, t); r = r.slice(t); n.push([e.length, 0]) } } while (r.length); return n }; const wrapWord = (e, t) => { const r = []; let n = 0; calculateStringLengths(e, t).forEach((([t, s]) => { r.push((0, i.default)(e, n, n + t)); n += t + s })); return r }; t.wrapWord = wrapWord }, 445: e => { e.exports = ({ onlyFirst: e = false } = {}) => { const t = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|"); return new RegExp(t, e ? undefined : "g") } }, 4743: (e, t, r) => { const n = r(445); e.exports = e => typeof e === "string" ? e.replace(n(), "") : e }, 1861: (e, t, r) => {
    /*!
     * to-regex-range <https://github.com/micromatch/to-regex-range>
     *
     * Copyright (c) 2015-present, Jon Schlinkert.
     * Released under the MIT License.
     */
    const n = r(5680); const toRegexRange = (e, t, r) => { if (n(e) === false) { throw new TypeError("toRegexRange: expected the first argument to be a number") } if (t === void 0 || e === t) { return String(e) } if (n(t) === false) { throw new TypeError("toRegexRange: expected the second argument to be a number.") } let i = { relaxZeros: true, ...r }; if (typeof i.strictZeros === "boolean") { i.relaxZeros = i.strictZeros === false } let s = String(i.relaxZeros); let o = String(i.shorthand); let a = String(i.capture); let u = String(i.wrap); let l = e + ":" + t + "=" + s + o + a + u; if (toRegexRange.cache.hasOwnProperty(l)) { return toRegexRange.cache[l].result } let f = Math.min(e, t); let d = Math.max(e, t); if (Math.abs(f - d) === 1) { let r = e + "|" + t; if (i.capture) { return `(${r})` } if (i.wrap === false) { return r } return `(?:${r})` } let p = hasPadding(e) || hasPadding(t); let h = { min: e, max: t, a: f, b: d }; let m = []; let g = []; if (p) { h.isPadded = p; h.maxLen = String(h.max).length } if (f < 0) { let e = d < 0 ? Math.abs(d) : 1; g = splitToPatterns(e, Math.abs(f), h, i); f = h.a = 0 } if (d >= 0) { m = splitToPatterns(f, d, h, i) } h.negatives = g; h.positives = m; h.result = collatePatterns(g, m, i); if (i.capture === true) { h.result = `(${h.result})` } else if (i.wrap !== false && m.length + g.length > 1) { h.result = `(?:${h.result})` } toRegexRange.cache[l] = h; return h.result }; function collatePatterns(e, t, r) { let n = filterPatterns(e, t, "-", false, r) || []; let i = filterPatterns(t, e, "", false, r) || []; let s = filterPatterns(e, t, "-?", true, r) || []; let o = n.concat(s).concat(i); return o.join("|") } function splitToRanges(e, t) { let r = 1; let n = 1; let i = countNines(e, r); let s = new Set([t]); while (e <= i && i <= t) { s.add(i); r += 1; i = countNines(e, r) } i = countZeros(t + 1, n) - 1; while (e < i && i <= t) { s.add(i); n += 1; i = countZeros(t + 1, n) - 1 } s = [...s]; s.sort(compare); return s } function rangeToPattern(e, t, r) { if (e === t) { return { pattern: e, count: [], digits: 0 } } let n = zip(e, t); let i = n.length; let s = ""; let o = 0; for (let e = 0; e < i; e++) { let [t, i] = n[e]; if (t === i) { s += t } else if (t !== "0" || i !== "9") { s += toCharacterClass(t, i, r) } else { o++ } } if (o) { s += r.shorthand === true ? "\\d" : "[0-9]" } return { pattern: s, count: [o], digits: i } } function splitToPatterns(e, t, r, n) { let i = splitToRanges(e, t); let s = []; let o = e; let a; for (let e = 0; e < i.length; e++) { let t = i[e]; let u = rangeToPattern(String(o), String(t), n); let l = ""; if (!r.isPadded && a && a.pattern === u.pattern) { if (a.count.length > 1) { a.count.pop() } a.count.push(u.count[0]); a.string = a.pattern + toQuantifier(a.count); o = t + 1; continue } if (r.isPadded) { l = padZeros(t, r, n) } u.string = l + u.pattern + toQuantifier(u.count); s.push(u); o = t + 1; a = u } return s } function filterPatterns(e, t, r, n, i) { let s = []; for (let i of e) { let { string: e } = i; if (!n && !contains(t, "string", e)) { s.push(r + e) } if (n && contains(t, "string", e)) { s.push(r + e) } } return s } function zip(e, t) { let r = []; for (let n = 0; n < e.length; n++)r.push([e[n], t[n]]); return r } function compare(e, t) { return e > t ? 1 : t > e ? -1 : 0 } function contains(e, t, r) { return e.some((e => e[t] === r)) } function countNines(e, t) { return Number(String(e).slice(0, -t) + "9".repeat(t)) } function countZeros(e, t) { return e - e % Math.pow(10, t) } function toQuantifier(e) { let [t = 0, r = ""] = e; if (r || t > 1) { return `{${t + (r ? "," + r : "")}}` } return "" } function toCharacterClass(e, t, r) { return `[${e}${t - e === 1 ? "" : "-"}${t}]` } function hasPadding(e) { return /^-?(0+)\d/.test(e) } function padZeros(e, t, r) { if (!t.isPadded) { return e } let n = Math.abs(t.maxLen - String(e).length); let i = r.relaxZeros !== false; switch (n) { case 0: return ""; case 1: return i ? "0?" : "0"; case 2: return i ? "0{0,2}" : "00"; default: { return i ? `0{0,${n}}` : `0{${n}}` } } } toRegexRange.cache = {}; toRegexRange.clearCache = () => toRegexRange.cache = {}; e.exports = toRegexRange
  }, 4294: (e, t, r) => { e.exports = r(4219) }, 4219: (e, t, r) => { var n = r(1808); var i = r(4404); var s = r(3685); var o = r(5687); var a = r(2361); var u = r(9491); var l = r(3837); t.httpOverHttp = httpOverHttp; t.httpsOverHttp = httpsOverHttp; t.httpOverHttps = httpOverHttps; t.httpsOverHttps = httpsOverHttps; function httpOverHttp(e) { var t = new TunnelingAgent(e); t.request = s.request; return t } function httpsOverHttp(e) { var t = new TunnelingAgent(e); t.request = s.request; t.createSocket = createSecureSocket; t.defaultPort = 443; return t } function httpOverHttps(e) { var t = new TunnelingAgent(e); t.request = o.request; return t } function httpsOverHttps(e) { var t = new TunnelingAgent(e); t.request = o.request; t.createSocket = createSecureSocket; t.defaultPort = 443; return t } function TunnelingAgent(e) { var t = this; t.options = e || {}; t.proxyOptions = t.options.proxy || {}; t.maxSockets = t.options.maxSockets || s.Agent.defaultMaxSockets; t.requests = []; t.sockets = []; t.on("free", (function onFree(e, r, n, i) { var s = toOptions(r, n, i); for (var o = 0, a = t.requests.length; o < a; ++o) { var u = t.requests[o]; if (u.host === s.host && u.port === s.port) { t.requests.splice(o, 1); u.request.onSocket(e); return } } e.destroy(); t.removeSocket(e) })) } l.inherits(TunnelingAgent, a.EventEmitter); TunnelingAgent.prototype.addRequest = function addRequest(e, t, r, n) { var i = this; var s = mergeOptions({ request: e }, i.options, toOptions(t, r, n)); if (i.sockets.length >= this.maxSockets) { i.requests.push(s); return } i.createSocket(s, (function (t) { t.on("free", onFree); t.on("close", onCloseOrRemove); t.on("agentRemove", onCloseOrRemove); e.onSocket(t); function onFree() { i.emit("free", t, s) } function onCloseOrRemove(e) { i.removeSocket(t); t.removeListener("free", onFree); t.removeListener("close", onCloseOrRemove); t.removeListener("agentRemove", onCloseOrRemove) } })) }; TunnelingAgent.prototype.createSocket = function createSocket(e, t) { var r = this; var n = {}; r.sockets.push(n); var i = mergeOptions({}, r.proxyOptions, { method: "CONNECT", path: e.host + ":" + e.port, agent: false, headers: { host: e.host + ":" + e.port } }); if (e.localAddress) { i.localAddress = e.localAddress } if (i.proxyAuth) { i.headers = i.headers || {}; i.headers["Proxy-Authorization"] = "Basic " + new Buffer(i.proxyAuth).toString("base64") } f("making CONNECT request"); var s = r.request(i); s.useChunkedEncodingByDefault = false; s.once("response", onResponse); s.once("upgrade", onUpgrade); s.once("connect", onConnect); s.once("error", onError); s.end(); function onResponse(e) { e.upgrade = true } function onUpgrade(e, t, r) { process.nextTick((function () { onConnect(e, t, r) })) } function onConnect(i, o, a) { s.removeAllListeners(); o.removeAllListeners(); if (i.statusCode !== 200) { f("tunneling socket could not be established, statusCode=%d", i.statusCode); o.destroy(); var u = new Error("tunneling socket could not be established, " + "statusCode=" + i.statusCode); u.code = "ECONNRESET"; e.request.emit("error", u); r.removeSocket(n); return } if (a.length > 0) { f("got illegal response body from proxy"); o.destroy(); var u = new Error("got illegal response body from proxy"); u.code = "ECONNRESET"; e.request.emit("error", u); r.removeSocket(n); return } f("tunneling connection has established"); r.sockets[r.sockets.indexOf(n)] = o; return t(o) } function onError(t) { s.removeAllListeners(); f("tunneling socket could not be established, cause=%s\n", t.message, t.stack); var i = new Error("tunneling socket could not be established, " + "cause=" + t.message); i.code = "ECONNRESET"; e.request.emit("error", i); r.removeSocket(n) } }; TunnelingAgent.prototype.removeSocket = function removeSocket(e) { var t = this.sockets.indexOf(e); if (t === -1) { return } this.sockets.splice(t, 1); var r = this.requests.shift(); if (r) { this.createSocket(r, (function (e) { r.request.onSocket(e) })) } }; function createSecureSocket(e, t) { var r = this; TunnelingAgent.prototype.createSocket.call(r, e, (function (n) { var s = e.request.getHeader("host"); var o = mergeOptions({}, r.options, { socket: n, servername: s ? s.replace(/:.*$/, "") : e.host }); var a = i.connect(0, o); r.sockets[r.sockets.indexOf(n)] = a; t(a) })) } function toOptions(e, t, r) { if (typeof e === "string") { return { host: e, port: t, localAddress: r } } return e } function mergeOptions(e) { for (var t = 1, r = arguments.length; t < r; ++t) { var n = arguments[t]; if (typeof n === "object") { var i = Object.keys(n); for (var s = 0, o = i.length; s < o; ++s) { var a = i[s]; if (n[a] !== undefined) { e[a] = n[a] } } } } return e } var f; if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) { f = function () { var e = Array.prototype.slice.call(arguments); if (typeof e[0] === "string") { e[0] = "TUNNEL: " + e[0] } else { e.unshift("TUNNEL:") } console.error.apply(console, e) } } else { f = function () { } } t.debug = f }, 9046: (e, t) => { t.fromCallback = function (e) { return Object.defineProperty((function (...t) { if (typeof t[t.length - 1] === "function") e.apply(this, t); else { return new Promise(((r, n) => { e.call(this, ...t, ((e, t) => e != null ? n(e) : r(t))) })) } }), "name", { value: e.name }) }; t.fromPromise = function (e) { return Object.defineProperty((function (...t) { const r = t[t.length - 1]; if (typeof r !== "function") return e.apply(this, t); else e.apply(this, t.slice(0, -1)).then((e => r(null, e)), r) }), "name", { value: e.name }) } }, 7127: (e, t, r) => { e.exports = r(3837).deprecate }, 5840: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); Object.defineProperty(t, "v1", { enumerable: true, get: function () { return n.default } }); Object.defineProperty(t, "v3", { enumerable: true, get: function () { return i.default } }); Object.defineProperty(t, "v4", { enumerable: true, get: function () { return s.default } }); Object.defineProperty(t, "v5", { enumerable: true, get: function () { return o.default } }); Object.defineProperty(t, "NIL", { enumerable: true, get: function () { return a.default } }); Object.defineProperty(t, "version", { enumerable: true, get: function () { return u.default } }); Object.defineProperty(t, "validate", { enumerable: true, get: function () { return l.default } }); Object.defineProperty(t, "stringify", { enumerable: true, get: function () { return f.default } }); Object.defineProperty(t, "parse", { enumerable: true, get: function () { return d.default } }); var n = _interopRequireDefault(r(8628)); var i = _interopRequireDefault(r(6409)); var s = _interopRequireDefault(r(5122)); var o = _interopRequireDefault(r(9120)); var a = _interopRequireDefault(r(5332)); var u = _interopRequireDefault(r(1595)); var l = _interopRequireDefault(r(6900)); var f = _interopRequireDefault(r(8950)); var d = _interopRequireDefault(r(2746)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } }, 4569: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t["default"] = void 0; var n = _interopRequireDefault(r(6113)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function md5(e) { if (Array.isArray(e)) { e = Buffer.from(e) } else if (typeof e === "string") { e = Buffer.from(e, "utf8") } return n.default.createHash("md5").update(e).digest() } var i = md5; t["default"] = i }, 5332: (e, t) => { Object.defineProperty(t, "__esModule", { value: true }); t["default"] = void 0; var r = "00000000-0000-0000-0000-000000000000"; t["default"] = r }, 2746: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t["default"] = void 0; var n = _interopRequireDefault(r(6900)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function parse(e) { if (!(0, n.default)(e)) { throw TypeError("Invalid UUID") } let t; const r = new Uint8Array(16); r[0] = (t = parseInt(e.slice(0, 8), 16)) >>> 24; r[1] = t >>> 16 & 255; r[2] = t >>> 8 & 255; r[3] = t & 255; r[4] = (t = parseInt(e.slice(9, 13), 16)) >>> 8; r[5] = t & 255; r[6] = (t = parseInt(e.slice(14, 18), 16)) >>> 8; r[7] = t & 255; r[8] = (t = parseInt(e.slice(19, 23), 16)) >>> 8; r[9] = t & 255; r[10] = (t = parseInt(e.slice(24, 36), 16)) / 1099511627776 & 255; r[11] = t / 4294967296 & 255; r[12] = t >>> 24 & 255; r[13] = t >>> 16 & 255; r[14] = t >>> 8 & 255; r[15] = t & 255; return r } var i = parse; t["default"] = i }, 814: (e, t) => { Object.defineProperty(t, "__esModule", { value: true }); t["default"] = void 0; var r = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i; t["default"] = r }, 807: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t["default"] = rng; var n = _interopRequireDefault(r(6113)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } const i = new Uint8Array(256); let s = i.length; function rng() { if (s > i.length - 16) { n.default.randomFillSync(i); s = 0 } return i.slice(s, s += 16) } }, 5274: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t["default"] = void 0; var n = _interopRequireDefault(r(6113)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function sha1(e) { if (Array.isArray(e)) { e = Buffer.from(e) } else if (typeof e === "string") { e = Buffer.from(e, "utf8") } return n.default.createHash("sha1").update(e).digest() } var i = sha1; t["default"] = i }, 8950: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t["default"] = void 0; var n = _interopRequireDefault(r(6900)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } const i = []; for (let e = 0; e < 256; ++e) { i.push((e + 256).toString(16).substr(1)) } function stringify(e, t = 0) { const r = (i[e[t + 0]] + i[e[t + 1]] + i[e[t + 2]] + i[e[t + 3]] + "-" + i[e[t + 4]] + i[e[t + 5]] + "-" + i[e[t + 6]] + i[e[t + 7]] + "-" + i[e[t + 8]] + i[e[t + 9]] + "-" + i[e[t + 10]] + i[e[t + 11]] + i[e[t + 12]] + i[e[t + 13]] + i[e[t + 14]] + i[e[t + 15]]).toLowerCase(); if (!(0, n.default)(r)) { throw TypeError("Stringified UUID is invalid") } return r } var s = stringify; t["default"] = s }, 8628: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t["default"] = void 0; var n = _interopRequireDefault(r(807)); var i = _interopRequireDefault(r(8950)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } let s; let o; let a = 0; let u = 0; function v1(e, t, r) { let l = t && r || 0; const f = t || new Array(16); e = e || {}; let d = e.node || s; let p = e.clockseq !== undefined ? e.clockseq : o; if (d == null || p == null) { const t = e.random || (e.rng || n.default)(); if (d == null) { d = s = [t[0] | 1, t[1], t[2], t[3], t[4], t[5]] } if (p == null) { p = o = (t[6] << 8 | t[7]) & 16383 } } let h = e.msecs !== undefined ? e.msecs : Date.now(); let m = e.nsecs !== undefined ? e.nsecs : u + 1; const g = h - a + (m - u) / 1e4; if (g < 0 && e.clockseq === undefined) { p = p + 1 & 16383 } if ((g < 0 || h > a) && e.nsecs === undefined) { m = 0 } if (m >= 1e4) { throw new Error("uuid.v1(): Can't create more than 10M uuids/sec") } a = h; u = m; o = p; h += 122192928e5; const y = ((h & 268435455) * 1e4 + m) % 4294967296; f[l++] = y >>> 24 & 255; f[l++] = y >>> 16 & 255; f[l++] = y >>> 8 & 255; f[l++] = y & 255; const b = h / 4294967296 * 1e4 & 268435455; f[l++] = b >>> 8 & 255; f[l++] = b & 255; f[l++] = b >>> 24 & 15 | 16; f[l++] = b >>> 16 & 255; f[l++] = p >>> 8 | 128; f[l++] = p & 255; for (let e = 0; e < 6; ++e) { f[l + e] = d[e] } return t || (0, i.default)(f) } var l = v1; t["default"] = l }, 6409: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t["default"] = void 0; var n = _interopRequireDefault(r(5998)); var i = _interopRequireDefault(r(4569)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } const s = (0, n.default)("v3", 48, i.default); var o = s; t["default"] = o }, 5998: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t["default"] = _default; t.URL = t.DNS = void 0; var n = _interopRequireDefault(r(8950)); var i = _interopRequireDefault(r(2746)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function stringToBytes(e) { e = unescape(encodeURIComponent(e)); const t = []; for (let r = 0; r < e.length; ++r) { t.push(e.charCodeAt(r)) } return t } const s = "6ba7b810-9dad-11d1-80b4-00c04fd430c8"; t.DNS = s; const o = "6ba7b811-9dad-11d1-80b4-00c04fd430c8"; t.URL = o; function _default(e, t, r) { function generateUUID(e, s, o, a) { if (typeof e === "string") { e = stringToBytes(e) } if (typeof s === "string") { s = (0, i.default)(s) } if (s.length !== 16) { throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)") } let u = new Uint8Array(16 + e.length); u.set(s); u.set(e, s.length); u = r(u); u[6] = u[6] & 15 | t; u[8] = u[8] & 63 | 128; if (o) { a = a || 0; for (let e = 0; e < 16; ++e) { o[a + e] = u[e] } return o } return (0, n.default)(u) } try { generateUUID.name = e } catch (e) { } generateUUID.DNS = s; generateUUID.URL = o; return generateUUID } }, 5122: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t["default"] = void 0; var n = _interopRequireDefault(r(807)); var i = _interopRequireDefault(r(8950)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function v4(e, t, r) { e = e || {}; const s = e.random || (e.rng || n.default)(); s[6] = s[6] & 15 | 64; s[8] = s[8] & 63 | 128; if (t) { r = r || 0; for (let e = 0; e < 16; ++e) { t[r + e] = s[e] } return t } return (0, i.default)(s) } var s = v4; t["default"] = s }, 9120: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t["default"] = void 0; var n = _interopRequireDefault(r(5998)); var i = _interopRequireDefault(r(5274)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } const s = (0, n.default)("v5", 80, i.default); var o = s; t["default"] = o }, 6900: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t["default"] = void 0; var n = _interopRequireDefault(r(814)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function validate(e) { return typeof e === "string" && n.default.test(e) } var i = validate; t["default"] = i }, 1595: (e, t, r) => { Object.defineProperty(t, "__esModule", { value: true }); t["default"] = void 0; var n = _interopRequireDefault(r(6900)); function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e } } function version(e) { if (!(0, n.default)(e)) { throw TypeError("Invalid UUID") } return parseInt(e.substr(14, 1), 16) } var i = version; t["default"] = i }, 4383: e => { e.exports = [[768, 879], [1155, 1158], [1160, 1161], [1425, 1469], [1471, 1471], [1473, 1474], [1476, 1477], [1479, 1479], [1536, 1539], [1552, 1557], [1611, 1630], [1648, 1648], [1750, 1764], [1767, 1768], [1770, 1773], [1807, 1807], [1809, 1809], [1840, 1866], [1958, 1968], [2027, 2035], [2305, 2306], [2364, 2364], [2369, 2376], [2381, 2381], [2385, 2388], [2402, 2403], [2433, 2433], [2492, 2492], [2497, 2500], [2509, 2509], [2530, 2531], [2561, 2562], [2620, 2620], [2625, 2626], [2631, 2632], [2635, 2637], [2672, 2673], [2689, 2690], [2748, 2748], [2753, 2757], [2759, 2760], [2765, 2765], [2786, 2787], [2817, 2817], [2876, 2876], [2879, 2879], [2881, 2883], [2893, 2893], [2902, 2902], [2946, 2946], [3008, 3008], [3021, 3021], [3134, 3136], [3142, 3144], [3146, 3149], [3157, 3158], [3260, 3260], [3263, 3263], [3270, 3270], [3276, 3277], [3298, 3299], [3393, 3395], [3405, 3405], [3530, 3530], [3538, 3540], [3542, 3542], [3633, 3633], [3636, 3642], [3655, 3662], [3761, 3761], [3764, 3769], [3771, 3772], [3784, 3789], [3864, 3865], [3893, 3893], [3895, 3895], [3897, 3897], [3953, 3966], [3968, 3972], [3974, 3975], [3984, 3991], [3993, 4028], [4038, 4038], [4141, 4144], [4146, 4146], [4150, 4151], [4153, 4153], [4184, 4185], [4448, 4607], [4959, 4959], [5906, 5908], [5938, 5940], [5970, 5971], [6002, 6003], [6068, 6069], [6071, 6077], [6086, 6086], [6089, 6099], [6109, 6109], [6155, 6157], [6313, 6313], [6432, 6434], [6439, 6440], [6450, 6450], [6457, 6459], [6679, 6680], [6912, 6915], [6964, 6964], [6966, 6970], [6972, 6972], [6978, 6978], [7019, 7027], [7616, 7626], [7678, 7679], [8203, 8207], [8234, 8238], [8288, 8291], [8298, 8303], [8400, 8431], [12330, 12335], [12441, 12442], [43014, 43014], [43019, 43019], [43045, 43046], [64286, 64286], [65024, 65039], [65056, 65059], [65279, 65279], [65529, 65531], [68097, 68099], [68101, 68102], [68108, 68111], [68152, 68154], [68159, 68159], [119143, 119145], [119155, 119170], [119173, 119179], [119210, 119213], [119362, 119364], [917505, 917505], [917536, 917631], [917760, 917999]] }, 5917: (e, t, r) => { var n = r(732); var i = r(4383); var s = { nul: 0, control: 0 }; e.exports = function wcwidth(e) { return wcswidth(e, s) }; e.exports.config = function (e) { e = n(e || {}, s); return function wcwidth(t) { return wcswidth(t, e) } }; function wcswidth(e, t) { if (typeof e !== "string") return wcwidth(e, t); var r = 0; for (var n = 0; n < e.length; n++) { var i = wcwidth(e.charCodeAt(n), t); if (i < 0) return -1; r += i } return r } function wcwidth(e, t) { if (e === 0) return t.nul; if (e < 32 || e >= 127 && e < 160) return t.control; if (bisearch(e)) return 0; return 1 + (e >= 4352 && (e <= 4447 || e == 9001 || e == 9002 || e >= 11904 && e <= 42191 && e != 12351 || e >= 44032 && e <= 55203 || e >= 63744 && e <= 64255 || e >= 65040 && e <= 65049 || e >= 65072 && e <= 65135 || e >= 65280 && e <= 65376 || e >= 65504 && e <= 65510 || e >= 131072 && e <= 196605 || e >= 196608 && e <= 262141)) } function bisearch(e) { var t = 0; var r = i.length - 1; var n; if (e < i[0][0] || e > i[r][1]) return false; while (r >= t) { n = Math.floor((t + r) / 2); if (e > i[n][1]) t = n + 1; else if (e < i[n][0]) r = n - 1; else return true } return false } }, 4207: (e, t, r) => { const n = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys"; const i = r(1017); const s = n ? ";" : ":"; const o = r(7126); const getNotFoundError = e => Object.assign(new Error(`not found: ${e}`), { code: "ENOENT" }); const getPathInfo = (e, t) => { const r = t.colon || s; const i = e.match(/\//) || n && e.match(/\\/) ? [""] : [...n ? [process.cwd()] : [], ...(t.path || process.env.PATH || "").split(r)]; const o = n ? t.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : ""; const a = n ? o.split(r) : [""]; if (n) { if (e.indexOf(".") !== -1 && a[0] !== "") a.unshift("") } return { pathEnv: i, pathExt: a, pathExtExe: o } }; const which = (e, t, r) => { if (typeof t === "function") { r = t; t = {} } if (!t) t = {}; const { pathEnv: n, pathExt: s, pathExtExe: a } = getPathInfo(e, t); const u = []; const step = r => new Promise(((s, o) => { if (r === n.length) return t.all && u.length ? s(u) : o(getNotFoundError(e)); const a = n[r]; const l = /^".*"$/.test(a) ? a.slice(1, -1) : a; const f = i.join(l, e); const d = !l && /^\.[\\\/]/.test(e) ? e.slice(0, 2) + f : f; s(subStep(d, r, 0)) })); const subStep = (e, r, n) => new Promise(((i, l) => { if (n === s.length) return i(step(r + 1)); const f = s[n]; o(e + f, { pathExt: a }, ((s, o) => { if (!s && o) { if (t.all) u.push(e + f); else return i(e + f) } return i(subStep(e, r, n + 1)) })) })); return r ? step(0).then((e => r(null, e)), r) : step(0) }; const whichSync = (e, t) => { t = t || {}; const { pathEnv: r, pathExt: n, pathExtExe: s } = getPathInfo(e, t); const a = []; for (let u = 0; u < r.length; u++) { const l = r[u]; const f = /^".*"$/.test(l) ? l.slice(1, -1) : l; const d = i.join(f, e); const p = !f && /^\.[\\\/]/.test(e) ? e.slice(0, 2) + d : d; for (let e = 0; e < n.length; e++) { const r = p + n[e]; try { const e = o.sync(r, { pathExt: s }); if (e) { if (t.all) a.push(r); else return r } } catch (e) { } } } if (t.all && a.length) return a; if (t.nothrow) return null; throw getNotFoundError(e) }; e.exports = which; which.sync = whichSync }, 9491: e => { e.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("assert") }, 4300: e => { e.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("buffer") }, 2081: e => { e.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("child_process") }, 2057: e => { e.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("constants") }, 6113: e => { e.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("crypto") }, 2361: e => { e.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("events") }, 7147: e => { e.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("fs") }, 3685: e => { e.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("http") }, 5158: e => { e.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("http2") }, 5687: e => { e.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("https") }, 1808: e => { e.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("net") }, 2037: e => { e.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("os") }, 1017: e => { e.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("path") }, 2781: e => { e.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("stream") }, 4404: e => { e.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("tls") }, 6224: e => { e.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("tty") }, 7310: e => { e.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("url") }, 3837: e => { e.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("util") }, 9796: e => { e.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("zlib") }, 6374: e => { e.exports = JSON.parse('{"dots":{"interval":80,"frames":["⠋","⠙","⠹","⠸","⠼","⠴","⠦","⠧","⠇","⠏"]},"dots2":{"interval":80,"frames":["⣾","⣽","⣻","⢿","⡿","⣟","⣯","⣷"]},"dots3":{"interval":80,"frames":["⠋","⠙","⠚","⠞","⠖","⠦","⠴","⠲","⠳","⠓"]},"dots4":{"interval":80,"frames":["⠄","⠆","⠇","⠋","⠙","⠸","⠰","⠠","⠰","⠸","⠙","⠋","⠇","⠆"]},"dots5":{"interval":80,"frames":["⠋","⠙","⠚","⠒","⠂","⠂","⠒","⠲","⠴","⠦","⠖","⠒","⠐","⠐","⠒","⠓","⠋"]},"dots6":{"interval":80,"frames":["⠁","⠉","⠙","⠚","⠒","⠂","⠂","⠒","⠲","⠴","⠤","⠄","⠄","⠤","⠴","⠲","⠒","⠂","⠂","⠒","⠚","⠙","⠉","⠁"]},"dots7":{"interval":80,"frames":["⠈","⠉","⠋","⠓","⠒","⠐","⠐","⠒","⠖","⠦","⠤","⠠","⠠","⠤","⠦","⠖","⠒","⠐","⠐","⠒","⠓","⠋","⠉","⠈"]},"dots8":{"interval":80,"frames":["⠁","⠁","⠉","⠙","⠚","⠒","⠂","⠂","⠒","⠲","⠴","⠤","⠄","⠄","⠤","⠠","⠠","⠤","⠦","⠖","⠒","⠐","⠐","⠒","⠓","⠋","⠉","⠈","⠈"]},"dots9":{"interval":80,"frames":["⢹","⢺","⢼","⣸","⣇","⡧","⡗","⡏"]},"dots10":{"interval":80,"frames":["⢄","⢂","⢁","⡁","⡈","⡐","⡠"]},"dots11":{"interval":100,"frames":["⠁","⠂","⠄","⡀","⢀","⠠","⠐","⠈"]},"dots12":{"interval":80,"frames":["⢀⠀","⡀⠀","⠄⠀","⢂⠀","⡂⠀","⠅⠀","⢃⠀","⡃⠀","⠍⠀","⢋⠀","⡋⠀","⠍⠁","⢋⠁","⡋⠁","⠍⠉","⠋⠉","⠋⠉","⠉⠙","⠉⠙","⠉⠩","⠈⢙","⠈⡙","⢈⠩","⡀⢙","⠄⡙","⢂⠩","⡂⢘","⠅⡘","⢃⠨","⡃⢐","⠍⡐","⢋⠠","⡋⢀","⠍⡁","⢋⠁","⡋⠁","⠍⠉","⠋⠉","⠋⠉","⠉⠙","⠉⠙","⠉⠩","⠈⢙","⠈⡙","⠈⠩","⠀⢙","⠀⡙","⠀⠩","⠀⢘","⠀⡘","⠀⠨","⠀⢐","⠀⡐","⠀⠠","⠀⢀","⠀⡀"]},"dots13":{"interval":80,"frames":["⣼","⣹","⢻","⠿","⡟","⣏","⣧","⣶"]},"dots8Bit":{"interval":80,"frames":["⠀","⠁","⠂","⠃","⠄","⠅","⠆","⠇","⡀","⡁","⡂","⡃","⡄","⡅","⡆","⡇","⠈","⠉","⠊","⠋","⠌","⠍","⠎","⠏","⡈","⡉","⡊","⡋","⡌","⡍","⡎","⡏","⠐","⠑","⠒","⠓","⠔","⠕","⠖","⠗","⡐","⡑","⡒","⡓","⡔","⡕","⡖","⡗","⠘","⠙","⠚","⠛","⠜","⠝","⠞","⠟","⡘","⡙","⡚","⡛","⡜","⡝","⡞","⡟","⠠","⠡","⠢","⠣","⠤","⠥","⠦","⠧","⡠","⡡","⡢","⡣","⡤","⡥","⡦","⡧","⠨","⠩","⠪","⠫","⠬","⠭","⠮","⠯","⡨","⡩","⡪","⡫","⡬","⡭","⡮","⡯","⠰","⠱","⠲","⠳","⠴","⠵","⠶","⠷","⡰","⡱","⡲","⡳","⡴","⡵","⡶","⡷","⠸","⠹","⠺","⠻","⠼","⠽","⠾","⠿","⡸","⡹","⡺","⡻","⡼","⡽","⡾","⡿","⢀","⢁","⢂","⢃","⢄","⢅","⢆","⢇","⣀","⣁","⣂","⣃","⣄","⣅","⣆","⣇","⢈","⢉","⢊","⢋","⢌","⢍","⢎","⢏","⣈","⣉","⣊","⣋","⣌","⣍","⣎","⣏","⢐","⢑","⢒","⢓","⢔","⢕","⢖","⢗","⣐","⣑","⣒","⣓","⣔","⣕","⣖","⣗","⢘","⢙","⢚","⢛","⢜","⢝","⢞","⢟","⣘","⣙","⣚","⣛","⣜","⣝","⣞","⣟","⢠","⢡","⢢","⢣","⢤","⢥","⢦","⢧","⣠","⣡","⣢","⣣","⣤","⣥","⣦","⣧","⢨","⢩","⢪","⢫","⢬","⢭","⢮","⢯","⣨","⣩","⣪","⣫","⣬","⣭","⣮","⣯","⢰","⢱","⢲","⢳","⢴","⢵","⢶","⢷","⣰","⣱","⣲","⣳","⣴","⣵","⣶","⣷","⢸","⢹","⢺","⢻","⢼","⢽","⢾","⢿","⣸","⣹","⣺","⣻","⣼","⣽","⣾","⣿"]},"sand":{"interval":80,"frames":["⠁","⠂","⠄","⡀","⡈","⡐","⡠","⣀","⣁","⣂","⣄","⣌","⣔","⣤","⣥","⣦","⣮","⣶","⣷","⣿","⡿","⠿","⢟","⠟","⡛","⠛","⠫","⢋","⠋","⠍","⡉","⠉","⠑","⠡","⢁"]},"line":{"interval":130,"frames":["-","\\\\","|","/"]},"line2":{"interval":100,"frames":["⠂","-","–","—","–","-"]},"pipe":{"interval":100,"frames":["┤","┘","┴","└","├","┌","┬","┐"]},"simpleDots":{"interval":400,"frames":[".  ",".. ","...","   "]},"simpleDotsScrolling":{"interval":200,"frames":[".  ",".. ","..."," ..","  .","   "]},"star":{"interval":70,"frames":["✶","✸","✹","✺","✹","✷"]},"star2":{"interval":80,"frames":["+","x","*"]},"flip":{"interval":70,"frames":["_","_","_","-","`","`","\'","´","-","_","_","_"]},"hamburger":{"interval":100,"frames":["☱","☲","☴"]},"growVertical":{"interval":120,"frames":["▁","▃","▄","▅","▆","▇","▆","▅","▄","▃"]},"growHorizontal":{"interval":120,"frames":["▏","▎","▍","▌","▋","▊","▉","▊","▋","▌","▍","▎"]},"balloon":{"interval":140,"frames":[" ",".","o","O","@","*"," "]},"balloon2":{"interval":120,"frames":[".","o","O","°","O","o","."]},"noise":{"interval":100,"frames":["▓","▒","░"]},"bounce":{"interval":120,"frames":["⠁","⠂","⠄","⠂"]},"boxBounce":{"interval":120,"frames":["▖","▘","▝","▗"]},"boxBounce2":{"interval":100,"frames":["▌","▀","▐","▄"]},"triangle":{"interval":50,"frames":["◢","◣","◤","◥"]},"arc":{"interval":100,"frames":["◜","◠","◝","◞","◡","◟"]},"circle":{"interval":120,"frames":["◡","⊙","◠"]},"squareCorners":{"interval":180,"frames":["◰","◳","◲","◱"]},"circleQuarters":{"interval":120,"frames":["◴","◷","◶","◵"]},"circleHalves":{"interval":50,"frames":["◐","◓","◑","◒"]},"squish":{"interval":100,"frames":["╫","╪"]},"toggle":{"interval":250,"frames":["⊶","⊷"]},"toggle2":{"interval":80,"frames":["▫","▪"]},"toggle3":{"interval":120,"frames":["□","■"]},"toggle4":{"interval":100,"frames":["■","□","▪","▫"]},"toggle5":{"interval":100,"frames":["▮","▯"]},"toggle6":{"interval":300,"frames":["ဝ","၀"]},"toggle7":{"interval":80,"frames":["⦾","⦿"]},"toggle8":{"interval":100,"frames":["◍","◌"]},"toggle9":{"interval":100,"frames":["◉","◎"]},"toggle10":{"interval":100,"frames":["㊂","㊀","㊁"]},"toggle11":{"interval":50,"frames":["⧇","⧆"]},"toggle12":{"interval":120,"frames":["☗","☖"]},"toggle13":{"interval":80,"frames":["=","*","-"]},"arrow":{"interval":100,"frames":["←","↖","↑","↗","→","↘","↓","↙"]},"arrow2":{"interval":80,"frames":["⬆️ ","↗️ ","➡️ ","↘️ ","⬇️ ","↙️ ","⬅️ ","↖️ "]},"arrow3":{"interval":120,"frames":["▹▹▹▹▹","▸▹▹▹▹","▹▸▹▹▹","▹▹▸▹▹","▹▹▹▸▹","▹▹▹▹▸"]},"bouncingBar":{"interval":80,"frames":["[    ]","[=   ]","[==  ]","[=== ]","[ ===]","[  ==]","[   =]","[    ]","[   =]","[  ==]","[ ===]","[====]","[=== ]","[==  ]","[=   ]"]},"bouncingBall":{"interval":80,"frames":["( ●    )","(  ●   )","(   ●  )","(    ● )","(     ●)","(    ● )","(   ●  )","(  ●   )","( ●    )","(●     )"]},"smiley":{"interval":200,"frames":["😄 ","😝 "]},"monkey":{"interval":300,"frames":["🙈 ","🙈 ","🙉 ","🙊 "]},"hearts":{"interval":100,"frames":["💛 ","💙 ","💜 ","💚 ","❤️ "]},"clock":{"interval":100,"frames":["🕛 ","🕐 ","🕑 ","🕒 ","🕓 ","🕔 ","🕕 ","🕖 ","🕗 ","🕘 ","🕙 ","🕚 "]},"earth":{"interval":180,"frames":["🌍 ","🌎 ","🌏 "]},"material":{"interval":17,"frames":["█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁","██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁","███▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁","████▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁","██████▁▁▁▁▁▁▁▁▁▁▁▁▁▁","██████▁▁▁▁▁▁▁▁▁▁▁▁▁▁","███████▁▁▁▁▁▁▁▁▁▁▁▁▁","████████▁▁▁▁▁▁▁▁▁▁▁▁","█████████▁▁▁▁▁▁▁▁▁▁▁","█████████▁▁▁▁▁▁▁▁▁▁▁","██████████▁▁▁▁▁▁▁▁▁▁","███████████▁▁▁▁▁▁▁▁▁","█████████████▁▁▁▁▁▁▁","██████████████▁▁▁▁▁▁","██████████████▁▁▁▁▁▁","▁██████████████▁▁▁▁▁","▁██████████████▁▁▁▁▁","▁██████████████▁▁▁▁▁","▁▁██████████████▁▁▁▁","▁▁▁██████████████▁▁▁","▁▁▁▁█████████████▁▁▁","▁▁▁▁██████████████▁▁","▁▁▁▁██████████████▁▁","▁▁▁▁▁██████████████▁","▁▁▁▁▁██████████████▁","▁▁▁▁▁██████████████▁","▁▁▁▁▁▁██████████████","▁▁▁▁▁▁██████████████","▁▁▁▁▁▁▁█████████████","▁▁▁▁▁▁▁█████████████","▁▁▁▁▁▁▁▁████████████","▁▁▁▁▁▁▁▁████████████","▁▁▁▁▁▁▁▁▁███████████","▁▁▁▁▁▁▁▁▁███████████","▁▁▁▁▁▁▁▁▁▁██████████","▁▁▁▁▁▁▁▁▁▁██████████","▁▁▁▁▁▁▁▁▁▁▁▁████████","▁▁▁▁▁▁▁▁▁▁▁▁▁███████","▁▁▁▁▁▁▁▁▁▁▁▁▁▁██████","▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█████","▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█████","█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁████","██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁███","██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁███","███▁▁▁▁▁▁▁▁▁▁▁▁▁▁███","████▁▁▁▁▁▁▁▁▁▁▁▁▁▁██","█████▁▁▁▁▁▁▁▁▁▁▁▁▁▁█","█████▁▁▁▁▁▁▁▁▁▁▁▁▁▁█","██████▁▁▁▁▁▁▁▁▁▁▁▁▁█","████████▁▁▁▁▁▁▁▁▁▁▁▁","█████████▁▁▁▁▁▁▁▁▁▁▁","█████████▁▁▁▁▁▁▁▁▁▁▁","█████████▁▁▁▁▁▁▁▁▁▁▁","█████████▁▁▁▁▁▁▁▁▁▁▁","███████████▁▁▁▁▁▁▁▁▁","████████████▁▁▁▁▁▁▁▁","████████████▁▁▁▁▁▁▁▁","██████████████▁▁▁▁▁▁","██████████████▁▁▁▁▁▁","▁██████████████▁▁▁▁▁","▁██████████████▁▁▁▁▁","▁▁▁█████████████▁▁▁▁","▁▁▁▁▁████████████▁▁▁","▁▁▁▁▁████████████▁▁▁","▁▁▁▁▁▁███████████▁▁▁","▁▁▁▁▁▁▁▁█████████▁▁▁","▁▁▁▁▁▁▁▁█████████▁▁▁","▁▁▁▁▁▁▁▁▁█████████▁▁","▁▁▁▁▁▁▁▁▁█████████▁▁","▁▁▁▁▁▁▁▁▁▁█████████▁","▁▁▁▁▁▁▁▁▁▁▁████████▁","▁▁▁▁▁▁▁▁▁▁▁████████▁","▁▁▁▁▁▁▁▁▁▁▁▁███████▁","▁▁▁▁▁▁▁▁▁▁▁▁███████▁","▁▁▁▁▁▁▁▁▁▁▁▁▁███████","▁▁▁▁▁▁▁▁▁▁▁▁▁███████","▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█████","▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁████","▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁████","▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁████","▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁███","▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁███","▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁██","▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁██","▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁██","▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█","▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█","▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█","▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁","▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁","▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁","▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁"]},"moon":{"interval":80,"frames":["🌑 ","🌒 ","🌓 ","🌔 ","🌕 ","🌖 ","🌗 ","🌘 "]},"runner":{"interval":140,"frames":["🚶 ","🏃 "]},"pong":{"interval":80,"frames":["▐⠂       ▌","▐⠈       ▌","▐ ⠂      ▌","▐ ⠠      ▌","▐  ⡀     ▌","▐  ⠠     ▌","▐   ⠂    ▌","▐   ⠈    ▌","▐    ⠂   ▌","▐    ⠠   ▌","▐     ⡀  ▌","▐     ⠠  ▌","▐      ⠂ ▌","▐      ⠈ ▌","▐       ⠂▌","▐       ⠠▌","▐       ⡀▌","▐      ⠠ ▌","▐      ⠂ ▌","▐     ⠈  ▌","▐     ⠂  ▌","▐    ⠠   ▌","▐    ⡀   ▌","▐   ⠠    ▌","▐   ⠂    ▌","▐  ⠈     ▌","▐  ⠂     ▌","▐ ⠠      ▌","▐ ⡀      ▌","▐⠠       ▌"]},"shark":{"interval":120,"frames":["▐|\\\\____________▌","▐_|\\\\___________▌","▐__|\\\\__________▌","▐___|\\\\_________▌","▐____|\\\\________▌","▐_____|\\\\_______▌","▐______|\\\\______▌","▐_______|\\\\_____▌","▐________|\\\\____▌","▐_________|\\\\___▌","▐__________|\\\\__▌","▐___________|\\\\_▌","▐____________|\\\\▌","▐____________/|▌","▐___________/|_▌","▐__________/|__▌","▐_________/|___▌","▐________/|____▌","▐_______/|_____▌","▐______/|______▌","▐_____/|_______▌","▐____/|________▌","▐___/|_________▌","▐__/|__________▌","▐_/|___________▌","▐/|____________▌"]},"dqpb":{"interval":100,"frames":["d","q","p","b"]},"weather":{"interval":100,"frames":["☀️ ","☀️ ","☀️ ","🌤 ","⛅️ ","🌥 ","☁️ ","🌧 ","🌨 ","🌧 ","🌨 ","🌧 ","🌨 ","⛈ ","🌨 ","🌧 ","🌨 ","☁️ ","🌥 ","⛅️ ","🌤 ","☀️ ","☀️ "]},"christmas":{"interval":400,"frames":["🌲","🎄"]},"grenade":{"interval":80,"frames":["،  ","′  "," ´ "," ‾ ","  ⸌","  ⸊","  |","  ⁎","  ⁕"," ෴ ","  ⁓","   ","   ","   "]},"point":{"interval":125,"frames":["∙∙∙","●∙∙","∙●∙","∙∙●","∙∙∙"]},"layer":{"interval":150,"frames":["-","=","≡"]},"betaWave":{"interval":80,"frames":["ρββββββ","βρβββββ","ββρββββ","βββρβββ","ββββρββ","βββββρβ","ββββββρ"]},"fingerDance":{"interval":160,"frames":["🤘 ","🤟 ","🖖 ","✋ ","🤚 ","👆 "]},"fistBump":{"interval":80,"frames":["🤜　　　　🤛 ","🤜　　　　🤛 ","🤜　　　　🤛 ","　🤜　　🤛　 ","　　🤜🤛　　 ","　🤜✨🤛　　 ","🤜　✨　🤛　 "]},"soccerHeader":{"interval":80,"frames":[" 🧑⚽️       🧑 ","🧑  ⚽️      🧑 ","🧑   ⚽️     🧑 ","🧑    ⚽️    🧑 ","🧑     ⚽️   🧑 ","🧑      ⚽️  🧑 ","🧑       ⚽️🧑  ","🧑      ⚽️  🧑 ","🧑     ⚽️   🧑 ","🧑    ⚽️    🧑 ","🧑   ⚽️     🧑 ","🧑  ⚽️      🧑 "]},"mindblown":{"interval":160,"frames":["😐 ","😐 ","😮 ","😮 ","😦 ","😦 ","😧 ","😧 ","🤯 ","💥 ","✨ ","　 ","　 ","　 "]},"speaker":{"interval":160,"frames":["🔈 ","🔉 ","🔊 ","🔉 "]},"orangePulse":{"interval":100,"frames":["🔸 ","🔶 ","🟠 ","🟠 ","🔶 "]},"bluePulse":{"interval":100,"frames":["🔹 ","🔷 ","🔵 ","🔵 ","🔷 "]},"orangeBluePulse":{"interval":100,"frames":["🔸 ","🔶 ","🟠 ","🟠 ","🔶 ","🔹 ","🔷 ","🔵 ","🔵 ","🔷 "]},"timeTravel":{"interval":100,"frames":["🕛 ","🕚 ","🕙 ","🕘 ","🕗 ","🕖 ","🕕 ","🕔 ","🕓 ","🕒 ","🕑 ","🕐 "]},"aesthetic":{"interval":80,"frames":["▰▱▱▱▱▱▱","▰▰▱▱▱▱▱","▰▰▰▱▱▱▱","▰▰▰▰▱▱▱","▰▰▰▰▰▱▱","▰▰▰▰▰▰▱","▰▰▰▰▰▰▰","▰▱▱▱▱▱▱"]},"dwarfFortress":{"interval":80,"frames":[" ██████£££  ","☺██████£££  ","☺██████£££  ","☺▓█████£££  ","☺▓█████£££  ","☺▒█████£££  ","☺▒█████£££  ","☺░█████£££  ","☺░█████£££  ","☺ █████£££  "," ☺█████£££  "," ☺█████£££  "," ☺▓████£££  "," ☺▓████£££  "," ☺▒████£££  "," ☺▒████£££  "," ☺░████£££  "," ☺░████£££  "," ☺ ████£££  ","  ☺████£££  ","  ☺████£££  ","  ☺▓███£££  ","  ☺▓███£££  ","  ☺▒███£££  ","  ☺▒███£££  ","  ☺░███£££  ","  ☺░███£££  ","  ☺ ███£££  ","   ☺███£££  ","   ☺███£££  ","   ☺▓██£££  ","   ☺▓██£££  ","   ☺▒██£££  ","   ☺▒██£££  ","   ☺░██£££  ","   ☺░██£££  ","   ☺ ██£££  ","    ☺██£££  ","    ☺██£££  ","    ☺▓█£££  ","    ☺▓█£££  ","    ☺▒█£££  ","    ☺▒█£££  ","    ☺░█£££  ","    ☺░█£££  ","    ☺ █£££  ","     ☺█£££  ","     ☺█£££  ","     ☺▓£££  ","     ☺▓£££  ","     ☺▒£££  ","     ☺▒£££  ","     ☺░£££  ","     ☺░£££  ","     ☺ £££  ","      ☺£££  ","      ☺£££  ","      ☺▓££  ","      ☺▓££  ","      ☺▒££  ","      ☺▒££  ","      ☺░££  ","      ☺░££  ","      ☺ ££  ","       ☺££  ","       ☺££  ","       ☺▓£  ","       ☺▓£  ","       ☺▒£  ","       ☺▒£  ","       ☺░£  ","       ☺░£  ","       ☺ £  ","        ☺£  ","        ☺£  ","        ☺▓  ","        ☺▓  ","        ☺▒  ","        ☺▒  ","        ☺░  ","        ☺░  ","        ☺   ","        ☺  &","        ☺ ☼&","       ☺ ☼ &","       ☺☼  &","      ☺☼  & ","      ‼   & ","     ☺   &  ","    ‼    &  ","   ☺    &   ","  ‼     &   "," ☺     &    ","‼      &    ","      &     ","      &     ","     &   ░  ","     &   ▒  ","    &    ▓  ","    &    £  ","   &    ░£  ","   &    ▒£  ","  &     ▓£  ","  &     ££  "," &     ░££  "," &     ▒££  ","&      ▓££  ","&      £££  ","      ░£££  ","      ▒£££  ","      ▓£££  ","      █£££  ","     ░█£££  ","     ▒█£££  ","     ▓█£££  ","     ██£££  ","    ░██£££  ","    ▒██£££  ","    ▓██£££  ","    ███£££  ","   ░███£££  ","   ▒███£££  ","   ▓███£££  ","   ████£££  ","  ░████£££  ","  ▒████£££  ","  ▓████£££  ","  █████£££  "," ░█████£££  "," ▒█████£££  "," ▓█████£££  "," ██████£££  "," ██████£££  "]}}') }, 9968: e => { e.exports = JSON.parse('{"name":"dotenv","version":"16.0.3","description":"Loads environment variables from .env file","main":"lib/main.js","types":"lib/main.d.ts","exports":{".":{"require":"./lib/main.js","types":"./lib/main.d.ts","default":"./lib/main.js"},"./config":"./config.js","./config.js":"./config.js","./lib/env-options":"./lib/env-options.js","./lib/env-options.js":"./lib/env-options.js","./lib/cli-options":"./lib/cli-options.js","./lib/cli-options.js":"./lib/cli-options.js","./package.json":"./package.json"},"scripts":{"dts-check":"tsc --project tests/types/tsconfig.json","lint":"standard","lint-readme":"standard-markdown","pretest":"npm run lint && npm run dts-check","test":"tap tests/*.js --100 -Rspec","prerelease":"npm test","release":"standard-version"},"repository":{"type":"git","url":"git://github.com/motdotla/dotenv.git"},"keywords":["dotenv","env",".env","environment","variables","config","settings"],"readmeFilename":"README.md","license":"BSD-2-Clause","devDependencies":{"@types/node":"^17.0.9","decache":"^4.6.1","dtslint":"^3.7.0","sinon":"^12.0.1","standard":"^16.0.4","standard-markdown":"^7.1.0","standard-version":"^9.3.2","tap":"^15.1.6","tar":"^6.1.11","typescript":"^4.5.4"},"engines":{"node":">=12"}}') }
}; var __webpack_module_cache__ = {}; function __nccwpck_require__(e) { var t = __webpack_module_cache__[e]; if (t !== undefined) { return t.exports } var r = __webpack_module_cache__[e] = { id: e, loaded: false, exports: {} }; var n = true; try { __webpack_modules__[e].call(r.exports, r, r.exports, __nccwpck_require__); n = false } finally { if (n) delete __webpack_module_cache__[e] } r.loaded = true; return r.exports } (() => { __nccwpck_require__.nmd = e => { e.paths = []; if (!e.children) e.children = []; return e } })(); if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = new URL(".", import.meta.url).pathname.slice(import.meta.url.match(/^file:\/\/\/\w:/) ? 1 : 0, -1) + "/"; var __webpack_exports__ = {}; (() => { var e = __nccwpck_require__(2186); var t = __nccwpck_require__(8237); const r = ["Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array", "BigInt64Array", "BigUint64Array"]; function isTypedArrayName(e) { return r.includes(e) } const n = ["Function", "Generator", "AsyncGenerator", "GeneratorFunction", "AsyncGeneratorFunction", "AsyncFunction", "Observable", "Array", "Buffer", "Blob", "Object", "RegExp", "Date", "Error", "Map", "Set", "WeakMap", "WeakSet", "WeakRef", "ArrayBuffer", "SharedArrayBuffer", "DataView", "Promise", "URL", "FormData", "URLSearchParams", "HTMLElement", "NaN", ...r]; function isObjectTypeName(e) { return n.includes(e) } const i = ["null", "undefined", "string", "number", "bigint", "boolean", "symbol"]; function isPrimitiveTypeName(e) { return i.includes(e) } function isOfType(e) { return t => typeof t === e } const { toString: s } = Object.prototype; const getObjectType = e => { const t = s.call(e).slice(8, -1); if (/HTML\w+Element/.test(t) && is.domElement(e)) { return "HTMLElement" } if (isObjectTypeName(t)) { return t } return undefined }; const isObjectOfType = e => t => getObjectType(t) === e; function is(e) { if (e === null) { return "null" } switch (typeof e) { case "undefined": return "undefined"; case "string": return "string"; case "number": return Number.isNaN(e) ? "NaN" : "number"; case "boolean": return "boolean"; case "function": return "Function"; case "bigint": return "bigint"; case "symbol": return "symbol"; default: }if (is.observable(e)) { return "Observable" } if (is.array(e)) { return "Array" } if (is.buffer(e)) { return "Buffer" } const t = getObjectType(e); if (t) { return t } if (e instanceof String || e instanceof Boolean || e instanceof Number) { throw new TypeError("Please don't use object wrappers for primitive types") } return "Object" } is.undefined = isOfType("undefined"); is.string = isOfType("string"); const o = isOfType("number"); is.number = e => o(e) && !is.nan(e); is.bigint = isOfType("bigint"); is.function_ = isOfType("function"); is.null_ = e => e === null; is.class_ = e => is.function_(e) && e.toString().startsWith("class "); is.boolean = e => e === true || e === false; is.symbol = isOfType("symbol"); is.numericString = e => is.string(e) && !is.emptyStringOrWhitespace(e) && !Number.isNaN(Number(e)); is.array = (e, t) => { if (!Array.isArray(e)) { return false } if (!is.function_(t)) { return true } return e.every((e => t(e))) }; is.buffer = e => e?.constructor?.isBuffer?.(e) ?? false; is.blob = e => isObjectOfType("Blob")(e); is.nullOrUndefined = e => is.null_(e) || is.undefined(e); is.object = e => !is.null_(e) && (typeof e === "object" || is.function_(e)); is.iterable = e => is.function_(e?.[Symbol.iterator]); is.asyncIterable = e => is.function_(e?.[Symbol.asyncIterator]); is.generator = e => is.iterable(e) && is.function_(e?.next) && is.function_(e?.throw); is.asyncGenerator = e => is.asyncIterable(e) && is.function_(e.next) && is.function_(e.throw); is.nativePromise = e => isObjectOfType("Promise")(e); const hasPromiseApi = e => is.function_(e?.then) && is.function_(e?.catch); is.promise = e => is.nativePromise(e) || hasPromiseApi(e); is.generatorFunction = isObjectOfType("GeneratorFunction"); is.asyncGeneratorFunction = e => getObjectType(e) === "AsyncGeneratorFunction"; is.asyncFunction = e => getObjectType(e) === "AsyncFunction"; is.boundFunction = e => is.function_(e) && !e.hasOwnProperty("prototype"); is.regExp = isObjectOfType("RegExp"); is.date = isObjectOfType("Date"); is.error = isObjectOfType("Error"); is.map = e => isObjectOfType("Map")(e); is.set = e => isObjectOfType("Set")(e); is.weakMap = e => isObjectOfType("WeakMap")(e); is.weakSet = e => isObjectOfType("WeakSet")(e); is.weakRef = e => isObjectOfType("WeakRef")(e); is.int8Array = isObjectOfType("Int8Array"); is.uint8Array = isObjectOfType("Uint8Array"); is.uint8ClampedArray = isObjectOfType("Uint8ClampedArray"); is.int16Array = isObjectOfType("Int16Array"); is.uint16Array = isObjectOfType("Uint16Array"); is.int32Array = isObjectOfType("Int32Array"); is.uint32Array = isObjectOfType("Uint32Array"); is.float32Array = isObjectOfType("Float32Array"); is.float64Array = isObjectOfType("Float64Array"); is.bigInt64Array = isObjectOfType("BigInt64Array"); is.bigUint64Array = isObjectOfType("BigUint64Array"); is.arrayBuffer = isObjectOfType("ArrayBuffer"); is.sharedArrayBuffer = isObjectOfType("SharedArrayBuffer"); is.dataView = isObjectOfType("DataView"); is.enumCase = (e, t) => Object.values(t).includes(e); is.directInstanceOf = (e, t) => Object.getPrototypeOf(e) === t.prototype; is.urlInstance = e => isObjectOfType("URL")(e); is.urlString = e => { if (!is.string(e)) { return false } try { new URL(e); return true } catch { return false } }; is.truthy = e => Boolean(e); is.falsy = e => !e; is.nan = e => Number.isNaN(e); is.primitive = e => is.null_(e) || isPrimitiveTypeName(typeof e); is.integer = e => Number.isInteger(e); is.safeInteger = e => Number.isSafeInteger(e); is.plainObject = e => { if (typeof e !== "object" || e === null) { return false } const t = Object.getPrototypeOf(e); return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e) }; is.typedArray = e => isTypedArrayName(getObjectType(e)); const isValidLength = e => is.safeInteger(e) && e >= 0; is.arrayLike = e => !is.nullOrUndefined(e) && !is.function_(e) && isValidLength(e.length); is.inRange = (e, t) => { if (is.number(t)) { return e >= Math.min(0, t) && e <= Math.max(t, 0) } if (is.array(t) && t.length === 2) { return e >= Math.min(...t) && e <= Math.max(...t) } throw new TypeError(`Invalid range: ${JSON.stringify(t)}`) }; const a = 1; const u = ["innerHTML", "ownerDocument", "style", "attributes", "nodeValue"]; is.domElement = e => is.object(e) && e.nodeType === a && is.string(e.nodeName) && !is.plainObject(e) && u.every((t => t in e)); is.observable = e => { if (!e) { return false } if (e === e[Symbol.observable]?.()) { return true } if (e === e["@@observable"]?.()) { return true } return false }; is.nodeStream = e => is.object(e) && is.function_(e.pipe) && !is.observable(e); is.infinite = e => e === Number.POSITIVE_INFINITY || e === Number.NEGATIVE_INFINITY; const isAbsoluteMod2 = e => t => is.integer(t) && Math.abs(t % 2) === e; is.evenInteger = isAbsoluteMod2(0); is.oddInteger = isAbsoluteMod2(1); is.emptyArray = e => is.array(e) && e.length === 0; is.nonEmptyArray = e => is.array(e) && e.length > 0; is.emptyString = e => is.string(e) && e.length === 0; const isWhiteSpaceString = e => is.string(e) && !/\S/.test(e); is.emptyStringOrWhitespace = e => is.emptyString(e) || isWhiteSpaceString(e); is.nonEmptyString = e => is.string(e) && e.length > 0; is.nonEmptyStringAndNotWhitespace = e => is.string(e) && !is.emptyStringOrWhitespace(e); is.emptyObject = e => is.object(e) && !is.map(e) && !is.set(e) && Object.keys(e).length === 0; is.nonEmptyObject = e => is.object(e) && !is.map(e) && !is.set(e) && Object.keys(e).length > 0; is.emptySet = e => is.set(e) && e.size === 0; is.nonEmptySet = e => is.set(e) && e.size > 0; is.emptyMap = e => is.map(e) && e.size === 0; is.nonEmptyMap = e => is.map(e) && e.size > 0; is.propertyKey = e => is.any([is.string, is.number, is.symbol], e); is.formData = e => isObjectOfType("FormData")(e); is.urlSearchParams = e => isObjectOfType("URLSearchParams")(e); const predicateOnArray = (e, t, r) => { if (!is.function_(t)) { throw new TypeError(`Invalid predicate: ${JSON.stringify(t)}`) } if (r.length === 0) { throw new TypeError("Invalid number of values") } return e.call(r, t) }; is.any = (e, ...t) => { const r = is.array(e) ? e : [e]; return r.some((e => predicateOnArray(Array.prototype.some, e, t))) }; is.all = (e, ...t) => predicateOnArray(Array.prototype.every, e, t); const assertType = (e, t, r, n = {}) => { if (!e) { const { multipleValues: e } = n; const i = e ? `received values of types ${[...new Set(r.map((e => `\`${is(e)}\``)))].join(", ")}` : `received value of type \`${is(r)}\``; throw new TypeError(`Expected value which is \`${t}\`, ${i}.`) } }; const l = { undefined: e => assertType(is.undefined(e), "undefined", e), string: e => assertType(is.string(e), "string", e), number: e => assertType(is.number(e), "number", e), bigint: e => assertType(is.bigint(e), "bigint", e), function_: e => assertType(is.function_(e), "Function", e), null_: e => assertType(is.null_(e), "null", e), class_: e => assertType(is.class_(e), "Class", e), boolean: e => assertType(is.boolean(e), "boolean", e), symbol: e => assertType(is.symbol(e), "symbol", e), numericString: e => assertType(is.numericString(e), "string with a number", e), array: (e, t) => { const r = assertType; r(is.array(e), "Array", e); if (t) { e.forEach(t) } }, buffer: e => assertType(is.buffer(e), "Buffer", e), blob: e => assertType(is.blob(e), "Blob", e), nullOrUndefined: e => assertType(is.nullOrUndefined(e), "null or undefined", e), object: e => assertType(is.object(e), "Object", e), iterable: e => assertType(is.iterable(e), "Iterable", e), asyncIterable: e => assertType(is.asyncIterable(e), "AsyncIterable", e), generator: e => assertType(is.generator(e), "Generator", e), asyncGenerator: e => assertType(is.asyncGenerator(e), "AsyncGenerator", e), nativePromise: e => assertType(is.nativePromise(e), "native Promise", e), promise: e => assertType(is.promise(e), "Promise", e), generatorFunction: e => assertType(is.generatorFunction(e), "GeneratorFunction", e), asyncGeneratorFunction: e => assertType(is.asyncGeneratorFunction(e), "AsyncGeneratorFunction", e), asyncFunction: e => assertType(is.asyncFunction(e), "AsyncFunction", e), boundFunction: e => assertType(is.boundFunction(e), "Function", e), regExp: e => assertType(is.regExp(e), "RegExp", e), date: e => assertType(is.date(e), "Date", e), error: e => assertType(is.error(e), "Error", e), map: e => assertType(is.map(e), "Map", e), set: e => assertType(is.set(e), "Set", e), weakMap: e => assertType(is.weakMap(e), "WeakMap", e), weakSet: e => assertType(is.weakSet(e), "WeakSet", e), weakRef: e => assertType(is.weakRef(e), "WeakRef", e), int8Array: e => assertType(is.int8Array(e), "Int8Array", e), uint8Array: e => assertType(is.uint8Array(e), "Uint8Array", e), uint8ClampedArray: e => assertType(is.uint8ClampedArray(e), "Uint8ClampedArray", e), int16Array: e => assertType(is.int16Array(e), "Int16Array", e), uint16Array: e => assertType(is.uint16Array(e), "Uint16Array", e), int32Array: e => assertType(is.int32Array(e), "Int32Array", e), uint32Array: e => assertType(is.uint32Array(e), "Uint32Array", e), float32Array: e => assertType(is.float32Array(e), "Float32Array", e), float64Array: e => assertType(is.float64Array(e), "Float64Array", e), bigInt64Array: e => assertType(is.bigInt64Array(e), "BigInt64Array", e), bigUint64Array: e => assertType(is.bigUint64Array(e), "BigUint64Array", e), arrayBuffer: e => assertType(is.arrayBuffer(e), "ArrayBuffer", e), sharedArrayBuffer: e => assertType(is.sharedArrayBuffer(e), "SharedArrayBuffer", e), dataView: e => assertType(is.dataView(e), "DataView", e), enumCase: (e, t) => assertType(is.enumCase(e, t), "EnumCase", e), urlInstance: e => assertType(is.urlInstance(e), "URL", e), urlString: e => assertType(is.urlString(e), "string with a URL", e), truthy: e => assertType(is.truthy(e), "truthy", e), falsy: e => assertType(is.falsy(e), "falsy", e), nan: e => assertType(is.nan(e), "NaN", e), primitive: e => assertType(is.primitive(e), "primitive", e), integer: e => assertType(is.integer(e), "integer", e), safeInteger: e => assertType(is.safeInteger(e), "integer", e), plainObject: e => assertType(is.plainObject(e), "plain object", e), typedArray: e => assertType(is.typedArray(e), "TypedArray", e), arrayLike: e => assertType(is.arrayLike(e), "array-like", e), domElement: e => assertType(is.domElement(e), "HTMLElement", e), observable: e => assertType(is.observable(e), "Observable", e), nodeStream: e => assertType(is.nodeStream(e), "Node.js Stream", e), infinite: e => assertType(is.infinite(e), "infinite number", e), emptyArray: e => assertType(is.emptyArray(e), "empty array", e), nonEmptyArray: e => assertType(is.nonEmptyArray(e), "non-empty array", e), emptyString: e => assertType(is.emptyString(e), "empty string", e), emptyStringOrWhitespace: e => assertType(is.emptyStringOrWhitespace(e), "empty string or whitespace", e), nonEmptyString: e => assertType(is.nonEmptyString(e), "non-empty string", e), nonEmptyStringAndNotWhitespace: e => assertType(is.nonEmptyStringAndNotWhitespace(e), "non-empty string and not whitespace", e), emptyObject: e => assertType(is.emptyObject(e), "empty object", e), nonEmptyObject: e => assertType(is.nonEmptyObject(e), "non-empty object", e), emptySet: e => assertType(is.emptySet(e), "empty set", e), nonEmptySet: e => assertType(is.nonEmptySet(e), "non-empty set", e), emptyMap: e => assertType(is.emptyMap(e), "empty map", e), nonEmptyMap: e => assertType(is.nonEmptyMap(e), "non-empty map", e), propertyKey: e => assertType(is.propertyKey(e), "PropertyKey", e), formData: e => assertType(is.formData(e), "FormData", e), urlSearchParams: e => assertType(is.urlSearchParams(e), "URLSearchParams", e), evenInteger: e => assertType(is.evenInteger(e), "even integer", e), oddInteger: e => assertType(is.oddInteger(e), "odd integer", e), directInstanceOf: (e, t) => assertType(is.directInstanceOf(e, t), "T", e), inRange: (e, t) => assertType(is.inRange(e, t), "in range", e), any: (e, ...t) => assertType(is.any(e, ...t), "predicate returns truthy for any value", t, { multipleValues: true }), all: (e, ...t) => assertType(is.all(e, ...t), "predicate returns truthy for all values", t, { multipleValues: true }) }; Object.defineProperties(is, { class: { value: is.class_ }, function: { value: is.function_ }, null: { value: is.null_ } }); Object.defineProperties(l, { class: { value: l.class_ }, function: { value: l.function_ }, null: { value: l.null_ } }); const f = is; const d = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("events"); class CancelError extends Error { constructor(e) { super(e || "Promise was canceled"); this.name = "CancelError" } get isCanceled() { return true } } class PCancelable { static fn(e) { return (...t) => new PCancelable(((r, n, i) => { t.push(i); e(...t).then(r, n) })) } constructor(e) { this._cancelHandlers = []; this._isPending = true; this._isCanceled = false; this._rejectOnCancel = true; this._promise = new Promise(((t, r) => { this._reject = r; const onResolve = e => { if (!this._isCanceled || !onCancel.shouldReject) { this._isPending = false; t(e) } }; const onReject = e => { this._isPending = false; r(e) }; const onCancel = e => { if (!this._isPending) { throw new Error("The `onCancel` handler was attached after the promise settled.") } this._cancelHandlers.push(e) }; Object.defineProperties(onCancel, { shouldReject: { get: () => this._rejectOnCancel, set: e => { this._rejectOnCancel = e } } }); e(onResolve, onReject, onCancel) })) } then(e, t) { return this._promise.then(e, t) } catch(e) { return this._promise.catch(e) } finally(e) { return this._promise.finally(e) } cancel(e) { if (!this._isPending || this._isCanceled) { return } this._isCanceled = true; if (this._cancelHandlers.length > 0) { try { for (const e of this._cancelHandlers) { e() } } catch (e) { this._reject(e); return } } if (this._rejectOnCancel) { this._reject(new CancelError(e)) } } get isCanceled() { return this._isCanceled } } Object.setPrototypeOf(PCancelable.prototype, Promise.prototype); function isRequest(e) { return f.object(e) && "_onResponse" in e } class errors_RequestError extends Error { constructor(e, t, r) { super(e); Object.defineProperty(this, "input", { enumerable: true, configurable: true, writable: true, value: void 0 }); Object.defineProperty(this, "code", { enumerable: true, configurable: true, writable: true, value: void 0 }); Object.defineProperty(this, "stack", { enumerable: true, configurable: true, writable: true, value: void 0 }); Object.defineProperty(this, "response", { enumerable: true, configurable: true, writable: true, value: void 0 }); Object.defineProperty(this, "request", { enumerable: true, configurable: true, writable: true, value: void 0 }); Object.defineProperty(this, "timings", { enumerable: true, configurable: true, writable: true, value: void 0 }); Error.captureStackTrace(this, this.constructor); this.name = "RequestError"; this.code = t.code ?? "ERR_GOT_REQUEST_ERROR"; this.input = t.input; if (isRequest(r)) { Object.defineProperty(this, "request", { enumerable: false, value: r }); Object.defineProperty(this, "response", { enumerable: false, value: r.response }); this.options = r.options } else { this.options = r } this.timings = this.request?.timings; if (f.string(t.stack) && f.string(this.stack)) { const e = this.stack.indexOf(this.message) + this.message.length; const r = this.stack.slice(e).split("\n").reverse(); const n = t.stack.slice(t.stack.indexOf(t.message) + t.message.length).split("\n").reverse(); while (n.length > 0 && n[0] === r[0]) { r.shift() } this.stack = `${this.stack.slice(0, e)}${r.reverse().join("\n")}${n.reverse().join("\n")}` } } } class MaxRedirectsError extends errors_RequestError { constructor(e) { super(`Redirected ${e.options.maxRedirects} times. Aborting.`, {}, e); this.name = "MaxRedirectsError"; this.code = "ERR_TOO_MANY_REDIRECTS" } } class HTTPError extends errors_RequestError { constructor(e) { super(`Response code ${e.statusCode} (${e.statusMessage})`, {}, e.request); this.name = "HTTPError"; this.code = "ERR_NON_2XX_3XX_RESPONSE" } } class CacheError extends errors_RequestError { constructor(e, t) { super(e.message, e, t); this.name = "CacheError"; this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_CACHE_ACCESS" : this.code } } class UploadError extends errors_RequestError { constructor(e, t) { super(e.message, e, t); this.name = "UploadError"; this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_UPLOAD" : this.code } } class TimeoutError extends errors_RequestError { constructor(e, t, r) { super(e.message, e, r); Object.defineProperty(this, "timings", { enumerable: true, configurable: true, writable: true, value: void 0 }); Object.defineProperty(this, "event", { enumerable: true, configurable: true, writable: true, value: void 0 }); this.name = "TimeoutError"; this.event = e.event; this.timings = t } } class ReadError extends errors_RequestError { constructor(e, t) { super(e.message, e, t); this.name = "ReadError"; this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_READING_RESPONSE_STREAM" : this.code } } class RetryError extends errors_RequestError { constructor(e) { super("Retrying", {}, e); this.name = "RetryError"; this.code = "ERR_RETRYING" } } class AbortError extends errors_RequestError { constructor(e) { super("This operation was aborted.", {}, e); this.code = "ERR_ABORTED"; this.name = "AbortError" } } const p = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("process"); const h = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("buffer"); const m = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("stream"); const g = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("url"); const y = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("http"); var b = __nccwpck_require__(2361); var _ = __nccwpck_require__(3837); var v = __nccwpck_require__(6214); const timer = e => { if (e.timings) { return e.timings } const t = { start: Date.now(), socket: undefined, lookup: undefined, connect: undefined, secureConnect: undefined, upload: undefined, response: undefined, end: undefined, error: undefined, abort: undefined, phases: { wait: undefined, dns: undefined, tcp: undefined, tls: undefined, request: undefined, firstByte: undefined, download: undefined, total: undefined } }; e.timings = t; const handleError = e => { e.once(b.errorMonitor, (() => { t.error = Date.now(); t.phases.total = t.error - t.start })) }; handleError(e); const onAbort = () => { t.abort = Date.now(); t.phases.total = t.abort - t.start }; e.prependOnceListener("abort", onAbort); const onSocket = e => { t.socket = Date.now(); t.phases.wait = t.socket - t.start; if (_.types.isProxy(e)) { return } const lookupListener = () => { t.lookup = Date.now(); t.phases.dns = t.lookup - t.socket }; e.prependOnceListener("lookup", lookupListener); v(e, { connect: () => { t.connect = Date.now(); if (t.lookup === undefined) { e.removeListener("lookup", lookupListener); t.lookup = t.connect; t.phases.dns = t.lookup - t.socket } t.phases.tcp = t.connect - t.lookup }, secureConnect: () => { t.secureConnect = Date.now(); t.phases.tls = t.secureConnect - t.connect } }) }; if (e.socket) { onSocket(e.socket) } else { e.prependOnceListener("socket", onSocket) } const onUpload = () => { t.upload = Date.now(); t.phases.request = t.upload - (t.secureConnect ?? t.connect) }; if (e.writableFinished) { onUpload() } else { e.prependOnceListener("finish", onUpload) } e.prependOnceListener("response", (r => { t.response = Date.now(); t.phases.firstByte = t.response - t.upload; r.timings = t; handleError(r); r.prependOnceListener("end", (() => { e.off("abort", onAbort); r.off("aborted", onAbort); if (t.phases.total) { return } t.end = Date.now(); t.phases.download = t.end - t.response; t.phases.total = t.end - t.start })); r.prependOnceListener("aborted", onAbort) })); return t }; const w = timer; const D = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("crypto"); const E = "text/plain"; const S = "us-ascii"; const testParameter = (e, t) => t.some((t => t instanceof RegExp ? t.test(e) : t === e)); const C = new Set(["https:", "http:", "file:"]); const hasCustomProtocol = e => { try { const { protocol: t } = new URL(e); return t.endsWith(":") && !C.has(t) } catch { return false } }; const normalizeDataURL = (e, { stripHash: t }) => { const r = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(e); if (!r) { throw new Error(`Invalid URL: ${e}`) } let { type: n, data: i, hash: s } = r.groups; const o = n.split(";"); s = t ? "" : s; let a = false; if (o[o.length - 1] === "base64") { o.pop(); a = true } const u = o.shift()?.toLowerCase() ?? ""; const l = o.map((e => { let [t, r = ""] = e.split("=").map((e => e.trim())); if (t === "charset") { r = r.toLowerCase(); if (r === S) { return "" } } return `${t}${r ? `=${r}` : ""}` })).filter(Boolean); const f = [...l]; if (a) { f.push("base64") } if (f.length > 0 || u && u !== E) { f.unshift(u) } return `data:${f.join(";")},${a ? i.trim() : i}${s ? `#${s}` : ""}` }; function normalizeUrl(e, t) { t = { defaultProtocol: "http", normalizeProtocol: true, forceHttp: false, forceHttps: false, stripAuthentication: true, stripHash: false, stripTextFragment: true, stripWWW: true, removeQueryParameters: [/^utm_\w+/i], removeTrailingSlash: true, removeSingleSlash: true, removeDirectoryIndex: false, removeExplicitPort: false, sortQueryParameters: true, ...t }; if (typeof t.defaultProtocol === "string" && !t.defaultProtocol.endsWith(":")) { t.defaultProtocol = `${t.defaultProtocol}:` } e = e.trim(); if (/^data:/i.test(e)) { return normalizeDataURL(e, t) } if (hasCustomProtocol(e)) { return e } const r = e.startsWith("//"); const n = !r && /^\.*\//.test(e); if (!n) { e = e.replace(/^(?!(?:\w+:)?\/\/)|^\/\//, t.defaultProtocol) } const i = new URL(e); if (t.forceHttp && t.forceHttps) { throw new Error("The `forceHttp` and `forceHttps` options cannot be used together") } if (t.forceHttp && i.protocol === "https:") { i.protocol = "http:" } if (t.forceHttps && i.protocol === "http:") { i.protocol = "https:" } if (t.stripAuthentication) { i.username = ""; i.password = "" } if (t.stripHash) { i.hash = "" } else if (t.stripTextFragment) { i.hash = i.hash.replace(/#?:~:text.*?$/i, "") } if (i.pathname) { const e = /\b[a-z][a-z\d+\-.]{1,50}:\/\//g; let t = 0; let r = ""; for (; ;) { const n = e.exec(i.pathname); if (!n) { break } const s = n[0]; const o = n.index; const a = i.pathname.slice(t, o); r += a.replace(/\/{2,}/g, "/"); r += s; t = o + s.length } const n = i.pathname.slice(t, i.pathname.length); r += n.replace(/\/{2,}/g, "/"); i.pathname = r } if (i.pathname) { try { i.pathname = decodeURI(i.pathname) } catch { } } if (t.removeDirectoryIndex === true) { t.removeDirectoryIndex = [/^index\.[a-z]+$/] } if (Array.isArray(t.removeDirectoryIndex) && t.removeDirectoryIndex.length > 0) { let e = i.pathname.split("/"); const r = e[e.length - 1]; if (testParameter(r, t.removeDirectoryIndex)) { e = e.slice(0, -1); i.pathname = e.slice(1).join("/") + "/" } } if (i.hostname) { i.hostname = i.hostname.replace(/\.$/, ""); if (t.stripWWW && /^www\.(?!www\.)[a-z\-\d]{1,63}\.[a-z.\-\d]{2,63}$/.test(i.hostname)) { i.hostname = i.hostname.replace(/^www\./, "") } } if (Array.isArray(t.removeQueryParameters)) { for (const e of [...i.searchParams.keys()]) { if (testParameter(e, t.removeQueryParameters)) { i.searchParams.delete(e) } } } if (!Array.isArray(t.keepQueryParameters) && t.removeQueryParameters === true) { i.search = "" } if (Array.isArray(t.keepQueryParameters) && t.keepQueryParameters.length > 0) { for (const e of [...i.searchParams.keys()]) { if (!testParameter(e, t.keepQueryParameters)) { i.searchParams.delete(e) } } } if (t.sortQueryParameters) { i.searchParams.sort(); try { i.search = decodeURIComponent(i.search) } catch { } } if (t.removeTrailingSlash) { i.pathname = i.pathname.replace(/\/$/, "") } if (t.removeExplicitPort && i.port) { i.port = "" } const s = e; e = i.toString(); if (!t.removeSingleSlash && i.pathname === "/" && !s.endsWith("/") && i.hash === "") { e = e.replace(/\/$/, "") } if ((t.removeTrailingSlash || i.pathname === "/") && i.hash === "" && t.removeSingleSlash) { e = e.replace(/\/$/, "") } if (r && !t.normalizeProtocol) { e = e.replace(/^http:\/\//, "//") } if (t.stripProtocol) { e = e.replace(/^(?:https?:)?\/\//, "") } return e } var x = __nccwpck_require__(1766); var A = __nccwpck_require__(1002); function lowercaseKeys(e) { return Object.fromEntries(Object.entries(e).map((([e, t]) => [e.toLowerCase(), t]))) } class Response extends m.Readable { statusCode; headers; body; url; constructor({ statusCode: e, headers: t, body: r, url: n }) { if (typeof e !== "number") { throw new TypeError("Argument `statusCode` should be a number") } if (typeof t !== "object") { throw new TypeError("Argument `headers` should be an object") } if (!(r instanceof Uint8Array)) { throw new TypeError("Argument `body` should be a buffer") } if (typeof n !== "string") { throw new TypeError("Argument `url` should be a string") } super({ read() { this.push(r); this.push(null) } }); this.statusCode = e; this.headers = lowercaseKeys(t); this.body = r; this.url = n } } var P = __nccwpck_require__(1531); const R = ["aborted", "complete", "headers", "httpVersion", "httpVersionMinor", "httpVersionMajor", "method", "rawHeaders", "rawTrailers", "setTimeout", "socket", "statusCode", "statusMessage", "trailers", "url"]; function mimicResponse(e, t) { if (t._readableState.autoDestroy) { throw new Error("The second stream must have the `autoDestroy` option set to `false`") } const r = new Set([...Object.keys(e), ...R]); const n = {}; for (const i of r) { if (i in t) { continue } n[i] = { get() { const t = e[i]; const r = typeof t === "function"; return r ? t.bind(e) : t }, set(t) { e[i] = t }, enumerable: true, configurable: false } } Object.defineProperties(t, n); e.once("aborted", (() => { t.destroy(); t.emit("aborted") })); e.once("close", (() => { if (e.complete) { if (t.readable) { t.once("end", (() => { t.emit("close") })) } else { t.emit("close") } } else { t.emit("close") } })); return t } class types_RequestError extends Error { constructor(e) { super(e.message); Object.assign(this, e) } } class types_CacheError extends Error { constructor(e) { super(e.message); Object.assign(this, e) } } class CacheableRequest { constructor(e, t) { this.hooks = new Map; this.request = () => (e, t) => { let r; if (typeof e === "string") { r = normalizeUrlObject(g.parse(e)); e = {} } else if (e instanceof g.URL) { r = normalizeUrlObject(g.parse(e.toString())); e = {} } else { const [t, ...n] = (e.path ?? "").split("?"); const i = n.length > 0 ? `?${n.join("?")}` : ""; r = normalizeUrlObject({ ...e, pathname: t, search: i }) } e = { headers: {}, method: "GET", cache: true, strictTtl: false, automaticFailover: false, ...e, ...urlObjectToRequestOptions(r) }; e.headers = Object.fromEntries(k(e.headers).map((([e, t]) => [e.toLowerCase(), t]))); const n = new d; const i = normalizeUrl(g.format(r), { stripWWW: false, removeTrailingSlash: false, stripAuthentication: false }); let s = `${e.method}:${i}`; if (e.body && e.method !== undefined && ["POST", "PATCH", "PUT"].includes(e.method)) { if (e.body instanceof m.Readable) { e.cache = false } else { s += `:${D.createHash("md5").update(e.body).digest("hex")}` } } let o = false; let a = false; const makeRequest = e => { a = true; let r = false; let requestErrorCallback = () => { }; const i = new Promise((e => { requestErrorCallback = () => { if (!r) { r = true; e() } } })); const handler = async r => { if (o) { r.status = r.statusCode; const t = A.fromObject(o.cachePolicy).revalidatedPolicy(e, r); if (!t.modified) { r.resume(); await new Promise((e => { r.once("end", e) })); const e = convertHeaders(t.policy.responseHeaders()); r = new Response({ statusCode: o.statusCode, headers: e, body: o.body, url: o.url }); r.cachePolicy = t.policy; r.fromCache = true } } if (!r.fromCache) { r.cachePolicy = new A(e, r, e); r.fromCache = false } let a; if (e.cache && r.cachePolicy.storable()) { a = cloneResponse(r); (async () => { try { const t = x.buffer(r); await Promise.race([i, new Promise((e => r.once("end", e))), new Promise((e => r.once("close", e)))]); const n = await t; let a = { url: r.url, statusCode: r.fromCache ? o.statusCode : r.statusCode, body: n, cachePolicy: r.cachePolicy.toObject() }; let u = e.strictTtl ? r.cachePolicy.timeToLive() : undefined; if (e.maxTtl) { u = u ? Math.min(u, e.maxTtl) : e.maxTtl } if (this.hooks.size > 0) { for (const e of this.hooks.keys()) { a = await this.runHook(e, a, r) } } await this.cache.set(s, a, u) } catch (e) { n.emit("error", new types_CacheError(e)) } })() } else if (e.cache && o) { (async () => { try { await this.cache.delete(s) } catch (e) { n.emit("error", new types_CacheError(e)) } })() } n.emit("response", a ?? r); if (typeof t === "function") { t(a ?? r) } }; try { const t = this.cacheRequest(e, handler); t.once("error", requestErrorCallback); t.once("abort", requestErrorCallback); t.once("destroy", requestErrorCallback); n.emit("request", t) } catch (e) { n.emit("error", new types_RequestError(e)) } }; (async () => { const get = async e => { await Promise.resolve(); const r = e.cache ? await this.cache.get(s) : undefined; if (typeof r === "undefined" && !e.forceRefresh) { makeRequest(e); return } const i = A.fromObject(r.cachePolicy); if (i.satisfiesWithoutRevalidation(e) && !e.forceRefresh) { const e = convertHeaders(i.responseHeaders()); const s = new Response({ statusCode: r.statusCode, headers: e, body: r.body, url: r.url }); s.cachePolicy = i; s.fromCache = true; n.emit("response", s); if (typeof t === "function") { t(s) } } else if (i.satisfiesWithoutRevalidation(e) && Date.now() >= i.timeToLive() && e.forceRefresh) { await this.cache.delete(s); e.headers = i.revalidationHeaders(e); makeRequest(e) } else { o = r; e.headers = i.revalidationHeaders(e); makeRequest(e) } }; const errorHandler = e => n.emit("error", new types_CacheError(e)); if (this.cache instanceof P) { const e = this.cache; e.once("error", errorHandler); n.on("error", (() => e.removeListener("error", errorHandler))); n.on("response", (() => e.removeListener("error", errorHandler))) } try { await get(e) } catch (t) { if (e.automaticFailover && !a) { makeRequest(e) } n.emit("error", new types_CacheError(t)) } })(); return n }; this.addHook = (e, t) => { if (!this.hooks.has(e)) { this.hooks.set(e, t) } }; this.removeHook = e => this.hooks.delete(e); this.getHook = e => this.hooks.get(e); this.runHook = async (e, ...t) => this.hooks.get(e)?.(...t); if (t instanceof P) { this.cache = t } else if (typeof t === "string") { this.cache = new P({ uri: t, namespace: "cacheable-request" }) } else { this.cache = new P({ store: t, namespace: "cacheable-request" }) } this.request = this.request.bind(this); this.cacheRequest = e } } const k = Object.entries; const cloneResponse = e => { const t = new m.PassThrough({ autoDestroy: false }); mimicResponse(e, t); return e.pipe(t) }; const urlObjectToRequestOptions = e => { const t = { ...e }; t.path = `${e.pathname || "/"}${e.search || ""}`; delete t.pathname; delete t.search; return t }; const normalizeUrlObject = e => ({ protocol: e.protocol, auth: e.auth, hostname: e.hostname || e.host || "localhost", port: e.port, pathname: e.pathname, search: e.search }); const convertHeaders = e => { const t = []; for (const r of Object.keys(e)) { t[r.toLowerCase()] = e[r] } return t }; const O = CacheableRequest; const T = "onResponse"; var F = __nccwpck_require__(2391); const isFunction = e => typeof e === "function"; const isFormData = e => Boolean(e && isFunction(e.constructor) && e[Symbol.toStringTag] === "FormData" && isFunction(e.append) && isFunction(e.getAll) && isFunction(e.entries) && isFunction(e[Symbol.iterator])); const isAsyncIterable = e => isFunction(e[Symbol.asyncIterator]); async function* readStream(e) { const t = e.getReader(); while (true) { const { done: e, value: r } = await t.read(); if (e) { break } yield r } } const getStreamIterator = e => { if (isAsyncIterable(e)) { return e } if (isFunction(e.getReader)) { return readStream(e) } throw new TypeError("Unsupported data source: Expected either ReadableStream or async iterable.") }; const j = "abcdefghijklmnopqrstuvwxyz0123456789"; function createBoundary() { let e = 16; let t = ""; while (e--) { t += j[Math.random() * j.length << 0] } return t } const normalizeValue = e => String(e).replace(/\r|\n/g, ((e, t, r) => { if (e === "\r" && r[t + 1] !== "\n" || e === "\n" && r[t - 1] !== "\r") { return "\r\n" } return e })); const getType = e => Object.prototype.toString.call(e).slice(8, -1).toLowerCase(); function isPlainObject(e) { if (getType(e) !== "object") { return false } const t = Object.getPrototypeOf(e); if (t === null || t === undefined) { return true } const r = t.constructor && t.constructor.toString(); return r === Object.toString() } function getProperty(e, t) { if (typeof t === "string") { for (const [r, n] of Object.entries(e)) { if (t.toLowerCase() === r.toLowerCase()) { return n } } } return undefined } const proxyHeaders = e => new Proxy(e, { get: (e, t) => getProperty(e, t), has: (e, t) => getProperty(e, t) !== undefined }); const escapeName = e => String(e).replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/"/g, "%22"); const isFile = e => Boolean(e && typeof e === "object" && isFunction(e.constructor) && e[Symbol.toStringTag] === "File" && isFunction(e.stream) && e.name != null); const L = null && isFile; var I = undefined && undefined.__classPrivateFieldSet || function (e, t, r, n, i) { if (n === "m") throw new TypeError("Private method is not writable"); if (n === "a" && !i) throw new TypeError("Private accessor was defined without a setter"); if (typeof t === "function" ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it"); return n === "a" ? i.call(e, r) : i ? i.value = r : t.set(e, r), r }; var B = undefined && undefined.__classPrivateFieldGet || function (e, t, r, n) { if (r === "a" && !n) throw new TypeError("Private accessor was defined without a getter"); if (typeof t === "function" ? e !== t || !n : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return r === "m" ? n : r === "a" ? n.call(e) : n ? n.value : t.get(e) }; var N, M, H, q, U, W, G, z, V, K, J; const Y = { enableAdditionalHeaders: false }; const Q = { writable: false, configurable: false }; class FormDataEncoder { constructor(e, t, r) { N.add(this); M.set(this, "\r\n"); H.set(this, void 0); q.set(this, void 0); U.set(this, "-".repeat(2)); W.set(this, new TextEncoder); G.set(this, void 0); z.set(this, void 0); V.set(this, void 0); if (!isFormData(e)) { throw new TypeError("Expected first argument to be a FormData instance.") } let n; if (isPlainObject(t)) { r = t } else { n = t } if (!n) { n = createBoundary() } if (typeof n !== "string") { throw new TypeError("Expected boundary argument to be a string.") } if (r && !isPlainObject(r)) { throw new TypeError("Expected options argument to be an object.") } I(this, z, Array.from(e.entries()), "f"); I(this, V, { ...Y, ...r }, "f"); I(this, H, B(this, W, "f").encode(B(this, M, "f")), "f"); I(this, q, B(this, H, "f").byteLength, "f"); this.boundary = `form-data-boundary-${n}`; this.contentType = `multipart/form-data; boundary=${this.boundary}`; I(this, G, B(this, W, "f").encode(`${B(this, U, "f")}${this.boundary}${B(this, U, "f")}${B(this, M, "f").repeat(2)}`), "f"); const i = { "Content-Type": this.contentType }; const s = B(this, N, "m", J).call(this); if (s) { this.contentLength = s; i["Content-Length"] = s } this.headers = proxyHeaders(Object.freeze(i)); Object.defineProperties(this, { boundary: Q, contentType: Q, contentLength: Q, headers: Q }) } getContentLength() { return this.contentLength == null ? undefined : Number(this.contentLength) } *values() { for (const [e, t] of B(this, z, "f")) { const r = isFile(t) ? t : B(this, W, "f").encode(normalizeValue(t)); yield B(this, N, "m", K).call(this, e, r); yield r; yield B(this, H, "f") } yield B(this, G, "f") } async*encode() { for (const e of this.values()) { if (isFile(e)) { yield* getStreamIterator(e.stream()) } else { yield e } } } [(M = new WeakMap, H = new WeakMap, q = new WeakMap, U = new WeakMap, W = new WeakMap, G = new WeakMap, z = new WeakMap, V = new WeakMap, N = new WeakSet, K = function _FormDataEncoder_getFieldHeader(e, t) { let r = ""; r += `${B(this, U, "f")}${this.boundary}${B(this, M, "f")}`; r += `Content-Disposition: form-data; name="${escapeName(e)}"`; if (isFile(t)) { r += `; filename="${escapeName(t.name)}"${B(this, M, "f")}`; r += `Content-Type: ${t.type || "application/octet-stream"}` } const n = isFile(t) ? t.size : t.byteLength; if (B(this, V, "f").enableAdditionalHeaders === true && n != null && !isNaN(n)) { r += `${B(this, M, "f")}Content-Length: ${isFile(t) ? t.size : t.byteLength}` } return B(this, W, "f").encode(`${r}${B(this, M, "f").repeat(2)}`) }, J = function _FormDataEncoder_getContentLength() { let e = 0; for (const [t, r] of B(this, z, "f")) { const n = isFile(r) ? r : B(this, W, "f").encode(normalizeValue(r)); const i = isFile(n) ? n.size : n.byteLength; if (i == null || isNaN(i)) { return undefined } e += B(this, N, "m", K).call(this, t, n).byteLength; e += i; e += B(this, q, "f") } return String(e + B(this, G, "f").byteLength) }, Symbol.iterator)]() { return this.values() } [Symbol.asyncIterator]() { return this.encode() } } const X = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("util"); function is_form_data_isFormData(e) { return f.nodeStream(e) && f.function_(e.getBoundary) } async function getBodySize(e, t) { if (t && "content-length" in t) { return Number(t["content-length"]) } if (!e) { return 0 } if (f.string(e)) { return h.Buffer.byteLength(e) } if (f.buffer(e)) { return e.length } if (is_form_data_isFormData(e)) { return (0, X.promisify)(e.getLength.bind(e))() } return undefined } function proxyEvents(e, t, r) { const n = {}; for (const i of r) { const eventFunction = (...e) => { t.emit(i, ...e) }; n[i] = eventFunction; e.on(i, eventFunction) } return () => { for (const [t, r] of Object.entries(n)) { e.off(t, r) } } } const Z = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("net"); function unhandle() { const e = []; return { once(t, r, n) { t.once(r, n); e.push({ origin: t, event: r, fn: n }) }, unhandleAll() { for (const t of e) { const { origin: e, event: r, fn: n } = t; e.removeListener(r, n) } e.length = 0 } } } const ee = Symbol("reentry"); const noop = () => { }; class timed_out_TimeoutError extends Error { constructor(e, t) { super(`Timeout awaiting '${t}' for ${e}ms`); Object.defineProperty(this, "event", { enumerable: true, configurable: true, writable: true, value: t }); Object.defineProperty(this, "code", { enumerable: true, configurable: true, writable: true, value: void 0 }); this.name = "TimeoutError"; this.code = "ETIMEDOUT" } } function timedOut(e, t, r) { if (ee in e) { return noop } e[ee] = true; const n = []; const { once: i, unhandleAll: s } = unhandle(); const addTimeout = (e, t, r) => { const i = setTimeout(t, e, e, r); i.unref?.(); const cancel = () => { clearTimeout(i) }; n.push(cancel); return cancel }; const { host: o, hostname: a } = r; const timeoutHandler = (t, r) => { e.destroy(new timed_out_TimeoutError(t, r)) }; const cancelTimeouts = () => { for (const e of n) { e() } s() }; e.once("error", (t => { cancelTimeouts(); if (e.listenerCount("error") === 0) { throw t } })); if (typeof t.request !== "undefined") { const r = addTimeout(t.request, timeoutHandler, "request"); i(e, "response", (e => { i(e, "end", r) })) } if (typeof t.socket !== "undefined") { const { socket: r } = t; const socketTimeoutHandler = () => { timeoutHandler(r, "socket") }; e.setTimeout(r, socketTimeoutHandler); n.push((() => { e.removeListener("timeout", socketTimeoutHandler) })) } const u = typeof t.lookup !== "undefined"; const l = typeof t.connect !== "undefined"; const f = typeof t.secureConnect !== "undefined"; const d = typeof t.send !== "undefined"; if (u || l || f || d) { i(e, "socket", (n => { const { socketPath: s } = e; if (n.connecting) { const e = Boolean(s ?? Z.isIP(a ?? o ?? "") !== 0); if (u && !e && typeof n.address().address === "undefined") { const e = addTimeout(t.lookup, timeoutHandler, "lookup"); i(n, "lookup", e) } if (l) { const timeConnect = () => addTimeout(t.connect, timeoutHandler, "connect"); if (e) { i(n, "connect", timeConnect()) } else { i(n, "lookup", (e => { if (e === null) { i(n, "connect", timeConnect()) } })) } } if (f && r.protocol === "https:") { i(n, "connect", (() => { const e = addTimeout(t.secureConnect, timeoutHandler, "secureConnect"); i(n, "secureConnect", e) })) } } if (d) { const timeRequest = () => addTimeout(t.send, timeoutHandler, "send"); if (n.connecting) { i(n, "connect", (() => { i(e, "upload-complete", timeRequest()) })) } else { i(e, "upload-complete", timeRequest()) } } })) } if (typeof t.response !== "undefined") { i(e, "upload-complete", (() => { const r = addTimeout(t.response, timeoutHandler, "response"); i(e, "response", r) })) } if (typeof t.read !== "undefined") { i(e, "response", (e => { const r = addTimeout(t.read, timeoutHandler, "read"); i(e, "end", r) })) } return cancelTimeouts } function urlToOptions(e) { e = e; const t = { protocol: e.protocol, hostname: f.string(e.hostname) && e.hostname.startsWith("[") ? e.hostname.slice(1, -1) : e.hostname, host: e.host, hash: e.hash, search: e.search, pathname: e.pathname, href: e.href, path: `${e.pathname || ""}${e.search || ""}` }; if (f.string(e.port) && e.port.length > 0) { t.port = Number(e.port) } if (e.username || e.password) { t.auth = `${e.username || ""}:${e.password || ""}` } return t } class WeakableMap { constructor() { Object.defineProperty(this, "weakMap", { enumerable: true, configurable: true, writable: true, value: void 0 }); Object.defineProperty(this, "map", { enumerable: true, configurable: true, writable: true, value: void 0 }); this.weakMap = new WeakMap; this.map = new Map } set(e, t) { if (typeof e === "object") { this.weakMap.set(e, t) } else { this.map.set(e, t) } } get(e) { if (typeof e === "object") { return this.weakMap.get(e) } return this.map.get(e) } has(e) { if (typeof e === "object") { return this.weakMap.has(e) } return this.map.has(e) } } const calculateRetryDelay = ({ attemptCount: e, retryOptions: t, error: r, retryAfter: n, computedValue: i }) => { if (r.name === "RetryError") { return 1 } if (e > t.limit) { return 0 } const s = t.methods.includes(r.options.method); const o = t.errorCodes.includes(r.code); const a = r.response && t.statusCodes.includes(r.response.statusCode); if (!s || !o && !a) { return 0 } if (r.response) { if (n) { if (n > i) { return 0 } return n } if (r.response.statusCode === 413) { return 0 } } const u = Math.random() * t.noise; return Math.min(2 ** (e - 1) * 1e3, t.backoffLimit) + u }; const te = calculateRetryDelay; const re = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("tls"); const ne = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("https"); const ie = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("dns"); const se = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("os"); const { Resolver: oe } = ie.promises; const ae = Symbol("cacheableLookupCreateConnection"); const ue = Symbol("cacheableLookupInstance"); const ce = Symbol("expires"); const le = typeof ie.ALL === "number"; const verifyAgent = e => { if (!(e && typeof e.createConnection === "function")) { throw new Error("Expected an Agent instance as the first argument") } }; const map4to6 = e => { for (const t of e) { if (t.family === 6) { continue } t.address = `::ffff:${t.address}`; t.family = 6 } }; const getIfaceInfo = () => { let e = false; let t = false; for (const r of Object.values(se.networkInterfaces())) { for (const n of r) { if (n.internal) { continue } if (n.family === "IPv6") { t = true } else { e = true } if (e && t) { return { has4: e, has6: t } } } } return { has4: e, has6: t } }; const isIterable = e => Symbol.iterator in e; const ignoreNoResultErrors = e => e.catch((e => { if (e.code === "ENODATA" || e.code === "ENOTFOUND" || e.code === "ENOENT") { return [] } throw e })); const fe = { ttl: true }; const de = { all: true }; const pe = { all: true, family: 4 }; const he = { all: true, family: 6 }; class CacheableLookup { constructor({ cache: e = new Map, maxTtl: t = Infinity, fallbackDuration: r = 3600, errorTtl: n = .15, resolver: i = new oe, lookup: s = ie.lookup } = {}) { this.maxTtl = t; this.errorTtl = n; this._cache = e; this._resolver = i; this._dnsLookup = s && (0, X.promisify)(s); this.stats = { cache: 0, query: 0 }; if (this._resolver instanceof oe) { this._resolve4 = this._resolver.resolve4.bind(this._resolver); this._resolve6 = this._resolver.resolve6.bind(this._resolver) } else { this._resolve4 = (0, X.promisify)(this._resolver.resolve4.bind(this._resolver)); this._resolve6 = (0, X.promisify)(this._resolver.resolve6.bind(this._resolver)) } this._iface = getIfaceInfo(); this._pending = {}; this._nextRemovalTime = false; this._hostnamesToFallback = new Set; this.fallbackDuration = r; if (r > 0) { const e = setInterval((() => { this._hostnamesToFallback.clear() }), r * 1e3); if (e.unref) { e.unref() } this._fallbackInterval = e } this.lookup = this.lookup.bind(this); this.lookupAsync = this.lookupAsync.bind(this) } set servers(e) { this.clear(); this._resolver.setServers(e) } get servers() { return this._resolver.getServers() } lookup(e, t, r) { if (typeof t === "function") { r = t; t = {} } else if (typeof t === "number") { t = { family: t } } if (!r) { throw new Error("Callback must be a function.") } this.lookupAsync(e, t).then((e => { if (t.all) { r(null, e) } else { r(null, e.address, e.family, e.expires, e.ttl, e.source) } }), r) } async lookupAsync(e, t = {}) { if (typeof t === "number") { t = { family: t } } let r = await this.query(e); if (t.family === 6) { const e = r.filter((e => e.family === 6)); if (t.hints & ie.V4MAPPED) { if (le && t.hints & ie.ALL || e.length === 0) { map4to6(r) } else { r = e } } else { r = e } } else if (t.family === 4) { r = r.filter((e => e.family === 4)) } if (t.hints & ie.ADDRCONFIG) { const { _iface: e } = this; r = r.filter((t => t.family === 6 ? e.has6 : e.has4)) } if (r.length === 0) { const t = new Error(`cacheableLookup ENOTFOUND ${e}`); t.code = "ENOTFOUND"; t.hostname = e; throw t } if (t.all) { return r } return r[0] } async query(e) { let t = "cache"; let r = await this._cache.get(e); if (r) { this.stats.cache++ } if (!r) { const n = this._pending[e]; if (n) { this.stats.cache++; r = await n } else { t = "query"; const n = this.queryAndCache(e); this._pending[e] = n; this.stats.query++; try { r = await n } finally { delete this._pending[e] } } } r = r.map((e => ({ ...e, source: t }))); return r } async _resolve(e) { const [t, r] = await Promise.all([ignoreNoResultErrors(this._resolve4(e, fe)), ignoreNoResultErrors(this._resolve6(e, fe))]); let n = 0; let i = 0; let s = 0; const o = Date.now(); for (const e of t) { e.family = 4; e.expires = o + e.ttl * 1e3; n = Math.max(n, e.ttl) } for (const e of r) { e.family = 6; e.expires = o + e.ttl * 1e3; i = Math.max(i, e.ttl) } if (t.length > 0) { if (r.length > 0) { s = Math.min(n, i) } else { s = n } } else { s = i } return { entries: [...t, ...r], cacheTtl: s } } async _lookup(e) { try { const [t, r] = await Promise.all([ignoreNoResultErrors(this._dnsLookup(e, pe)), ignoreNoResultErrors(this._dnsLookup(e, he))]); return { entries: [...t, ...r], cacheTtl: 0 } } catch { return { entries: [], cacheTtl: 0 } } } async _set(e, t, r) { if (this.maxTtl > 0 && r > 0) { r = Math.min(r, this.maxTtl) * 1e3; t[ce] = Date.now() + r; try { await this._cache.set(e, t, r) } catch (e) { this.lookupAsync = async () => { const t = new Error("Cache Error. Please recreate the CacheableLookup instance."); t.cause = e; throw t } } if (isIterable(this._cache)) { this._tick(r) } } } async queryAndCache(e) { if (this._hostnamesToFallback.has(e)) { return this._dnsLookup(e, de) } let t = await this._resolve(e); if (t.entries.length === 0 && this._dnsLookup) { t = await this._lookup(e); if (t.entries.length !== 0 && this.fallbackDuration > 0) { this._hostnamesToFallback.add(e) } } const r = t.entries.length === 0 ? this.errorTtl : t.cacheTtl; await this._set(e, t.entries, r); return t.entries } _tick(e) { const t = this._nextRemovalTime; if (!t || e < t) { clearTimeout(this._removalTimeout); this._nextRemovalTime = e; this._removalTimeout = setTimeout((() => { this._nextRemovalTime = false; let e = Infinity; const t = Date.now(); for (const [r, n] of this._cache) { const i = n[ce]; if (t >= i) { this._cache.delete(r) } else if (i < e) { e = i } } if (e !== Infinity) { this._tick(e - t) } }), e); if (this._removalTimeout.unref) { this._removalTimeout.unref() } } } install(e) { verifyAgent(e); if (ae in e) { throw new Error("CacheableLookup has been already installed") } e[ae] = e.createConnection; e[ue] = this; e.createConnection = (t, r) => { if (!("lookup" in t)) { t.lookup = this.lookup } return e[ae](t, r) } } uninstall(e) { verifyAgent(e); if (e[ae]) { if (e[ue] !== this) { throw new Error("The agent is not owned by this CacheableLookup instance") } e.createConnection = e[ae]; delete e[ae]; delete e[ue] } } updateInterfaceInfo() { const { _iface: e } = this; this._iface = getIfaceInfo(); if (e.has4 && !this._iface.has4 || e.has6 && !this._iface.has6) { this._cache.clear() } } clear(e) { if (e) { this._cache.delete(e); return } this._cache.clear() } } var me = __nccwpck_require__(4645); function parseLinkHeader(e) { const t = []; const r = e.split(","); for (const n of r) { const [r, ...i] = n.split(";"); const s = r.trim(); if (s[0] !== "<" || s[s.length - 1] !== ">") { throw new Error(`Invalid format of the Link header reference: ${s}`) } const o = s.slice(1, -1); const a = {}; if (i.length === 0) { throw new Error(`Unexpected end of Link header parameters: ${i.join(";")}`) } for (const t of i) { const r = t.trim(); const n = r.indexOf("="); if (n === -1) { throw new Error(`Failed to parse Link header: ${e}`) } const i = r.slice(0, n).trim(); const s = r.slice(n + 1).trim(); a[i] = s } t.push({ reference: o, parameters: a }) } return t } const [ge, ye] = p.versions.node.split(".").map(Number); function validateSearchParameters(e) { for (const t in e) { const r = e[t]; l.any([f.string, f.number, f.boolean, f.null_, f.undefined], r) } } const be = new Map; let _e; const getGlobalDnsCache = () => { if (_e) { return _e } _e = new CacheableLookup; return _e }; const ve = { request: undefined, agent: { http: undefined, https: undefined, http2: undefined }, h2session: undefined, decompress: true, timeout: { connect: undefined, lookup: undefined, read: undefined, request: undefined, response: undefined, secureConnect: undefined, send: undefined, socket: undefined }, prefixUrl: "", body: undefined, form: undefined, json: undefined, cookieJar: undefined, ignoreInvalidCookies: false, searchParams: undefined, dnsLookup: undefined, dnsCache: undefined, context: {}, hooks: { init: [], beforeRequest: [], beforeError: [], beforeRedirect: [], beforeRetry: [], afterResponse: [] }, followRedirect: true, maxRedirects: 10, cache: undefined, throwHttpErrors: true, username: "", password: "", http2: false, allowGetBody: false, headers: { "user-agent": "got (https://github.com/sindresorhus/got)" }, methodRewriting: false, dnsLookupIpVersion: undefined, parseJson: JSON.parse, stringifyJson: JSON.stringify, retry: { limit: 2, methods: ["GET", "PUT", "HEAD", "DELETE", "OPTIONS", "TRACE"], statusCodes: [408, 413, 429, 500, 502, 503, 504, 521, 522, 524], errorCodes: ["ETIMEDOUT", "ECONNRESET", "EADDRINUSE", "ECONNREFUSED", "EPIPE", "ENOTFOUND", "ENETUNREACH", "EAI_AGAIN"], maxRetryAfter: undefined, calculateDelay: ({ computedValue: e }) => e, backoffLimit: Number.POSITIVE_INFINITY, noise: 100 }, localAddress: undefined, method: "GET", createConnection: undefined, cacheOptions: { shared: undefined, cacheHeuristic: undefined, immutableMinTimeToLive: undefined, ignoreCargoCult: undefined }, https: { alpnProtocols: undefined, rejectUnauthorized: undefined, checkServerIdentity: undefined, certificateAuthority: undefined, key: undefined, certificate: undefined, passphrase: undefined, pfx: undefined, ciphers: undefined, honorCipherOrder: undefined, minVersion: undefined, maxVersion: undefined, signatureAlgorithms: undefined, tlsSessionLifetime: undefined, dhparam: undefined, ecdhCurve: undefined, certificateRevocationLists: undefined }, encoding: undefined, resolveBodyOnly: false, isStream: false, responseType: "text", url: undefined, pagination: { transform(e) { if (e.request.options.responseType === "json") { return e.body } return JSON.parse(e.body) }, paginate({ response: e }) { const t = e.headers.link; if (typeof t !== "string" || t.trim() === "") { return false } const r = parseLinkHeader(t); const n = r.find((e => e.parameters.rel === "next" || e.parameters.rel === '"next"')); if (n) { return { url: new g.URL(n.reference, e.url) } } return false }, filter: () => true, shouldContinue: () => true, countLimit: Number.POSITIVE_INFINITY, backoff: 0, requestLimit: 1e4, stackAllItems: false }, setHost: true, maxHeaderSize: undefined, signal: undefined, enableUnixSockets: true }; const cloneInternals = e => { const { hooks: t, retry: r } = e; const n = { ...e, context: { ...e.context }, cacheOptions: { ...e.cacheOptions }, https: { ...e.https }, agent: { ...e.agent }, headers: { ...e.headers }, retry: { ...r, errorCodes: [...r.errorCodes], methods: [...r.methods], statusCodes: [...r.statusCodes] }, timeout: { ...e.timeout }, hooks: { init: [...t.init], beforeRequest: [...t.beforeRequest], beforeError: [...t.beforeError], beforeRedirect: [...t.beforeRedirect], beforeRetry: [...t.beforeRetry], afterResponse: [...t.afterResponse] }, searchParams: e.searchParams ? new g.URLSearchParams(e.searchParams) : undefined, pagination: { ...e.pagination } }; if (n.url !== undefined) { n.prefixUrl = "" } return n }; const cloneRaw = e => { const { hooks: t, retry: r } = e; const n = { ...e }; if (f.object(e.context)) { n.context = { ...e.context } } if (f.object(e.cacheOptions)) { n.cacheOptions = { ...e.cacheOptions } } if (f.object(e.https)) { n.https = { ...e.https } } if (f.object(e.cacheOptions)) { n.cacheOptions = { ...n.cacheOptions } } if (f.object(e.agent)) { n.agent = { ...e.agent } } if (f.object(e.headers)) { n.headers = { ...e.headers } } if (f.object(r)) { n.retry = { ...r }; if (f.array(r.errorCodes)) { n.retry.errorCodes = [...r.errorCodes] } if (f.array(r.methods)) { n.retry.methods = [...r.methods] } if (f.array(r.statusCodes)) { n.retry.statusCodes = [...r.statusCodes] } } if (f.object(e.timeout)) { n.timeout = { ...e.timeout } } if (f.object(t)) { n.hooks = { ...t }; if (f.array(t.init)) { n.hooks.init = [...t.init] } if (f.array(t.beforeRequest)) { n.hooks.beforeRequest = [...t.beforeRequest] } if (f.array(t.beforeError)) { n.hooks.beforeError = [...t.beforeError] } if (f.array(t.beforeRedirect)) { n.hooks.beforeRedirect = [...t.beforeRedirect] } if (f.array(t.beforeRetry)) { n.hooks.beforeRetry = [...t.beforeRetry] } if (f.array(t.afterResponse)) { n.hooks.afterResponse = [...t.afterResponse] } } if (f.object(e.pagination)) { n.pagination = { ...e.pagination } } return n }; const getHttp2TimeoutOption = e => { const t = [e.timeout.socket, e.timeout.connect, e.timeout.lookup, e.timeout.request, e.timeout.secureConnect].filter((e => typeof e === "number")); if (t.length > 0) { return Math.min(...t) } return undefined }; const options_init = (e, t, r) => { const n = e.hooks?.init; if (n) { for (const e of n) { e(t, r) } } }; class Options { constructor(e, t, r) { Object.defineProperty(this, "_unixOptions", { enumerable: true, configurable: true, writable: true, value: void 0 }); Object.defineProperty(this, "_internals", { enumerable: true, configurable: true, writable: true, value: void 0 }); Object.defineProperty(this, "_merging", { enumerable: true, configurable: true, writable: true, value: void 0 }); Object.defineProperty(this, "_init", { enumerable: true, configurable: true, writable: true, value: void 0 }); l.any([f.string, f.urlInstance, f.object, f.undefined], e); l.any([f.object, f.undefined], t); l.any([f.object, f.undefined], r); if (e instanceof Options || t instanceof Options) { throw new TypeError("The defaults must be passed as the third argument") } this._internals = cloneInternals(r?._internals ?? r ?? ve); this._init = [...r?._init ?? []]; this._merging = false; this._unixOptions = undefined; try { if (f.plainObject(e)) { try { this.merge(e); this.merge(t) } finally { this.url = e.url } } else { try { this.merge(t) } finally { if (t?.url !== undefined) { if (e === undefined) { this.url = t.url } else { throw new TypeError("The `url` option is mutually exclusive with the `input` argument") } } else if (e !== undefined) { this.url = e } } } } catch (e) { e.options = this; throw e } } merge(e) { if (!e) { return } if (e instanceof Options) { for (const t of e._init) { this.merge(t) } return } e = cloneRaw(e); options_init(this, e, this); options_init(e, e, this); this._merging = true; if ("isStream" in e) { this.isStream = e.isStream } try { let t = false; for (const r in e) { if (r === "mutableDefaults" || r === "handlers") { continue } if (r === "url") { continue } if (!(r in this)) { throw new Error(`Unexpected option: ${r}`) } this[r] = e[r]; t = true } if (t) { this._init.push(e) } } finally { this._merging = false } } get request() { return this._internals.request } set request(e) { l.any([f.function_, f.undefined], e); this._internals.request = e } get agent() { return this._internals.agent } set agent(e) { l.plainObject(e); for (const t in e) { if (!(t in this._internals.agent)) { throw new TypeError(`Unexpected agent option: ${t}`) } l.any([f.object, f.undefined], e[t]) } if (this._merging) { Object.assign(this._internals.agent, e) } else { this._internals.agent = { ...e } } } get h2session() { return this._internals.h2session } set h2session(e) { this._internals.h2session = e } get decompress() { return this._internals.decompress } set decompress(e) { l.boolean(e); this._internals.decompress = e } get timeout() { return this._internals.timeout } set timeout(e) { l.plainObject(e); for (const t in e) { if (!(t in this._internals.timeout)) { throw new Error(`Unexpected timeout option: ${t}`) } l.any([f.number, f.undefined], e[t]) } if (this._merging) { Object.assign(this._internals.timeout, e) } else { this._internals.timeout = { ...e } } } get prefixUrl() { return this._internals.prefixUrl } set prefixUrl(e) { l.any([f.string, f.urlInstance], e); if (e === "") { this._internals.prefixUrl = ""; return } e = e.toString(); if (!e.endsWith("/")) { e += "/" } if (this._internals.prefixUrl && this._internals.url) { const { href: t } = this._internals.url; this._internals.url.href = e + t.slice(this._internals.prefixUrl.length) } this._internals.prefixUrl = e } get body() { return this._internals.body } set body(e) { l.any([f.string, f.buffer, f.nodeStream, f.generator, f.asyncGenerator, isFormData, f.undefined], e); if (f.nodeStream(e)) { l.truthy(e.readable) } if (e !== undefined) { l.undefined(this._internals.form); l.undefined(this._internals.json) } this._internals.body = e } get form() { return this._internals.form } set form(e) { l.any([f.plainObject, f.undefined], e); if (e !== undefined) { l.undefined(this._internals.body); l.undefined(this._internals.json) } this._internals.form = e } get json() { return this._internals.json } set json(e) { if (e !== undefined) { l.undefined(this._internals.body); l.undefined(this._internals.form) } this._internals.json = e } get url() { return this._internals.url } set url(e) { l.any([f.string, f.urlInstance, f.undefined], e); if (e === undefined) { this._internals.url = undefined; return } if (f.string(e) && e.startsWith("/")) { throw new Error("`url` must not start with a slash") } const t = `${this.prefixUrl}${e.toString()}`; const r = new g.URL(t); this._internals.url = r; if (r.protocol === "unix:") { r.href = `http://unix${r.pathname}${r.search}` } if (r.protocol !== "http:" && r.protocol !== "https:") { const e = new Error(`Unsupported protocol: ${r.protocol}`); e.code = "ERR_UNSUPPORTED_PROTOCOL"; throw e } if (this._internals.username) { r.username = this._internals.username; this._internals.username = "" } if (this._internals.password) { r.password = this._internals.password; this._internals.password = "" } if (this._internals.searchParams) { r.search = this._internals.searchParams.toString(); this._internals.searchParams = undefined } if (r.hostname === "unix") { if (!this._internals.enableUnixSockets) { throw new Error("Using UNIX domain sockets but option `enableUnixSockets` is not enabled") } const e = /(?<socketPath>.+?):(?<path>.+)/.exec(`${r.pathname}${r.search}`); if (e?.groups) { const { socketPath: t, path: r } = e.groups; this._unixOptions = { socketPath: t, path: r, host: "" } } else { this._unixOptions = undefined } return } this._unixOptions = undefined } get cookieJar() { return this._internals.cookieJar } set cookieJar(e) { l.any([f.object, f.undefined], e); if (e === undefined) { this._internals.cookieJar = undefined; return } let { setCookie: t, getCookieString: r } = e; l.function_(t); l.function_(r); if (t.length === 4 && r.length === 0) { t = (0, X.promisify)(t.bind(e)); r = (0, X.promisify)(r.bind(e)); this._internals.cookieJar = { setCookie: t, getCookieString: r } } else { this._internals.cookieJar = e } } get signal() { return this._internals.signal } set signal(e) { l.object(e); this._internals.signal = e } get ignoreInvalidCookies() { return this._internals.ignoreInvalidCookies } set ignoreInvalidCookies(e) { l.boolean(e); this._internals.ignoreInvalidCookies = e } get searchParams() { if (this._internals.url) { return this._internals.url.searchParams } if (this._internals.searchParams === undefined) { this._internals.searchParams = new g.URLSearchParams } return this._internals.searchParams } set searchParams(e) { l.any([f.string, f.object, f.undefined], e); const t = this._internals.url; if (e === undefined) { this._internals.searchParams = undefined; if (t) { t.search = "" } return } const r = this.searchParams; let n; if (f.string(e)) { n = new g.URLSearchParams(e) } else if (e instanceof g.URLSearchParams) { n = e } else { validateSearchParameters(e); n = new g.URLSearchParams; for (const t in e) { const i = e[t]; if (i === null) { n.append(t, "") } else if (i === undefined) { r.delete(t) } else { n.append(t, i) } } } if (this._merging) { for (const e of n.keys()) { r.delete(e) } for (const [e, t] of n) { r.append(e, t) } } else if (t) { t.search = r.toString() } else { this._internals.searchParams = r } } get searchParameters() { throw new Error("The `searchParameters` option does not exist. Use `searchParams` instead.") } set searchParameters(e) { throw new Error("The `searchParameters` option does not exist. Use `searchParams` instead.") } get dnsLookup() { return this._internals.dnsLookup } set dnsLookup(e) { l.any([f.function_, f.undefined], e); this._internals.dnsLookup = e } get dnsCache() { return this._internals.dnsCache } set dnsCache(e) { l.any([f.object, f.boolean, f.undefined], e); if (e === true) { this._internals.dnsCache = getGlobalDnsCache() } else if (e === false) { this._internals.dnsCache = undefined } else { this._internals.dnsCache = e } } get context() { return this._internals.context } set context(e) { l.object(e); if (this._merging) { Object.assign(this._internals.context, e) } else { this._internals.context = { ...e } } } get hooks() { return this._internals.hooks } set hooks(e) { l.object(e); for (const t in e) { if (!(t in this._internals.hooks)) { throw new Error(`Unexpected hook event: ${t}`) } const r = t; const n = e[r]; l.any([f.array, f.undefined], n); if (n) { for (const e of n) { l.function_(e) } } if (this._merging) { if (n) { this._internals.hooks[r].push(...n) } } else { if (!n) { throw new Error(`Missing hook event: ${t}`) } this._internals.hooks[t] = [...n] } } } get followRedirect() { return this._internals.followRedirect } set followRedirect(e) { l.boolean(e); this._internals.followRedirect = e } get followRedirects() { throw new TypeError("The `followRedirects` option does not exist. Use `followRedirect` instead.") } set followRedirects(e) { throw new TypeError("The `followRedirects` option does not exist. Use `followRedirect` instead.") } get maxRedirects() { return this._internals.maxRedirects } set maxRedirects(e) { l.number(e); this._internals.maxRedirects = e } get cache() { return this._internals.cache } set cache(e) { l.any([f.object, f.string, f.boolean, f.undefined], e); if (e === true) { this._internals.cache = be } else if (e === false) { this._internals.cache = undefined } else { this._internals.cache = e } } get throwHttpErrors() { return this._internals.throwHttpErrors } set throwHttpErrors(e) { l.boolean(e); this._internals.throwHttpErrors = e } get username() { const e = this._internals.url; const t = e ? e.username : this._internals.username; return decodeURIComponent(t) } set username(e) { l.string(e); const t = this._internals.url; const r = encodeURIComponent(e); if (t) { t.username = r } else { this._internals.username = r } } get password() { const e = this._internals.url; const t = e ? e.password : this._internals.password; return decodeURIComponent(t) } set password(e) { l.string(e); const t = this._internals.url; const r = encodeURIComponent(e); if (t) { t.password = r } else { this._internals.password = r } } get http2() { return this._internals.http2 } set http2(e) { l.boolean(e); this._internals.http2 = e } get allowGetBody() { return this._internals.allowGetBody } set allowGetBody(e) { l.boolean(e); this._internals.allowGetBody = e } get headers() { return this._internals.headers } set headers(e) { l.plainObject(e); if (this._merging) { Object.assign(this._internals.headers, lowercaseKeys(e)) } else { this._internals.headers = lowercaseKeys(e) } } get methodRewriting() { return this._internals.methodRewriting } set methodRewriting(e) { l.boolean(e); this._internals.methodRewriting = e } get dnsLookupIpVersion() { return this._internals.dnsLookupIpVersion } set dnsLookupIpVersion(e) { if (e !== undefined && e !== 4 && e !== 6) { throw new TypeError(`Invalid DNS lookup IP version: ${e}`) } this._internals.dnsLookupIpVersion = e } get parseJson() { return this._internals.parseJson } set parseJson(e) { l.function_(e); this._internals.parseJson = e } get stringifyJson() { return this._internals.stringifyJson } set stringifyJson(e) { l.function_(e); this._internals.stringifyJson = e } get retry() { return this._internals.retry } set retry(e) { l.plainObject(e); l.any([f.function_, f.undefined], e.calculateDelay); l.any([f.number, f.undefined], e.maxRetryAfter); l.any([f.number, f.undefined], e.limit); l.any([f.array, f.undefined], e.methods); l.any([f.array, f.undefined], e.statusCodes); l.any([f.array, f.undefined], e.errorCodes); l.any([f.number, f.undefined], e.noise); if (e.noise && Math.abs(e.noise) > 100) { throw new Error(`The maximum acceptable retry noise is +/- 100ms, got ${e.noise}`) } for (const t in e) { if (!(t in this._internals.retry)) { throw new Error(`Unexpected retry option: ${t}`) } } if (this._merging) { Object.assign(this._internals.retry, e) } else { this._internals.retry = { ...e } } const { retry: t } = this._internals; t.methods = [...new Set(t.methods.map((e => e.toUpperCase())))]; t.statusCodes = [...new Set(t.statusCodes)]; t.errorCodes = [...new Set(t.errorCodes)] } get localAddress() { return this._internals.localAddress } set localAddress(e) { l.any([f.string, f.undefined], e); this._internals.localAddress = e } get method() { return this._internals.method } set method(e) { l.string(e); this._internals.method = e.toUpperCase() } get createConnection() { return this._internals.createConnection } set createConnection(e) { l.any([f.function_, f.undefined], e); this._internals.createConnection = e } get cacheOptions() { return this._internals.cacheOptions } set cacheOptions(e) { l.plainObject(e); l.any([f.boolean, f.undefined], e.shared); l.any([f.number, f.undefined], e.cacheHeuristic); l.any([f.number, f.undefined], e.immutableMinTimeToLive); l.any([f.boolean, f.undefined], e.ignoreCargoCult); for (const t in e) { if (!(t in this._internals.cacheOptions)) { throw new Error(`Cache option \`${t}\` does not exist`) } } if (this._merging) { Object.assign(this._internals.cacheOptions, e) } else { this._internals.cacheOptions = { ...e } } } get https() { return this._internals.https } set https(e) { l.plainObject(e); l.any([f.boolean, f.undefined], e.rejectUnauthorized); l.any([f.function_, f.undefined], e.checkServerIdentity); l.any([f.string, f.object, f.array, f.undefined], e.certificateAuthority); l.any([f.string, f.object, f.array, f.undefined], e.key); l.any([f.string, f.object, f.array, f.undefined], e.certificate); l.any([f.string, f.undefined], e.passphrase); l.any([f.string, f.buffer, f.array, f.undefined], e.pfx); l.any([f.array, f.undefined], e.alpnProtocols); l.any([f.string, f.undefined], e.ciphers); l.any([f.string, f.buffer, f.undefined], e.dhparam); l.any([f.string, f.undefined], e.signatureAlgorithms); l.any([f.string, f.undefined], e.minVersion); l.any([f.string, f.undefined], e.maxVersion); l.any([f.boolean, f.undefined], e.honorCipherOrder); l.any([f.number, f.undefined], e.tlsSessionLifetime); l.any([f.string, f.undefined], e.ecdhCurve); l.any([f.string, f.buffer, f.array, f.undefined], e.certificateRevocationLists); for (const t in e) { if (!(t in this._internals.https)) { throw new Error(`HTTPS option \`${t}\` does not exist`) } } if (this._merging) { Object.assign(this._internals.https, e) } else { this._internals.https = { ...e } } } get encoding() { return this._internals.encoding } set encoding(e) { if (e === null) { throw new TypeError("To get a Buffer, set `options.responseType` to `buffer` instead") } l.any([f.string, f.undefined], e); this._internals.encoding = e } get resolveBodyOnly() { return this._internals.resolveBodyOnly } set resolveBodyOnly(e) { l.boolean(e); this._internals.resolveBodyOnly = e } get isStream() { return this._internals.isStream } set isStream(e) { l.boolean(e); this._internals.isStream = e } get responseType() { return this._internals.responseType } set responseType(e) { if (e === undefined) { this._internals.responseType = "text"; return } if (e !== "text" && e !== "buffer" && e !== "json") { throw new Error(`Invalid \`responseType\` option: ${e}`) } this._internals.responseType = e } get pagination() { return this._internals.pagination } set pagination(e) { l.object(e); if (this._merging) { Object.assign(this._internals.pagination, e) } else { this._internals.pagination = e } } get auth() { throw new Error("Parameter `auth` is deprecated. Use `username` / `password` instead.") } set auth(e) { throw new Error("Parameter `auth` is deprecated. Use `username` / `password` instead.") } get setHost() { return this._internals.setHost } set setHost(e) { l.boolean(e); this._internals.setHost = e } get maxHeaderSize() { return this._internals.maxHeaderSize } set maxHeaderSize(e) { l.any([f.number, f.undefined], e); this._internals.maxHeaderSize = e } get enableUnixSockets() { return this._internals.enableUnixSockets } set enableUnixSockets(e) { l.boolean(e); this._internals.enableUnixSockets = e } toJSON() { return { ...this._internals } } [Symbol.for("nodejs.util.inspect.custom")](e, t) { return (0, X.inspect)(this._internals, t) } createNativeRequestOptions() { const e = this._internals; const t = e.url; let r; if (t.protocol === "https:") { r = e.http2 ? e.agent : e.agent.https } else { r = e.agent.http } const { https: n } = e; let { pfx: i } = n; if (f.array(i) && f.plainObject(i[0])) { i = i.map((e => ({ buf: e.buffer, passphrase: e.passphrase }))) } return { ...e.cacheOptions, ...this._unixOptions, ALPNProtocols: n.alpnProtocols, ca: n.certificateAuthority, cert: n.certificate, key: n.key, passphrase: n.passphrase, pfx: n.pfx, rejectUnauthorized: n.rejectUnauthorized, checkServerIdentity: n.checkServerIdentity ?? re.checkServerIdentity, ciphers: n.ciphers, honorCipherOrder: n.honorCipherOrder, minVersion: n.minVersion, maxVersion: n.maxVersion, sigalgs: n.signatureAlgorithms, sessionTimeout: n.tlsSessionLifetime, dhparam: n.dhparam, ecdhCurve: n.ecdhCurve, crl: n.certificateRevocationLists, lookup: e.dnsLookup ?? e.dnsCache?.lookup, family: e.dnsLookupIpVersion, agent: r, setHost: e.setHost, method: e.method, maxHeaderSize: e.maxHeaderSize, localAddress: e.localAddress, headers: e.headers, createConnection: e.createConnection, timeout: e.http2 ? getHttp2TimeoutOption(e) : undefined, h2session: e.h2session } } getRequestFunction() { const e = this._internals.url; const { request: t } = this._internals; if (!t && e) { return this.getFallbackRequestFunction() } return t } getFallbackRequestFunction() { const e = this._internals.url; if (!e) { return } if (e.protocol === "https:") { if (this._internals.http2) { if (ge < 15 || ge === 15 && ye < 10) { const e = new Error("To use the `http2` option, install Node.js 15.10.0 or above"); e.code = "EUNSUPPORTED"; throw e } return me.auto } return ne.request } return y.request } freeze() { const e = this._internals; Object.freeze(e); Object.freeze(e.hooks); Object.freeze(e.hooks.afterResponse); Object.freeze(e.hooks.beforeError); Object.freeze(e.hooks.beforeRedirect); Object.freeze(e.hooks.beforeRequest); Object.freeze(e.hooks.beforeRetry); Object.freeze(e.hooks.init); Object.freeze(e.https); Object.freeze(e.cacheOptions); Object.freeze(e.agent); Object.freeze(e.headers); Object.freeze(e.timeout); Object.freeze(e.retry); Object.freeze(e.retry.errorCodes); Object.freeze(e.retry.methods); Object.freeze(e.retry.statusCodes) } } const isResponseOk = e => { const { statusCode: t } = e; const r = e.request.options.followRedirect ? 299 : 399; return t >= 200 && t <= r || t === 304 }; class ParseError extends errors_RequestError { constructor(e, t) { const { options: r } = t.request; super(`${e.message} in "${r.url.toString()}"`, e, t.request); this.name = "ParseError"; this.code = "ERR_BODY_PARSE_FAILURE" } } const parseBody = (e, t, r, n) => { const { rawBody: i } = e; try { if (t === "text") { return i.toString(n) } if (t === "json") { return i.length === 0 ? "" : r(i.toString(n)) } if (t === "buffer") { return i } } catch (t) { throw new ParseError(t, e) } throw new ParseError({ message: `Unknown body type '${t}'`, name: "Error" }, e) }; function isClientRequest(e) { return e.writable && !e.writableEnded } const we = isClientRequest; function isUnixSocketURL(e) { return e.protocol === "unix:" || e.hostname === "unix" } const De = f.string(p.versions.brotli); const Ee = new Set(["GET", "HEAD"]); const Se = new WeakableMap; const Ce = new Set([300, 301, 302, 303, 304, 307, 308]); const xe = ["socket", "connect", "continue", "information", "upgrade"]; const core_noop = () => { }; class Request extends m.Duplex { constructor(e, t, r) { super({ autoDestroy: false, highWaterMark: 0 }); Object.defineProperty(this, "constructor", { enumerable: true, configurable: true, writable: true, value: void 0 }); Object.defineProperty(this, "_noPipe", { enumerable: true, configurable: true, writable: true, value: void 0 }); Object.defineProperty(this, "options", { enumerable: true, configurable: true, writable: true, value: void 0 }); Object.defineProperty(this, "response", { enumerable: true, configurable: true, writable: true, value: void 0 }); Object.defineProperty(this, "requestUrl", { enumerable: true, configurable: true, writable: true, value: void 0 }); Object.defineProperty(this, "redirectUrls", { enumerable: true, configurable: true, writable: true, value: void 0 }); Object.defineProperty(this, "retryCount", { enumerable: true, configurable: true, writable: true, value: void 0 }); Object.defineProperty(this, "_stopRetry", { enumerable: true, configurable: true, writable: true, value: void 0 }); Object.defineProperty(this, "_downloadedSize", { enumerable: true, configurable: true, writable: true, value: void 0 }); Object.defineProperty(this, "_uploadedSize", { enumerable: true, configurable: true, writable: true, value: void 0 }); Object.defineProperty(this, "_stopReading", { enumerable: true, configurable: true, writable: true, value: void 0 }); Object.defineProperty(this, "_pipedServerResponses", { enumerable: true, configurable: true, writable: true, value: void 0 }); Object.defineProperty(this, "_request", { enumerable: true, configurable: true, writable: true, value: void 0 }); Object.defineProperty(this, "_responseSize", { enumerable: true, configurable: true, writable: true, value: void 0 }); Object.defineProperty(this, "_bodySize", { enumerable: true, configurable: true, writable: true, value: void 0 }); Object.defineProperty(this, "_unproxyEvents", { enumerable: true, configurable: true, writable: true, value: void 0 }); Object.defineProperty(this, "_isFromCache", { enumerable: true, configurable: true, writable: true, value: void 0 }); Object.defineProperty(this, "_cannotHaveBody", { enumerable: true, configurable: true, writable: true, value: void 0 }); Object.defineProperty(this, "_triggerRead", { enumerable: true, configurable: true, writable: true, value: void 0 }); Object.defineProperty(this, "_cancelTimeouts", { enumerable: true, configurable: true, writable: true, value: void 0 }); Object.defineProperty(this, "_removeListeners", { enumerable: true, configurable: true, writable: true, value: void 0 }); Object.defineProperty(this, "_nativeResponse", { enumerable: true, configurable: true, writable: true, value: void 0 }); Object.defineProperty(this, "_flushed", { enumerable: true, configurable: true, writable: true, value: void 0 }); Object.defineProperty(this, "_aborted", { enumerable: true, configurable: true, writable: true, value: void 0 }); Object.defineProperty(this, "_requestInitialized", { enumerable: true, configurable: true, writable: true, value: void 0 }); this._downloadedSize = 0; this._uploadedSize = 0; this._stopReading = false; this._pipedServerResponses = new Set; this._cannotHaveBody = false; this._unproxyEvents = core_noop; this._triggerRead = false; this._cancelTimeouts = core_noop; this._removeListeners = core_noop; this._jobs = []; this._flushed = false; this._requestInitialized = false; this._aborted = false; this.redirectUrls = []; this.retryCount = 0; this._stopRetry = core_noop; this.on("pipe", (e => { if (e.headers) { Object.assign(this.options.headers, e.headers) } })); this.on("newListener", (e => { if (e === "retry" && this.listenerCount("retry") > 0) { throw new Error("A retry listener has been attached already.") } })); try { this.options = new Options(e, t, r); if (!this.options.url) { if (this.options.prefixUrl === "") { throw new TypeError("Missing `url` property") } this.options.url = "" } this.requestUrl = this.options.url } catch (e) { const { options: t } = e; if (t) { this.options = t } this.flush = async () => { this.flush = async () => { }; this.destroy(e) }; return } const { body: n } = this.options; if (f.nodeStream(n)) { n.once("error", (e => { if (this._flushed) { this._beforeError(new UploadError(e, this)) } else { this.flush = async () => { this.flush = async () => { }; this._beforeError(new UploadError(e, this)) } } })) } if (this.options.signal) { const abort = () => { this.destroy(new AbortError(this)) }; if (this.options.signal.aborted) { abort() } else { this.options.signal.addEventListener("abort", abort); this._removeListeners = () => { this.options.signal.removeEventListener("abort", abort) } } } } async flush() { if (this._flushed) { return } this._flushed = true; try { await this._finalizeBody(); if (this.destroyed) { return } await this._makeRequest(); if (this.destroyed) { this._request?.destroy(); return } for (const e of this._jobs) { e() } this._jobs.length = 0; this._requestInitialized = true } catch (e) { this._beforeError(e) } } _beforeError(e) { if (this._stopReading) { return } const { response: t, options: r } = this; const n = this.retryCount + (e.name === "RetryError" ? 0 : 1); this._stopReading = true; if (!(e instanceof errors_RequestError)) { e = new errors_RequestError(e.message, e, this) } const i = e; void (async () => { if (t?.readable && !t.rawBody && !this._request?.socket?.destroyed) { t.setEncoding(this.readableEncoding); const e = await this._setRawBody(t); if (e) { t.body = t.rawBody.toString() } } if (this.listenerCount("retry") !== 0) { let s; try { let e; if (t && "retry-after" in t.headers) { e = Number(t.headers["retry-after"]); if (Number.isNaN(e)) { e = Date.parse(t.headers["retry-after"]) - Date.now(); if (e <= 0) { e = 1 } } else { e *= 1e3 } } const o = r.retry; s = await o.calculateDelay({ attemptCount: n, retryOptions: o, error: i, retryAfter: e, computedValue: te({ attemptCount: n, retryOptions: o, error: i, retryAfter: e, computedValue: o.maxRetryAfter ?? r.timeout.request ?? Number.POSITIVE_INFINITY }) }) } catch (e) { void this._error(new errors_RequestError(e.message, e, this)); return } if (s) { await new Promise((e => { const t = setTimeout(e, s); this._stopRetry = () => { clearTimeout(t); e() } })); if (this.destroyed) { return } try { for (const e of this.options.hooks.beforeRetry) { await e(i, this.retryCount + 1) } } catch (t) { void this._error(new errors_RequestError(t.message, e, this)); return } if (this.destroyed) { return } this.destroy(); this.emit("retry", this.retryCount + 1, e, (e => { const t = new Request(r.url, e, r); t.retryCount = this.retryCount + 1; p.nextTick((() => { void t.flush() })); return t })); return } } void this._error(i) })() } _read() { this._triggerRead = true; const { response: e } = this; if (e && !this._stopReading) { if (e.readableLength) { this._triggerRead = false } let t; while ((t = e.read()) !== null) { this._downloadedSize += t.length; const e = this.downloadProgress; if (e.percent < 1) { this.emit("downloadProgress", e) } this.push(t) } } } _write(e, t, r) { const write = () => { this._writeRequest(e, t, r) }; if (this._requestInitialized) { write() } else { this._jobs.push(write) } } _final(e) { const endRequest = () => { if (!this._request || this._request.destroyed) { e(); return } this._request.end((t => { if (this._request._writableState?.errored) { return } if (!t) { this._bodySize = this._uploadedSize; this.emit("uploadProgress", this.uploadProgress); this._request.emit("upload-complete") } e(t) })) }; if (this._requestInitialized) { endRequest() } else { this._jobs.push(endRequest) } } _destroy(e, t) { this._stopReading = true; this.flush = async () => { }; this._stopRetry(); this._cancelTimeouts(); this._removeListeners(); if (this.options) { const { body: e } = this.options; if (f.nodeStream(e)) { e.destroy() } } if (this._request) { this._request.destroy() } if (e !== null && !f.undefined(e) && !(e instanceof errors_RequestError)) { e = new errors_RequestError(e.message, e, this) } t(e) } pipe(e, t) { if (e instanceof y.ServerResponse) { this._pipedServerResponses.add(e) } return super.pipe(e, t) } unpipe(e) { if (e instanceof y.ServerResponse) { this._pipedServerResponses.delete(e) } super.unpipe(e); return this } async _finalizeBody() { const { options: e } = this; const { headers: t } = e; const r = !f.undefined(e.form); const n = !f.undefined(e.json); const i = !f.undefined(e.body); const s = Ee.has(e.method) && !(e.method === "GET" && e.allowGetBody); this._cannotHaveBody = s; if (r || n || i) { if (s) { throw new TypeError(`The \`${e.method}\` method cannot be used with a body`) } const n = !f.string(t["content-type"]); if (i) { if (isFormData(e.body)) { const r = new FormDataEncoder(e.body); if (n) { t["content-type"] = r.headers["Content-Type"] } if ("Content-Length" in r.headers) { t["content-length"] = r.headers["Content-Length"] } e.body = r.encode() } if (is_form_data_isFormData(e.body) && n) { t["content-type"] = `multipart/form-data; boundary=${e.body.getBoundary()}` } } else if (r) { if (n) { t["content-type"] = "application/x-www-form-urlencoded" } const { form: r } = e; e.form = undefined; e.body = new g.URLSearchParams(r).toString() } else { if (n) { t["content-type"] = "application/json" } const { json: r } = e; e.json = undefined; e.body = e.stringifyJson(r) } const o = await getBodySize(e.body, e.headers); if (f.undefined(t["content-length"]) && f.undefined(t["transfer-encoding"]) && !s && !f.undefined(o)) { t["content-length"] = String(o) } } if (e.responseType === "json" && !("accept" in e.headers)) { e.headers.accept = "application/json" } this._bodySize = Number(t["content-length"]) || undefined } async _onResponseBase(e) { if (this.isAborted) { return } const { options: t } = this; const { url: r } = t; this._nativeResponse = e; if (t.decompress) { e = F(e) } const n = e.statusCode; const i = e; i.statusMessage = i.statusMessage ?? y.STATUS_CODES[n]; i.url = t.url.toString(); i.requestUrl = this.requestUrl; i.redirectUrls = this.redirectUrls; i.request = this; i.isFromCache = this._nativeResponse.fromCache ?? false; i.ip = this.ip; i.retryCount = this.retryCount; i.ok = isResponseOk(i); this._isFromCache = i.isFromCache; this._responseSize = Number(e.headers["content-length"]) || undefined; this.response = i; e.once("end", (() => { this._responseSize = this._downloadedSize; this.emit("downloadProgress", this.downloadProgress) })); e.once("error", (t => { this._aborted = true; e.destroy(); this._beforeError(new ReadError(t, this)) })); e.once("aborted", (() => { this._aborted = true; this._beforeError(new ReadError({ name: "Error", message: "The server aborted pending request", code: "ECONNRESET" }, this)) })); this.emit("downloadProgress", this.downloadProgress); const s = e.headers["set-cookie"]; if (f.object(t.cookieJar) && s) { let e = s.map((async e => t.cookieJar.setCookie(e, r.toString()))); if (t.ignoreInvalidCookies) { e = e.map((async e => { try { await e } catch { } })) } try { await Promise.all(e) } catch (e) { this._beforeError(e); return } } if (this.isAborted) { return } if (t.followRedirect && e.headers.location && Ce.has(n)) { e.resume(); this._cancelTimeouts(); this._unproxyEvents(); if (this.redirectUrls.length >= t.maxRedirects) { this._beforeError(new MaxRedirectsError(this)); return } this._request = undefined; const s = new Options(undefined, undefined, this.options); const o = n === 303 && s.method !== "GET" && s.method !== "HEAD"; const a = n !== 307 && n !== 308; const u = s.methodRewriting && a; if (o || u) { s.method = "GET"; s.body = undefined; s.json = undefined; s.form = undefined; delete s.headers["content-length"] } try { const t = h.Buffer.from(e.headers.location, "binary").toString(); const n = new g.URL(t, r); if (!isUnixSocketURL(r) && isUnixSocketURL(n)) { this._beforeError(new errors_RequestError("Cannot redirect to UNIX socket", {}, this)); return } if (n.hostname !== r.hostname || n.port !== r.port) { if ("host" in s.headers) { delete s.headers.host } if ("cookie" in s.headers) { delete s.headers.cookie } if ("authorization" in s.headers) { delete s.headers.authorization } if (s.username || s.password) { s.username = ""; s.password = "" } } else { n.username = s.username; n.password = s.password } this.redirectUrls.push(n); s.prefixUrl = ""; s.url = n; for (const e of s.hooks.beforeRedirect) { await e(s, i) } this.emit("redirect", s, i); this.options = s; await this._makeRequest() } catch (e) { this._beforeError(e); return } return } if (t.isStream && t.throwHttpErrors && !isResponseOk(i)) { this._beforeError(new HTTPError(i)); return } e.on("readable", (() => { if (this._triggerRead) { this._read() } })); this.on("resume", (() => { e.resume() })); this.on("pause", (() => { e.pause() })); e.once("end", (() => { this.push(null) })); if (this._noPipe) { const t = await this._setRawBody(); if (t) { this.emit("response", e) } return } this.emit("response", e); for (const r of this._pipedServerResponses) { if (r.headersSent) { continue } for (const n in e.headers) { const i = t.decompress ? n !== "content-encoding" : true; const s = e.headers[n]; if (i) { r.setHeader(n, s) } } r.statusCode = n } } async _setRawBody(e = this) { if (e.readableEnded) { return false } try { const t = await (0, x.buffer)(e); if (!this.isAborted) { this.response.rawBody = t; return true } } catch { } return false } async _onResponse(e) { try { await this._onResponseBase(e) } catch (e) { this._beforeError(e) } } _onRequest(e) { const { options: t } = this; const { timeout: r, url: n } = t; w(e); if (this.options.http2) { e.setTimeout(0) } this._cancelTimeouts = timedOut(e, r, n); const i = t.cache ? "cacheableResponse" : "response"; e.once(i, (e => { void this._onResponse(e) })); e.once("error", (t => { this._aborted = true; e.destroy(); t = t instanceof timed_out_TimeoutError ? new TimeoutError(t, this.timings, this) : new errors_RequestError(t.message, t, this); this._beforeError(t) })); this._unproxyEvents = proxyEvents(e, this, xe); this._request = e; this.emit("uploadProgress", this.uploadProgress); this._sendBody(); this.emit("request", e) } async _asyncWrite(e) { return new Promise(((t, r) => { super.write(e, (e => { if (e) { r(e); return } t() })) })) } _sendBody() { const { body: e } = this.options; const t = this.redirectUrls.length === 0 ? this : this._request ?? this; if (f.nodeStream(e)) { e.pipe(t) } else if (f.generator(e) || f.asyncGenerator(e)) { (async () => { try { for await (const t of e) { await this._asyncWrite(t) } super.end() } catch (e) { this._beforeError(e) } })() } else if (!f.undefined(e)) { this._writeRequest(e, undefined, (() => { })); t.end() } else if (this._cannotHaveBody || this._noPipe) { t.end() } } _prepareCache(e) { if (!Se.has(e)) { const t = new O(((e, t) => { const r = e._request(e, t); if (f.promise(r)) { r.once = (e, t) => { if (e === "error") { (async () => { try { await r } catch (e) { t(e) } })() } else if (e === "abort") { (async () => { try { const e = await r; e.once("abort", t) } catch { } })() } else { throw new Error(`Unknown HTTP2 promise event: ${e}`) } return r } } return r }), e); Se.set(e, t.request()) } } async _createCacheableRequest(e, t) { return new Promise(((r, n) => { Object.assign(t, urlToOptions(e)); let i; const s = Se.get(t.cache)(t, (async e => { e._readableState.autoDestroy = false; if (i) { const fix = () => { if (e.req) { e.complete = e.req.res.complete } }; e.prependOnceListener("end", fix); fix(); (await i).emit("cacheableResponse", e) } r(e) })); s.once("error", n); s.once("request", (async e => { i = e; r(i) })) })) } async _makeRequest() { const { options: e } = this; const { headers: t, username: r, password: n } = e; const i = e.cookieJar; for (const e in t) { if (f.undefined(t[e])) { delete t[e] } else if (f.null_(t[e])) { throw new TypeError(`Use \`undefined\` instead of \`null\` to delete the \`${e}\` header`) } } if (e.decompress && f.undefined(t["accept-encoding"])) { t["accept-encoding"] = De ? "gzip, deflate, br" : "gzip, deflate" } if (r || n) { const e = h.Buffer.from(`${r}:${n}`).toString("base64"); t.authorization = `Basic ${e}` } if (i) { const r = await i.getCookieString(e.url.toString()); if (f.nonEmptyString(r)) { t.cookie = r } } e.prefixUrl = ""; let s; for (const t of e.hooks.beforeRequest) { const r = await t(e); if (!f.undefined(r)) { s = () => r; break } } if (!s) { s = e.getRequestFunction() } const o = e.url; this._requestOptions = e.createNativeRequestOptions(); if (e.cache) { this._requestOptions._request = s; this._requestOptions.cache = e.cache; this._requestOptions.body = e.body; this._prepareCache(e.cache) } const a = e.cache ? this._createCacheableRequest : s; try { let t = a(o, this._requestOptions); if (f.promise(t)) { t = await t } if (f.undefined(t)) { t = e.getFallbackRequestFunction()(o, this._requestOptions); if (f.promise(t)) { t = await t } } if (we(t)) { this._onRequest(t) } else if (this.writable) { this.once("finish", (() => { void this._onResponse(t) })); this._sendBody() } else { void this._onResponse(t) } } catch (e) { if (e instanceof types_CacheError) { throw new CacheError(e, this) } throw e } } async _error(e) { try { if (e instanceof HTTPError && !this.options.throwHttpErrors) { } else { for (const t of this.options.hooks.beforeError) { e = await t(e) } } } catch (t) { e = new errors_RequestError(t.message, t, this) } this.destroy(e) } _writeRequest(e, t, r) { if (!this._request || this._request.destroyed) { return } this._request.write(e, t, (n => { if (!n && !this._request.destroyed) { this._uploadedSize += h.Buffer.byteLength(e, t); const r = this.uploadProgress; if (r.percent < 1) { this.emit("uploadProgress", r) } } r(n) })) } get ip() { return this.socket?.remoteAddress } get isAborted() { return this._aborted } get socket() { return this._request?.socket ?? undefined } get downloadProgress() { let e; if (this._responseSize) { e = this._downloadedSize / this._responseSize } else if (this._responseSize === this._downloadedSize) { e = 1 } else { e = 0 } return { percent: e, transferred: this._downloadedSize, total: this._responseSize } } get uploadProgress() { let e; if (this._bodySize) { e = this._uploadedSize / this._bodySize } else if (this._bodySize === this._uploadedSize) { e = 1 } else { e = 0 } return { percent: e, transferred: this._uploadedSize, total: this._bodySize } } get timings() { return this._request?.timings } get isFromCache() { return this._isFromCache } get reusedSocket() { return this._request?.reusedSocket } } class types_CancelError extends errors_RequestError { constructor(e) { super("Promise was canceled", {}, e); this.name = "CancelError"; this.code = "ERR_CANCELED" } get isCanceled() { return true } } const Ae = ["request", "response", "redirect", "uploadProgress", "downloadProgress"]; function asPromise(e) { let t; let r; let n; const i = new d.EventEmitter; const s = new PCancelable(((o, a, u) => { u((() => { t.destroy() })); u.shouldReject = false; u((() => { a(new types_CancelError(t)) })); const makeRequest = l => { u((() => { })); const d = e ?? new Request(undefined, undefined, n); d.retryCount = l; d._noPipe = true; t = d; d.once("response", (async e => { const t = (e.headers["content-encoding"] ?? "").toLowerCase(); const n = t === "gzip" || t === "deflate" || t === "br"; const { options: i } = d; if (n && !i.decompress) { e.body = e.rawBody } else { try { e.body = parseBody(e, i.responseType, i.parseJson, i.encoding) } catch (t) { e.body = e.rawBody.toString(); if (isResponseOk(e)) { d._beforeError(t); return } } } try { const t = i.hooks.afterResponse; for (const [r, n] of t.entries()) { e = await n(e, (async e => { i.merge(e); i.prefixUrl = ""; if (e.url) { i.url = e.url } i.hooks.afterResponse = i.hooks.afterResponse.slice(0, r); throw new RetryError(d) })); if (!(f.object(e) && f.number(e.statusCode) && !f.nullOrUndefined(e.body))) { throw new TypeError("The `afterResponse` hook returned an invalid value") } } } catch (e) { d._beforeError(e); return } r = e; if (!isResponseOk(e)) { d._beforeError(new HTTPError(e)); return } d.destroy(); o(d.options.resolveBodyOnly ? e.body : e) })); const onError = e => { if (s.isCanceled) { return } const { options: t } = d; if (e instanceof HTTPError && !t.throwHttpErrors) { const { response: t } = e; d.destroy(); o(d.options.resolveBodyOnly ? t.body : t); return } a(e) }; d.once("error", onError); const p = d.options?.body; d.once("retry", ((t, r) => { e = undefined; const i = d.options.body; if (p === i && f.nodeStream(i)) { r.message = "Cannot retry with consumed body stream"; onError(r); return } n = d.options; makeRequest(t) })); proxyEvents(d, i, Ae); if (f.undefined(e)) { void d.flush() } }; makeRequest(0) })); s.on = (e, t) => { i.on(e, t); return s }; s.off = (e, t) => { i.off(e, t); return s }; const shortcut = e => { const t = (async () => { await s; const { options: t } = r.request; return parseBody(r, e, t.parseJson, t.encoding) })(); Object.defineProperties(t, Object.getOwnPropertyDescriptors(s)); return t }; s.json = () => { if (t.options) { const { headers: e } = t.options; if (!t.writableFinished && !("accept" in e)) { e.accept = "application/json" } } return shortcut("json") }; s.buffer = () => shortcut("buffer"); s.text = () => shortcut("text"); return s } const delay = async e => new Promise((t => { setTimeout(t, e) })); const isGotInstance = e => f.function_(e); const Pe = ["get", "post", "put", "patch", "head", "delete"]; const create = e => { e = { options: new Options(undefined, undefined, e.options), handlers: [...e.handlers], mutableDefaults: e.mutableDefaults }; Object.defineProperty(e, "mutableDefaults", { enumerable: true, configurable: false, writable: false }); const got = (t, r, n = e.options) => { const i = new Request(t, r, n); let s; const lastHandler = e => { i.options = e; i._noPipe = !e.isStream; void i.flush(); if (e.isStream) { return i } if (!s) { s = asPromise(i) } return s }; let o = 0; const iterateHandlers = t => { const r = e.handlers[o++] ?? lastHandler; const n = r(t, iterateHandlers); if (f.promise(n) && !i.options.isStream) { if (!s) { s = asPromise(i) } if (n !== s) { const e = Object.getOwnPropertyDescriptors(s); for (const t in e) { if (t in n) { delete e[t] } } Object.defineProperties(n, e); n.cancel = s.cancel } } return n }; return iterateHandlers(i.options) }; got.extend = (...t) => { const r = new Options(undefined, undefined, e.options); const n = [...e.handlers]; let i; for (const e of t) { if (isGotInstance(e)) { r.merge(e.defaults.options); n.push(...e.defaults.handlers); i = e.defaults.mutableDefaults } else { r.merge(e); if (e.handlers) { n.push(...e.handlers) } i = e.mutableDefaults } } return create({ options: r, handlers: n, mutableDefaults: Boolean(i) }) }; const paginateEach = async function* (t, r) { let n = new Options(t, r, e.options); n.resolveBodyOnly = false; const { pagination: i } = n; l.function_(i.transform); l.function_(i.shouldContinue); l.function_(i.filter); l.function_(i.paginate); l.number(i.countLimit); l.number(i.requestLimit); l.number(i.backoff); const s = []; let { countLimit: o } = i; let a = 0; while (a < i.requestLimit) { if (a !== 0) { await delay(i.backoff) } const e = await got(undefined, undefined, n); const t = await i.transform(e); const r = []; l.array(t); for (const e of t) { if (i.filter({ item: e, currentItems: r, allItems: s })) { if (!i.shouldContinue({ item: e, currentItems: r, allItems: s })) { return } yield e; if (i.stackAllItems) { s.push(e) } r.push(e); if (--o <= 0) { return } } } const u = i.paginate({ response: e, currentItems: r, allItems: s }); if (u === false) { return } if (u === e.request.options) { n = e.request.options } else { n.merge(u); l.any([f.urlInstance, f.undefined], u.url); if (u.url !== undefined) { n.prefixUrl = ""; n.url = u.url } } a++ } }; got.paginate = paginateEach; got.paginate.all = async (e, t) => { const r = []; for await (const n of paginateEach(e, t)) { r.push(n) } return r }; got.paginate.each = paginateEach; got.stream = (e, t) => got(e, { ...t, isStream: true }); for (const e of Pe) { got[e] = (t, r) => got(t, { ...r, method: e }); got.stream[e] = (t, r) => got(t, { ...r, method: e, isStream: true }) } if (!e.mutableDefaults) { Object.freeze(e.handlers); e.options.freeze() } Object.defineProperty(got, "defaults", { value: e, writable: false, configurable: false, enumerable: true }); return got }; const Re = create; const ke = { options: new Options, handlers: [], mutableDefaults: false }; const Oe = Re(ke); const Te = Oe; var Fe = __nccwpck_require__(5382); class p_throttle_AbortError extends Error { constructor() { super("Throttled function aborted"); this.name = "AbortError" } } function pThrottle({ limit: e, interval: t, strict: r }) { if (!Number.isFinite(e)) { throw new TypeError("Expected `limit` to be a finite number") } if (!Number.isFinite(t)) { throw new TypeError("Expected `interval` to be a finite number") } const n = new Map; let i = 0; let s = 0; function windowedDelay() { const r = Date.now(); if (r - i > t) { s = 1; i = r; return 0 } if (s < e) { s++ } else { i += t; s = 1 } return i - r } const o = []; function strictDelay() { const r = Date.now(); if (o.length < e) { o.push(r); return 0 } const n = o.shift() + t; if (r >= n) { o.push(r); return 0 } o.push(n); return n - r } const a = r ? strictDelay : windowedDelay; return e => { const throttled = function (...t) { if (!throttled.isEnabled) { return (async () => e.apply(this, t))() } let r; return new Promise(((i, s) => { const execute = () => { i(e.apply(this, t)); n.delete(r) }; r = setTimeout(execute, a()); n.set(r, s) })) }; throttled.abort = () => { for (const e of n.keys()) { clearTimeout(e); n.get(e)(new p_throttle_AbortError) } n.clear(); o.splice(0, o.length) }; throttled.isEnabled = true; return throttled } } const je = t("devto"); const Le = "https://dev.to/api"; const Ie = 1e3; const Be = pThrottle({ limit: 10, interval: 30500 })(Te.post); async function api_getAllArticles(e) { try { const t = []; let r = 1; const getPage = async t => Te(`${Le}/articles/me/all`, { searchParams: { per_page: Ie, page: t }, headers: { "api-key": e }, responseType: "json" }); let n; do { je("Requesting articles (page %s)", r); const e = await getPage(r++); n = e.body; t.push(...n) } while (n.length === Ie); je("Found %s remote article(s)", t.length); return t } catch (e) { if (e instanceof errors_RequestError && e?.response) { je("Debug infos: %O", e.response.body) } throw e } } async function api_getLastArticlesStats(e, t) { try { const r = await got(`${Le}/articles/me`, { searchParams: { per_page: t || 10 }, headers: { "api-key": e }, responseType: "json" }); return r.body.map((e => ({ date: e.published_at, title: e.title, views: e.page_views_count, reactions: e.positive_reactions_count, comments: e.comments_count }))) } catch (e) { if (e instanceof RequestError && e.response) { je("Debug infos: %O", e.response.body) } throw e } } async function updateRemoteArticle(e, t) { try { const r = Fe.stringify(e, e.data, { lineWidth: -1 }); const { id: n } = e.data; const i = n ? Te.put : Be; const s = await i(`${Le}/articles${n ? `/${n}` : ""}`, { headers: { "api-key": t }, json: { article: { title: e.data.title, body_markdown: r } }, responseType: "json" }); return s.body } catch (e) { if (e instanceof errors_RequestError && e.response) { je("Debug infos: %O", e.response.body) } throw e } } const Ne = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("path"); var Me = __nccwpck_require__(5630); const $e = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("fs"); var He = __nccwpck_require__(2578); var qe = __nccwpck_require__(3664); var Ue = __nccwpck_require__(2738); var We = __nccwpck_require__(4777); function slash(e) { const t = /^\\\\\?\\/.test(e); const r = /[^\u0000-\u0080]+/.test(e); if (t || r) { return e } return e.replace(/\\/g, "/") } const toPath = e => e instanceof URL ? (0, g.fileURLToPath)(e) : e; class FilterStream extends m.Transform { constructor(e) { super({ objectMode: true, transform(t, r, n) { n(undefined, e(t) ? t : undefined) } }) } } const isNegativePattern = e => e[0] === "!"; const Ge = { ignore: ["**/node_modules", "**/flow-typed", "**/coverage", "**/.git"], absolute: true, dot: true }; const ze = "**/.gitignore"; const applyBaseToPattern = (e, t) => isNegativePattern(e) ? "!" + Ne.posix.join(t, e.slice(1)) : Ne.posix.join(t, e); const parseIgnoreFile = (e, t) => { const r = slash(Ne.relative(t, Ne.dirname(e.filePath))); return e.content.split(/\r?\n/).filter((e => e && !e.startsWith("#"))).map((e => applyBaseToPattern(e, r))) }; const toRelativePath = (e, t) => { t = slash(t); if (Ne.isAbsolute(e)) { if (slash(e).startsWith(t)) { return Ne.relative(t, e) } throw new Error(`Path ${e} is not in cwd ${t}`) } return e }; const getIsIgnoredPredicate = (e, t) => { const r = e.flatMap((e => parseIgnoreFile(e, t))); const n = We().add(r); return e => { e = toPath(e); e = toRelativePath(e, t); return e ? n.ignores(slash(e)) : false } }; const normalizeOptions = (e = {}) => ({ cwd: toPath(e.cwd) || p.cwd() }); const isIgnoredByIgnoreFiles = async (e, t) => { const { cwd: r } = normalizeOptions(t); const n = await qe(e, { cwd: r, ...Ge }); const i = await Promise.all(n.map((async e => ({ filePath: e, content: await $e.promises.readFile(e, "utf8") })))); return getIsIgnoredPredicate(i, r) }; const isIgnoredByIgnoreFilesSync = (e, t) => { const { cwd: r } = normalizeOptions(t); const n = qe.sync(e, { cwd: r, ...Ge }); const i = n.map((e => ({ filePath: e, content: $e.readFileSync(e, "utf8") }))); return getIsIgnoredPredicate(i, r) }; const isGitIgnored = e => isIgnoredByIgnoreFiles(ze, e); const isGitIgnoredSync = e => isIgnoredByIgnoreFilesSync(ze, e); const assertPatternsInput = e => { if (e.some((e => typeof e !== "string"))) { throw new TypeError("Patterns must be a string or an array of strings") } }; const toPatternsArray = e => { e = [...new Set([e].flat())]; assertPatternsInput(e); return e }; const checkCwdOption = e => { if (!e.cwd) { return } let t; try { t = $e.statSync(e.cwd) } catch { return } if (!t.isDirectory()) { throw new Error("The `cwd` option must be a path to a directory") } }; const globby_normalizeOptions = (e = {}) => { e = { ignore: [], expandDirectories: true, ...e, cwd: toPath(e.cwd) }; checkCwdOption(e); return e }; const normalizeArguments = e => async (t, r) => e(toPatternsArray(t), globby_normalizeOptions(r)); const normalizeArgumentsSync = e => (t, r) => e(toPatternsArray(t), globby_normalizeOptions(r)); const getIgnoreFilesPatterns = e => { const { ignoreFiles: t, gitignore: r } = e; const n = t ? toPatternsArray(t) : []; if (r) { n.push(ze) } return n }; const getFilter = async e => { const t = getIgnoreFilesPatterns(e); return createFilterFunction(t.length > 0 && await isIgnoredByIgnoreFiles(t, { cwd: e.cwd })) }; const getFilterSync = e => { const t = getIgnoreFilesPatterns(e); return createFilterFunction(t.length > 0 && isIgnoredByIgnoreFilesSync(t, { cwd: e.cwd })) }; const createFilterFunction = e => { const t = new Set; return r => { const n = r.path || r; const i = Ne.normalize(n); const s = t.has(i) || e && e(n); t.add(i); return !s } }; const unionFastGlobResults = (e, t) => e.flat().filter((e => t(e))); const unionFastGlobStreams = (e, t) => He(e).pipe(new FilterStream((e => t(e)))); const convertNegativePatterns = (e, t) => { const r = []; while (e.length > 0) { const n = e.findIndex((e => isNegativePattern(e))); if (n === -1) { r.push({ patterns: e, options: t }); break } const i = e[n].slice(1); for (const e of r) { e.options.ignore.push(i) } if (n !== 0) { r.push({ patterns: e.slice(0, n), options: { ...t, ignore: [...t.ignore, i] } }) } e = e.slice(n + 1) } return r }; const getDirGlobOptions = (e, t) => ({ ...t ? { cwd: t } : {}, ...Array.isArray(e) ? { files: e } : e }); const generateTasks = async (e, t) => { const r = convertNegativePatterns(e, t); const { cwd: n, expandDirectories: i } = t; if (!i) { return r } const s = getDirGlobOptions(i, n); const o = n ? { cwd: n } : undefined; return Promise.all(r.map((async e => { let { patterns: t, options: r } = e;[t, r.ignore] = await Promise.all([Ue(t, s), Ue(r.ignore, o)]); return { patterns: t, options: r } }))) }; const generateTasksSync = (e, t) => { const r = convertNegativePatterns(e, t); const { cwd: n, expandDirectories: i } = t; if (!i) { return r } const s = getDirGlobOptions(i, n); const o = n ? { cwd: n } : undefined; return r.map((e => { let { patterns: t, options: r } = e; t = Ue.sync(t, s); r.ignore = Ue.sync(r.ignore, o); return { patterns: t, options: r } })) }; const Ve = normalizeArguments((async (e, t) => { const [r, n] = await Promise.all([generateTasks(e, t), getFilter(t)]); const i = await Promise.all(r.map((e => qe(e.patterns, e.options)))); return unionFastGlobResults(i, n) })); const Ke = normalizeArgumentsSync(((e, t) => { const r = generateTasksSync(e, t); const n = getFilterSync(t); const i = r.map((e => qe.sync(e.patterns, e.options))); return unionFastGlobResults(i, n) })); const Je = normalizeArgumentsSync(((e, t) => { const r = generateTasksSync(e, t); const n = getFilterSync(t); const i = r.map((e => qe.stream(e.patterns, e.options))); return unionFastGlobStreams(i, n) })); const Ye = normalizeArgumentsSync(((e, t) => e.some((e => qe.isDynamicPattern(e, t))))); const Qe = normalizeArguments(generateTasks); const Xe = normalizeArgumentsSync(generateTasksSync); var Ze = __nccwpck_require__(9481); function indentString(e, t = 1, r = {}) { const { indent: n = " ", includeEmptyLines: i = false } = r; if (typeof e !== "string") { throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof e}\``) } if (typeof t !== "number") { throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof t}\``) } if (t < 0) { throw new RangeError(`Expected \`count\` to be at least 0, got \`${t}\``) } if (typeof n !== "string") { throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof n}\``) } if (t === 0) { return e } const s = i ? /^/gm : /^(?!\s*$)/gm; return e.replace(s, n.repeat(t)) } var et = __nccwpck_require__(2037); function escapeStringRegexp(e) { if (typeof e !== "string") { throw new TypeError("Expected a string") } return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d") } const tt = /\s+at.*[(\s](.*)\)?/; const rt = /^(?:(?:(?:node|node:[\w/]+|(?:(?:node:)?internal\/[\w/]*|.*node_modules\/(?:babel-polyfill|pirates)\/.*)?\w+)(?:\.js)?:\d+:\d+)|native)/; const nt = typeof et.homedir === "undefined" ? "" : et.homedir().replace(/\\/g, "/"); function cleanStack(e, { pretty: t = false, basePath: r } = {}) { const n = r && new RegExp(`(at | \\()${escapeStringRegexp(r.replace(/\\/g, "/"))}`, "g"); if (typeof e !== "string") { return undefined } return e.replace(/\\/g, "/").split("\n").filter((e => { const t = e.match(tt); if (t === null || !t[1]) { return true } const r = t[1]; if (r.includes(".app/Contents/Resources/electron.asar") || r.includes(".app/Contents/Resources/default_app.asar") || r.includes("node_modules/electron/dist/resources/electron.asar") || r.includes("node_modules/electron/dist/resources/default_app.asar")) { return false } return !rt.test(r) })).filter((e => e.trim() !== "")).map((e => { if (n) { e = e.replace(n, "$1") } if (t) { e = e.replace(tt, ((e, t) => e.replace(t, t.replace(nt, "~")))) } return e })).join("\n") } const cleanInternalStack = e => e.replace(/\s+at .*aggregate-error\/index.js:\d+:\d+\)?/g, ""); class AggregateError extends Error { #e; name = "AggregateError"; constructor(e) { if (!Array.isArray(e)) { throw new TypeError(`Expected input to be an Array, got ${typeof e}`) } e = e.map((e => { if (e instanceof Error) { return e } if (e !== null && typeof e === "object") { return Object.assign(new Error(e.message), e) } return new Error(e) })); let t = e.map((e => typeof e.stack === "string" && e.stack.length > 0 ? cleanInternalStack(cleanStack(e.stack)) : String(e))).join("\n"); t = "\n" + indentString(t, 4); super(t); this.#e = e } get errors() { return this.#e.slice() } } class p_map_AbortError extends Error { constructor(e) { super(); this.name = "AbortError"; this.message = e } } const getDOMException = e => globalThis.DOMException === undefined ? new p_map_AbortError(e) : new DOMException(e); const getAbortedReason = e => { const t = e.reason === undefined ? getDOMException("This operation was aborted.") : e.reason; return t instanceof Error ? t : getDOMException(t) }; async function pMap(e, t, { concurrency: r = Number.POSITIVE_INFINITY, stopOnError: n = true, signal: i } = {}) { return new Promise(((s, o) => { if (e[Symbol.iterator] === undefined && e[Symbol.asyncIterator] === undefined) { throw new TypeError(`Expected \`input\` to be either an \`Iterable\` or \`AsyncIterable\`, got (${typeof e})`) } if (typeof t !== "function") { throw new TypeError("Mapper function is required") } if (!((Number.isSafeInteger(r) || r === Number.POSITIVE_INFINITY) && r >= 1)) { throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${r}\` (${typeof r})`) } const a = []; const u = []; const l = new Map; let f = false; let d = false; let p = false; let h = 0; let m = 0; const g = e[Symbol.iterator] === undefined ? e[Symbol.asyncIterator]() : e[Symbol.iterator](); const reject = e => { f = true; d = true; o(e) }; if (i) { if (i.aborted) { reject(getAbortedReason(i)) } i.addEventListener("abort", (() => { reject(getAbortedReason(i)) })) } const next = async () => { if (d) { return } const e = await g.next(); const r = m; m++; if (e.done) { p = true; if (h === 0 && !d) { if (!n && u.length > 0) { reject(new AggregateError(u)); return } d = true; if (l.size === 0) { s(a); return } const e = []; for (const [t, r] of a.entries()) { if (l.get(t) === it) { continue } e.push(r) } s(e) } return } h++; (async () => { try { const n = await e.value; if (d) { return } const i = await t(n, r); if (i === it) { l.set(r, i) } a[r] = i; h--; await next() } catch (e) { if (n) { reject(e) } else { u.push(e); h--; try { await next() } catch (e) { reject(e) } } } })() }; (async () => { for (let e = 0; e < r; e++) { try { await next() } catch (e) { reject(e); break } if (p || f) { break } } })() })) } const it = Symbol("skip"); const st = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("readline"); const ot = "https://raw.githubusercontent.com"; const at = /!\[(.*)]\((?!.*?:\/\/)([^ ]*?) *?( (?:'.*'|".*"))? *?\)/g; const ut = /!\[(.*)]\(([^ ]*?) *?( (?:'.*'|".*"))? *?\)/g; const convertPathToPosix = e => e.replace(/\\/g, "/"); const isUrl = e => /^https?:\/\/\w/.test(e); const getResourceUrl = (e, t) => `${ot}/${e.user}/${e.name}/${t}/`; const getFullImagePath = (e, t) => convertPathToPosix(Ne.normalize(Ne.join(e, t))); function updateRelativeImageUrls(e, t, r) { const n = { ...e.data }; let { content: i } = e; const s = Ne.dirname(e.file); let o; while (o = at.exec(e.content)) { const [e, n = "", a, u = ""] = o; if (a) { const o = getFullImagePath(s, a); const l = `![${n}](${getResourceUrl(t, r)}${o}${u})`; i = i.replace(e, l) } } if (n.cover_image && !isUrl(n.cover_image)) { const e = getFullImagePath(s, n.cover_image); n.cover_image = `${getResourceUrl(t, r)}${e}` } return { ...e, content: i, data: n } } function getImageUrls(e) { const t = []; let r; while (r = ut.exec(e.content)) { const e = r[2]; if (e) { t.push(e) } } if (e.data.cover_image) { t.push(e.data.cover_image) } return t } function util_scaleNumber(e, t = 5) { const r = ["", "K", "M", "G", "T", "P"]; const n = 1e3; let i = 0; let s = ""; while (e >= n) { e /= n; i++ } t -= r[i].length; s = e.toString(); for (let r = s.length; s.length > t; r--) { s = e.toPrecision(r) } return s + r[i] } async function util_prompt(e) { const t = createInterface({ input: process.stdin, output: process.stdout }); return new Promise(((r, n) => { t.question(e, (e => { t.close(); r(e) })) })) } async function util_replaceInFile(e, t, r) { const n = await fs.readFile(e, "utf8"); const i = new RegExp(t, "g"); const s = n.replace(i, r); await fs.writeFile(e, s) } const ct = t("article"); const lt = "posts"; async function getArticlesFromFiles(e) { const t = await Ve(e); const r = await Promise.all(t.map(getArticleFromFile)); return r.filter((e => e !== null)) } async function getArticleFromFile(e) { const t = await Me.readFile(e, "utf8"); const r = Fe(t, { language: "yaml" }); if (!r.data.title || r.data.devto_sync !== undefined && !r.data.devto_sync) { ct('File "%s" do not have a title or has sync disabled, skipping', e); return null } return { file: e, ...r } } function article_getArticlesFromRemoteData(e) { return (e || []).map(getArticleFromRemoteData) } function generateFrontMatterMetadata(e) { const { data: t } = Fe(e.body_markdown); const r = { title: t.title ? null : e.title, description: t.description ? null : e.description, tags: t.tags ? null : e.tag_list.join(", "), cover_image: t.cover_image ? null : e.cover_image, canonical_url: t.canonical_url || e.url === e.canonical_url ? null : e.canonical_url, published: e.published ? true : null, id: e.id, date: e.published_at }; for (const e in r) { if (r[e] === null || r[e] === undefined) { delete r[e] } } return r } function getArticleFromRemoteData(e) { const t = Fe(e.body_markdown); return { ...t, file: null, data: { ...t.data, ...generateFrontMatterMetadata(e) } } } function prepareArticleForDevto(e, t, r) { return updateRelativeImageUrls(e, t, r) } async function article_saveArticleToFile(e) { try { if (!e.file) { throw new Error("no filename provided") } const t = Fe.stringify(e.content, e.data, { lineWidth: -1 }); await Me.ensureDir(Ne.dirname(e.file)); await Me.writeFile(e.file, t); ct('Saved article "%s" to file "%s"', e.data.title, e.file) } catch (t) { throw new Error(`Cannot write to file "${e.file ?? ""}": ${String(t)}`) } } async function updateLocalArticle(e, t) { const r = { ...e.data }; const n = { ...e, data: r }; let i = false; if (t.id) { r.id = t.id; i = true } if (t.published_at) { r.date = t.published_at; i = true } return { ...n, hasChanged: i } } function article_generateArticleFilename(e) { if (!e.data?.title) { throw new Error("No title found") } const t = slugify(e.data.title, { lower: true, strict: true }); const r = path.join(lt, t + ".md"); return { ...e, file: r } } function reconcileLocalArticles(e, t, r = true) { return t.map((t => { if (t.data.id) { return t } const n = t.data.title?.trim(); const i = e.find((e => e.data.title?.trim() === n)); if (i?.data.id) { ct('Reconciled article "%s" to ID %s', t.data.title, i.data.id); const e = r ? { id: i.data.id } : { ...i.data }; return { ...t, data: { ...t.data, ...e }, hasChanged: true } } return t })) } function areArticlesEqual(e, t) { const r = { lineWidth: -1 }; const n = Fe.stringify(e, { ...e.data, date: null }, r); const i = Fe.stringify(t, { ...t.data, date: null }, r); return n === i } function checkIfArticleNeedsUpdate(e, t) { if (!t.data.id) { return true } const r = e.find((e => e.data.id === t.data.id)); if (!r) { throw new Error(`Cannot find published article on dev.to: ${t.data.title ?? "<no title>"}`) } return !areArticlesEqual(r, t) } async function article_createNewArticle(e) { const t = { file: e, content: `My article content`, data: { title: "My article title", description: "My article description", tags: "", cover_image: "", canonical_url: null, published: false } }; await article_saveArticleToFile(t) } async function checkArticleForOfflineImages(e) { try { const t = getImageUrls(e); ct('Found %s image(s) to check for "%s"', t.length, e.data.title); const checkUrl = async e => { ct('Checking image "%s"…', e); await Te(e); return null }; await pMap(t, checkUrl, { concurrency: 5 }); return null } catch (e) { if (e instanceof errors_RequestError && e.response) { const t = e.response.requestUrl.toString(); ct('Image "%s" appears to be offline', t); return t } ct("Error while checking image: %s", String(e)); return String(e) } } var ft = __nccwpck_require__(5871); var dt = __nccwpck_require__(2437); const pt = 10; const wrapAnsi16 = (e = 0) => t => `[${t + e}m`; const wrapAnsi256 = (e = 0) => t => `[${38 + e};5;${t}m`; const wrapAnsi16m = (e = 0) => (t, r, n) => `[${38 + e};2;${t};${r};${n}m`; const ht = { modifier: { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], overline: [53, 55], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29] }, color: { black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], blackBright: [90, 39], gray: [90, 39], grey: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39] }, bgColor: { bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgGray: [100, 49], bgGrey: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49] } }; const mt = Object.keys(ht.modifier); const gt = Object.keys(ht.color); const yt = Object.keys(ht.bgColor); const bt = [...gt, ...yt]; function assembleStyles() { const e = new Map; for (const [t, r] of Object.entries(ht)) { for (const [t, n] of Object.entries(r)) { ht[t] = { open: `[${n[0]}m`, close: `[${n[1]}m` }; r[t] = ht[t]; e.set(n[0], n[1]) } Object.defineProperty(ht, t, { value: r, enumerable: false }) } Object.defineProperty(ht, "codes", { value: e, enumerable: false }); ht.color.close = "[39m"; ht.bgColor.close = "[49m"; ht.color.ansi = wrapAnsi16(); ht.color.ansi256 = wrapAnsi256(); ht.color.ansi16m = wrapAnsi16m(); ht.bgColor.ansi = wrapAnsi16(pt); ht.bgColor.ansi256 = wrapAnsi256(pt); ht.bgColor.ansi16m = wrapAnsi16m(pt); Object.defineProperties(ht, { rgbToAnsi256: { value(e, t, r) { if (e === t && t === r) { if (e < 8) { return 16 } if (e > 248) { return 231 } return Math.round((e - 8) / 247 * 24) + 232 } return 16 + 36 * Math.round(e / 255 * 5) + 6 * Math.round(t / 255 * 5) + Math.round(r / 255 * 5) }, enumerable: false }, hexToRgb: { value(e) { const t = /[a-f\d]{6}|[a-f\d]{3}/i.exec(e.toString(16)); if (!t) { return [0, 0, 0] } let [r] = t; if (r.length === 3) { r = [...r].map((e => e + e)).join("") } const n = Number.parseInt(r, 16); return [n >> 16 & 255, n >> 8 & 255, n & 255] }, enumerable: false }, hexToAnsi256: { value: e => ht.rgbToAnsi256(...ht.hexToRgb(e)), enumerable: false }, ansi256ToAnsi: { value(e) { if (e < 8) { return 30 + e } if (e < 16) { return 90 + (e - 8) } let t; let r; let n; if (e >= 232) { t = ((e - 232) * 10 + 8) / 255; r = t; n = t } else { e -= 16; const i = e % 36; t = Math.floor(e / 36) / 5; r = Math.floor(i / 6) / 5; n = i % 6 / 5 } const i = Math.max(t, r, n) * 2; if (i === 0) { return 30 } let s = 30 + (Math.round(n) << 2 | Math.round(r) << 1 | Math.round(t)); if (i === 2) { s += 60 } return s }, enumerable: false }, rgbToAnsi: { value: (e, t, r) => ht.ansi256ToAnsi(ht.rgbToAnsi256(e, t, r)), enumerable: false }, hexToAnsi: { value: e => ht.ansi256ToAnsi(ht.hexToAnsi256(e)), enumerable: false } }); return ht } const _t = assembleStyles(); const vt = _t; const wt = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("tty"); function hasFlag(e, t = (globalThis.Deno ? globalThis.Deno.args : p.argv)) { const r = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--"; const n = t.indexOf(r + e); const i = t.indexOf("--"); return n !== -1 && (i === -1 || n < i) } const { env: Dt } = p; let Et; if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) { Et = 0 } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) { Et = 1 } function envForceColor() { if ("FORCE_COLOR" in Dt) { if (Dt.FORCE_COLOR === "true") { return 1 } if (Dt.FORCE_COLOR === "false") { return 0 } return Dt.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(Dt.FORCE_COLOR, 10), 3) } } function translateLevel(e) { if (e === 0) { return false } return { level: e, hasBasic: true, has256: e >= 2, has16m: e >= 3 } } function _supportsColor(e, { streamIsTTY: t, sniffFlags: r = true } = {}) { const n = envForceColor(); if (n !== undefined) { Et = n } const i = r ? Et : n; if (i === 0) { return 0 } if (r) { if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) { return 3 } if (hasFlag("color=256")) { return 2 } } if ("TF_BUILD" in Dt && "AGENT_NAME" in Dt) { return 1 } if (e && !t && i === undefined) { return 0 } const s = i || 0; if (Dt.TERM === "dumb") { return s } if (p.platform === "win32") { const e = se.release().split("."); if (Number(e[0]) >= 10 && Number(e[2]) >= 10586) { return Number(e[2]) >= 14931 ? 3 : 2 } return 1 } if ("CI" in Dt) { if ("GITHUB_ACTIONS" in Dt) { return 3 } if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((e => e in Dt)) || Dt.CI_NAME === "codeship") { return 1 } return s } if ("TEAMCITY_VERSION" in Dt) { return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Dt.TEAMCITY_VERSION) ? 1 : 0 } if (Dt.COLORTERM === "truecolor") { return 3 } if (Dt.TERM === "xterm-kitty") { return 3 } if ("TERM_PROGRAM" in Dt) { const e = Number.parseInt((Dt.TERM_PROGRAM_VERSION || "").split(".")[0], 10); switch (Dt.TERM_PROGRAM) { case "iTerm.app": { return e >= 3 ? 3 : 2 } case "Apple_Terminal": { return 2 } } } if (/-256(color)?$/i.test(Dt.TERM)) { return 2 } if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(Dt.TERM)) { return 1 } if ("COLORTERM" in Dt) { return 1 } return s } function createSupportsColor(e, t = {}) { const r = _supportsColor(e, { streamIsTTY: e && e.isTTY, ...t }); return translateLevel(r) } const St = { stdout: createSupportsColor({ isTTY: wt.isatty(1) }), stderr: createSupportsColor({ isTTY: wt.isatty(2) }) }; const Ct = St; function stringReplaceAll(e, t, r) { let n = e.indexOf(t); if (n === -1) { return e } const i = t.length; let s = 0; let o = ""; do { o += e.slice(s, n) + t + r; s = n + i; n = e.indexOf(t, s) } while (n !== -1); o += e.slice(s); return o } function stringEncaseCRLFWithFirstIndex(e, t, r, n) { let i = 0; let s = ""; do { const o = e[n - 1] === "\r"; s += e.slice(i, o ? n - 1 : n) + t + (o ? "\r\n" : "\n") + r; i = n + 1; n = e.indexOf("\n", i) } while (n !== -1); s += e.slice(i); return s } const { stdout: xt, stderr: At } = Ct; const Pt = Symbol("GENERATOR"); const Rt = Symbol("STYLER"); const kt = Symbol("IS_EMPTY"); const Ot = ["ansi", "ansi", "ansi256", "ansi16m"]; const Tt = Object.create(null); const applyOptions = (e, t = {}) => { if (t.level && !(Number.isInteger(t.level) && t.level >= 0 && t.level <= 3)) { throw new Error("The `level` option should be an integer from 0 to 3") } const r = xt ? xt.level : 0; e.level = t.level === undefined ? r : t.level }; class Chalk { constructor(e) { return chalkFactory(e) } } const chalkFactory = e => { const chalk = (...e) => e.join(" "); applyOptions(chalk, e); Object.setPrototypeOf(chalk, createChalk.prototype); return chalk }; function createChalk(e) { return chalkFactory(e) } Object.setPrototypeOf(createChalk.prototype, Function.prototype); for (const [e, t] of Object.entries(vt)) { Tt[e] = { get() { const r = createBuilder(this, createStyler(t.open, t.close, this[Rt]), this[kt]); Object.defineProperty(this, e, { value: r }); return r } } } Tt.visible = { get() { const e = createBuilder(this, this[Rt], true); Object.defineProperty(this, "visible", { value: e }); return e } }; const getModelAnsi = (e, t, r, ...n) => { if (e === "rgb") { if (t === "ansi16m") { return vt[r].ansi16m(...n) } if (t === "ansi256") { return vt[r].ansi256(vt.rgbToAnsi256(...n)) } return vt[r].ansi(vt.rgbToAnsi(...n)) } if (e === "hex") { return getModelAnsi("rgb", t, r, ...vt.hexToRgb(...n)) } return vt[r][e](...n) }; const Ft = ["rgb", "hex", "ansi256"]; for (const e of Ft) { Tt[e] = { get() { const { level: t } = this; return function (...r) { const n = createStyler(getModelAnsi(e, Ot[t], "color", ...r), vt.color.close, this[Rt]); return createBuilder(this, n, this[kt]) } } }; const t = "bg" + e[0].toUpperCase() + e.slice(1); Tt[t] = { get() { const { level: t } = this; return function (...r) { const n = createStyler(getModelAnsi(e, Ot[t], "bgColor", ...r), vt.bgColor.close, this[Rt]); return createBuilder(this, n, this[kt]) } } } } const jt = Object.defineProperties((() => { }), { ...Tt, level: { enumerable: true, get() { return this[Pt].level }, set(e) { this[Pt].level = e } } }); const createStyler = (e, t, r) => { let n; let i; if (r === undefined) { n = e; i = t } else { n = r.openAll + e; i = t + r.closeAll } return { open: e, close: t, openAll: n, closeAll: i, parent: r } }; const createBuilder = (e, t, r) => { const builder = (...e) => applyStyle(builder, e.length === 1 ? "" + e[0] : e.join(" ")); Object.setPrototypeOf(builder, jt); builder[Pt] = e; builder[Rt] = t; builder[kt] = r; return builder }; const applyStyle = (e, t) => { if (e.level <= 0 || !t) { return e[kt] ? "" : t } let r = e[Rt]; if (r === undefined) { return t } const { openAll: n, closeAll: i } = r; if (t.includes("")) { while (r !== undefined) { t = stringReplaceAll(t, r.close, r.open); r = r.parent } } const s = t.indexOf("\n"); if (s !== -1) { t = stringEncaseCRLFWithFirstIndex(t, i, n, s) } return n + t + i }; Object.defineProperties(createChalk.prototype, Tt); const Lt = createChalk(); const It = createChalk({ level: At ? At.level : 0 }); const Bt = Lt; class Node { value; next; constructor(e) { this.value = e } } class Queue { #t; #r; #n; constructor() { this.clear() } enqueue(e) { const t = new Node(e); if (this.#t) { this.#r.next = t; this.#r = t } else { this.#t = t; this.#r = t } this.#n++ } dequeue() { const e = this.#t; if (!e) { return } this.#t = this.#t.next; this.#n--; return e.value } clear() { this.#t = undefined; this.#r = undefined; this.#n = 0 } get size() { return this.#n } *[Symbol.iterator]() { let e = this.#t; while (e) { yield e.value; e = e.next } } } function pLimit(e) { if (!((Number.isInteger(e) || e === Number.POSITIVE_INFINITY) && e > 0)) { throw new TypeError("Expected `concurrency` to be a number from 1 and up") } const t = new Queue; let r = 0; const next = () => { r--; if (t.size > 0) { t.dequeue()() } }; const run = async (e, t, n) => { r++; const i = (async () => e(...n))(); t(i); try { await i } catch { } next() }; const enqueue = (n, i, s) => { t.enqueue(run.bind(undefined, n, i, s)); (async () => { await Promise.resolve(); if (r < e && t.size > 0) { t.dequeue()() } })() }; const generator = (e, ...t) => new Promise((r => { enqueue(e, r, t) })); Object.defineProperties(generator, { activeCount: { get: () => r }, pendingCount: { get: () => t.size }, clearQueue: { value: () => { t.clear() } } }); return generator } class EndError extends Error { constructor(e) { super(); this.value = e } } const testElement = async (e, t) => t(await e); const finder = async e => { const t = await Promise.all(e); if (t[1] === true) { throw new EndError(t[0]) } return false }; async function pLocate(e, t, { concurrency: r = Number.POSITIVE_INFINITY, preserveOrder: n = true } = {}) { const i = pLimit(r); const s = [...e].map((e => [e, i(testElement, e, t)])); const o = pLimit(n ? 1 : Number.POSITIVE_INFINITY); try { await Promise.all(s.map((e => o(finder, e)))) } catch (e) { if (e instanceof EndError) { return e.value } throw e } } const Nt = { directory: "isDirectory", file: "isFile" }; function checkType(e) { if (Object.hasOwnProperty.call(Nt, e)) { return } throw new Error(`Invalid type specified: ${e}`) } const matchType = (e, t) => t[Nt[e]](); const locate_path_toPath = e => e instanceof URL ? (0, g.fileURLToPath)(e) : e; async function locatePath(e, { cwd: t = p.cwd(), type: r = "file", allowSymlinks: n = true, concurrency: i, preserveOrder: s } = {}) { checkType(r); t = locate_path_toPath(t); const o = n ? $e.promises.stat : $e.promises.lstat; return pLocate(e, (async e => { try { const n = await o(Ne.resolve(t, e)); return matchType(r, n) } catch { return false } }), { concurrency: i, preserveOrder: s }) } function locate_path_locatePathSync(e, { cwd: t = process.cwd(), type: r = "file", allowSymlinks: n = true } = {}) { checkType(r); t = locate_path_toPath(t); const i = n ? fs.statSync : fs.lstatSync; for (const n of e) { try { const e = i(path.resolve(t, n), { throwIfNoEntry: false }); if (!e) { continue } if (matchType(r, e)) { return n } } catch { } } } async function pathExists(e) { try { await fsPromises.access(e); return true } catch { return false } } function pathExistsSync(e) { try { fs.accessSync(e); return true } catch { return false } } const find_up_toPath = e => e instanceof URL ? (0, g.fileURLToPath)(e) : e; const Mt = Symbol("findUpStop"); async function findUpMultiple(e, t = {}) { let r = Ne.resolve(find_up_toPath(t.cwd) || ""); const { root: n } = Ne.parse(r); const i = Ne.resolve(r, t.stopAt || n); const s = t.limit || Number.POSITIVE_INFINITY; const o = [e].flat(); const runMatcher = async t => { if (typeof e !== "function") { return locatePath(o, t) } const r = await e(t.cwd); if (typeof r === "string") { return locatePath([r], t) } return r }; const a = []; while (true) { const e = await runMatcher({ ...t, cwd: r }); if (e === Mt) { break } if (e) { a.push(Ne.resolve(r, e)) } if (r === i || a.length >= s) { break } r = Ne.dirname(r) } return a } function findUpMultipleSync(e, t = {}) { let r = path.resolve(find_up_toPath(t.cwd) || ""); const { root: n } = path.parse(r); const i = t.stopAt || n; const s = t.limit || Number.POSITIVE_INFINITY; const o = [e].flat(); const runMatcher = t => { if (typeof e !== "function") { return locatePathSync(o, t) } const r = e(t.cwd); if (typeof r === "string") { return locatePathSync([r], t) } return r }; const a = []; while (true) { const e = runMatcher({ ...t, cwd: r }); if (e === Mt) { break } if (e) { a.push(path.resolve(r, e)) } if (r === i || a.length >= s) { break } r = path.dirname(r) } return a } async function findUp(e, t = {}) { const r = await findUpMultiple(e, { ...t, limit: 1 }); return r[0] } function findUpSync(e, t = {}) { const r = findUpMultipleSync(e, { ...t, limit: 1 }); return r[0] } var $t = __nccwpck_require__(5218); const Ht = __WEBPACK_EXTERNAL_createRequire(import.meta.url)("child_process"); var qt = __nccwpck_require__(7881); function stripFinalNewline(e) { const t = typeof e === "string" ? "\n" : "\n".charCodeAt(); const r = typeof e === "string" ? "\r" : "\r".charCodeAt(); if (e[e.length - 1] === t) { e = e.slice(0, -1) } if (e[e.length - 1] === r) { e = e.slice(0, -1) } return e } function pathKey(e = {}) { const { env: t = process.env, platform: r = process.platform } = e; if (r !== "win32") { return "PATH" } return Object.keys(t).reverse().find((e => e.toUpperCase() === "PATH")) || "Path" } function npmRunPath(e = {}) { const { cwd: t = p.cwd(), path: r = p.env[pathKey()], execPath: n = p.execPath } = e; let i; const s = t instanceof URL ? g.fileURLToPath(t) : t; let o = Ne.resolve(s); const a = []; while (i !== o) { a.push(Ne.join(o, "node_modules/.bin")); i = o; o = Ne.resolve(o, "..") } a.push(Ne.resolve(s, n, "..")); return [...a, r].join(Ne.delimiter) } function npmRunPathEnv({ env: e = p.env, ...t } = {}) { e = { ...e }; const r = pathKey({ env: e }); t.path = e[r]; e[r] = npmRunPath(t); return e } const copyProperty = (e, t, r, n) => { if (r === "length" || r === "prototype") { return } if (r === "arguments" || r === "caller") { return } const i = Object.getOwnPropertyDescriptor(e, r); const s = Object.getOwnPropertyDescriptor(t, r); if (!canCopyProperty(i, s) && n) { return } Object.defineProperty(e, r, s) }; const canCopyProperty = function (e, t) { return e === undefined || e.configurable || e.writable === t.writable && e.enumerable === t.enumerable && e.configurable === t.configurable && (e.writable || e.value === t.value) }; const changePrototype = (e, t) => { const r = Object.getPrototypeOf(t); if (r === Object.getPrototypeOf(e)) { return } Object.setPrototypeOf(e, r) }; const wrappedToString = (e, t) => `/* Wrapped ${e}*/\n${t}`; const Ut = Object.getOwnPropertyDescriptor(Function.prototype, "toString"); const Wt = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name"); const changeToString = (e, t, r) => { const n = r === "" ? "" : `with ${r.trim()}() `; const i = wrappedToString.bind(null, n, t.toString()); Object.defineProperty(i, "name", Wt); Object.defineProperty(e, "toString", { ...Ut, value: i }) }; function mimicFunction(e, t, { ignoreNonConfigurable: r = false } = {}) { const { name: n } = e; for (const n of Reflect.ownKeys(t)) { copyProperty(e, t, n, r) } changePrototype(e, t); changeToString(e, t, n); return e } const Gt = new WeakMap; const onetime = (e, t = {}) => { if (typeof e !== "function") { throw new TypeError("Expected a function") } let r; let n = 0; const i = e.displayName || e.name || "<anonymous>"; const onetime = function (...s) { Gt.set(onetime, ++n); if (n === 1) { r = e.apply(this, s); e = null } else if (t.throw === true) { throw new Error(`Function \`${i}\` can only be called once`) } return r }; mimicFunction(onetime, e); Gt.set(onetime, n); return onetime }; onetime.callCount = e => { if (!Gt.has(e)) { throw new Error(`The given function \`${e.name}\` is not wrapped by the \`onetime\` package`) } return Gt.get(e) }; const zt = onetime; const getRealtimeSignals = () => { const e = Kt - Vt + 1; return Array.from({ length: e }, getRealtimeSignal) }; const getRealtimeSignal = (e, t) => ({ name: `SIGRT${t + 1}`, number: Vt + t, action: "terminate", description: "Application-specific signal (realtime)", standard: "posix" }); const Vt = 34; const Kt = 64; const Jt = [{ name: "SIGHUP", number: 1, action: "terminate", description: "Terminal closed", standard: "posix" }, { name: "SIGINT", number: 2, action: "terminate", description: "User interruption with CTRL-C", standard: "ansi" }, { name: "SIGQUIT", number: 3, action: "core", description: "User interruption with CTRL-\\", standard: "posix" }, { name: "SIGILL", number: 4, action: "core", description: "Invalid machine instruction", standard: "ansi" }, { name: "SIGTRAP", number: 5, action: "core", description: "Debugger breakpoint", standard: "posix" }, { name: "SIGABRT", number: 6, action: "core", description: "Aborted", standard: "ansi" }, { name: "SIGIOT", number: 6, action: "core", description: "Aborted", standard: "bsd" }, { name: "SIGBUS", number: 7, action: "core", description: "Bus error due to misaligned, non-existing address or paging error", standard: "bsd" }, { name: "SIGEMT", number: 7, action: "terminate", description: "Command should be emulated but is not implemented", standard: "other" }, { name: "SIGFPE", number: 8, action: "core", description: "Floating point arithmetic error", standard: "ansi" }, { name: "SIGKILL", number: 9, action: "terminate", description: "Forced termination", standard: "posix", forced: true }, { name: "SIGUSR1", number: 10, action: "terminate", description: "Application-specific signal", standard: "posix" }, { name: "SIGSEGV", number: 11, action: "core", description: "Segmentation fault", standard: "ansi" }, { name: "SIGUSR2", number: 12, action: "terminate", description: "Application-specific signal", standard: "posix" }, { name: "SIGPIPE", number: 13, action: "terminate", description: "Broken pipe or socket", standard: "posix" }, { name: "SIGALRM", number: 14, action: "terminate", description: "Timeout or timer", standard: "posix" }, { name: "SIGTERM", number: 15, action: "terminate", description: "Termination", standard: "ansi" }, { name: "SIGSTKFLT", number: 16, action: "terminate", description: "Stack is empty or overflowed", standard: "other" }, { name: "SIGCHLD", number: 17, action: "ignore", description: "Child process terminated, paused or unpaused", standard: "posix" }, { name: "SIGCLD", number: 17, action: "ignore", description: "Child process terminated, paused or unpaused", standard: "other" }, { name: "SIGCONT", number: 18, action: "unpause", description: "Unpaused", standard: "posix", forced: true }, { name: "SIGSTOP", number: 19, action: "pause", description: "Paused", standard: "posix", forced: true }, { name: "SIGTSTP", number: 20, action: "pause", description: 'Paused using CTRL-Z or "suspend"', standard: "posix" }, { name: "SIGTTIN", number: 21, action: "pause", description: "Background process cannot read terminal input", standard: "posix" }, { name: "SIGBREAK", number: 21, action: "terminate", description: "User interruption with CTRL-BREAK", standard: "other" }, { name: "SIGTTOU", number: 22, action: "pause", description: "Background process cannot write to terminal output", standard: "posix" }, { name: "SIGURG", number: 23, action: "ignore", description: "Socket received out-of-band data", standard: "bsd" }, { name: "SIGXCPU", number: 24, action: "core", description: "Process timed out", standard: "bsd" }, { name: "SIGXFSZ", number: 25, action: "core", description: "File too big", standard: "bsd" }, { name: "SIGVTALRM", number: 26, action: "terminate", description: "Timeout or timer", standard: "bsd" }, { name: "SIGPROF", number: 27, action: "terminate", description: "Timeout or timer", standard: "bsd" }, { name: "SIGWINCH", number: 28, action: "ignore", description: "Terminal window size changed", standard: "bsd" }, { name: "SIGIO", number: 29, action: "terminate", description: "I/O is available", standard: "other" }, { name: "SIGPOLL", number: 29, action: "terminate", description: "Watched event", standard: "other" }, { name: "SIGINFO", number: 29, action: "ignore", description: "Request for process information", standard: "other" }, { name: "SIGPWR", number: 30, action: "terminate", description: "Device running out of power", standard: "systemv" }, { name: "SIGSYS", number: 31, action: "core", description: "Invalid system call", standard: "other" }, { name: "SIGUNUSED", number: 31, action: "terminate", description: "Invalid system call", standard: "other" }]; const getSignals = () => { const e = getRealtimeSignals(); const t = [...Jt, ...e].map(normalizeSignal); return t }; const normalizeSignal = ({ name: e, number: t, description: r, action: n, forced: i = false, standard: s }) => { const { signals: { [e]: o } } = se.constants; const a = o !== undefined; const u = a ? o : t; return { name: e, number: u, description: r, supported: a, action: n, forced: i, standard: s } }; const getSignalsByName = () => { const e = getSignals(); return Object.fromEntries(e.map(getSignalByName)) }; const getSignalByName = ({ name: e, number: t, description: r, supported: n, action: i, forced: s, standard: o }) => [e, { name: e, number: t, description: r, supported: n, action: i, forced: s, standard: o }]; const Yt = getSignalsByName(); const getSignalsByNumber = () => { const e = getSignals(); const t = Kt + 1; const r = Array.from({ length: t }, ((t, r) => getSignalByNumber(r, e))); return Object.assign({}, ...r) }; const getSignalByNumber = (e, t) => { const r = findSignalByNumber(e, t); if (r === undefined) { return {} } const { name: n, description: i, supported: s, action: o, forced: a, standard: u } = r; return { [e]: { name: n, number: e, description: i, supported: s, action: o, forced: a, standard: u } } }; const findSignalByNumber = (e, t) => { const r = t.find((({ name: t }) => se.constants.signals[t] === e)); if (r !== undefined) { return r } return t.find((t => t.number === e)) }; const Qt = getSignalsByNumber(); const getErrorPrefix = ({ timedOut: e, timeout: t, errorCode: r, signal: n, signalDescription: i, exitCode: s, isCanceled: o }) => { if (e) { return `timed out after ${t} milliseconds` } if (o) { return "was canceled" } if (r !== undefined) { return `failed with ${r}` } if (n !== undefined) { return `was killed with ${n} (${i})` } if (s !== undefined) { return `failed with exit code ${s}` } return "failed" }; const makeError = ({ stdout: e, stderr: t, all: r, error: n, signal: i, exitCode: s, command: o, escapedCommand: a, timedOut: u, isCanceled: l, killed: f, parsed: { options: { timeout: d } } }) => { s = s === null ? undefined : s; i = i === null ? undefined : i; const p = i === undefined ? undefined : Yt[i].description; const h = n && n.code; const m = getErrorPrefix({ timedOut: u, timeout: d, errorCode: h, signal: i, signalDescription: p, exitCode: s, isCanceled: l }); const g = `Command ${m}: ${o}`; const y = Object.prototype.toString.call(n) === "[object Error]"; const b = y ? `${g}\n${n.message}` : g; const _ = [b, t, e].filter(Boolean).join("\n"); if (y) { n.originalMessage = n.message; n.message = _ } else { n = new Error(_) } n.shortMessage = b; n.command = o; n.escapedCommand = a; n.exitCode = s; n.signal = i; n.signalDescription = p; n.stdout = e; n.stderr = t; if (r !== undefined) { n.all = r } if ("bufferedData" in n) { delete n.bufferedData } n.failed = true; n.timedOut = Boolean(u); n.isCanceled = l; n.killed = f && !u; return n }; const Xt = ["stdin", "stdout", "stderr"]; const hasAlias = e => Xt.some((t => e[t] !== undefined)); const normalizeStdio = e => { if (!e) { return } const { stdio: t } = e; if (t === undefined) { return Xt.map((t => e[t])) } if (hasAlias(e)) { throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${Xt.map((e => `\`${e}\``)).join(", ")}`) } if (typeof t === "string") { return t } if (!Array.isArray(t)) { throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof t}\``) } const r = Math.max(t.length, Xt.length); return Array.from({ length: r }, ((e, r) => t[r])) }; const stdio_normalizeStdioNode = e => { const t = normalizeStdio(e); if (t === "ipc") { return "ipc" } if (t === undefined || typeof t === "string") { return [t, t, t, "ipc"] } if (t.includes("ipc")) { return t } return [...t, "ipc"] }; var Zt = __nccwpck_require__(4931); const er = 1e3 * 5; const spawnedKill = (e, t = "SIGTERM", r = {}) => { const n = e(t); setKillTimeout(e, t, r, n); return n }; const setKillTimeout = (e, t, r, n) => { if (!shouldForceKill(t, r, n)) { return } const i = getForceKillAfterTimeout(r); const s = setTimeout((() => { e("SIGKILL") }), i); if (s.unref) { s.unref() } }; const shouldForceKill = (e, { forceKillAfterTimeout: t }, r) => isSigterm(e) && t !== false && r; const isSigterm = e => e === se.constants.signals.SIGTERM || typeof e === "string" && e.toUpperCase() === "SIGTERM"; const getForceKillAfterTimeout = ({ forceKillAfterTimeout: e = true }) => { if (e === true) { return er } if (!Number.isFinite(e) || e < 0) { throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${e}\` (${typeof e})`) } return e }; const spawnedCancel = (e, t) => { const r = e.kill(); if (r) { t.isCanceled = true } }; const timeoutKill = (e, t, r) => { e.kill(t); r(Object.assign(new Error("Timed out"), { timedOut: true, signal: t })) }; const setupTimeout = (e, { timeout: t, killSignal: r = "SIGTERM" }, n) => { if (t === 0 || t === undefined) { return n } let i; const s = new Promise(((n, s) => { i = setTimeout((() => { timeoutKill(e, r, s) }), t) })); const o = n.finally((() => { clearTimeout(i) })); return Promise.race([s, o]) }; const validateTimeout = ({ timeout: e }) => { if (e !== undefined && (!Number.isFinite(e) || e < 0)) { throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${e}\` (${typeof e})`) } }; const setExitHandler = async (e, { cleanup: t, detached: r }, n) => { if (!t || r) { return n } const i = Zt((() => { e.kill() })); return n.finally((() => { i() })) }; function isStream(e) { return e !== null && typeof e === "object" && typeof e.pipe === "function" } function isWritableStream(e) { return isStream(e) && e.writable !== false && typeof e._write === "function" && typeof e._writableState === "object" } function isReadableStream(e) { return isStream(e) && e.readable !== false && typeof e._read === "function" && typeof e._readableState === "object" } function isDuplexStream(e) { return isWritableStream(e) && isReadableStream(e) } function isTransformStream(e) { return isDuplexStream(e) && typeof e._transform === "function" } const isExecaChildProcess = e => e instanceof Ht.ChildProcess && typeof e.then === "function"; const pipeToTarget = (e, t, r) => { if (typeof r === "string") { e[t].pipe((0, $e.createWriteStream)(r)); return e } if (isWritableStream(r)) { e[t].pipe(r); return e } if (!isExecaChildProcess(r)) { throw new TypeError("The second argument must be a string, a stream or an Execa child process.") } if (!isWritableStream(r.stdin)) { throw new TypeError("The target child process's stdin must be available.") } e[t].pipe(r.stdin); return r }; const addPipeMethods = e => { if (e.stdout !== null) { e.pipeStdout = pipeToTarget.bind(undefined, e, "stdout") } if (e.stderr !== null) { e.pipeStderr = pipeToTarget.bind(undefined, e, "stderr") } if (e.all !== undefined) { e.pipeAll = pipeToTarget.bind(undefined, e, "all") } }; var tr = __nccwpck_require__(2621); const validateInputOptions = e => { if (e !== undefined) { throw new TypeError("The `input` and `inputFile` options cannot be both set.") } }; const getInputSync = ({ input: e, inputFile: t }) => { if (typeof t !== "string") { return e } validateInputOptions(e); return (0, $e.readFileSync)(t) }; const handleInputSync = e => { const t = getInputSync(e); if (isStream(t)) { throw new TypeError("The `input` option cannot be a stream in sync mode") } return t }; const getInput = ({ input: e, inputFile: t }) => { if (typeof t !== "string") { return e } validateInputOptions(e); return (0, $e.createReadStream)(t) }; const handleInput = (e, t) => { const r = getInput(t); if (r === undefined) { return } if (isStream(r)) { r.pipe(e.stdin) } else { e.stdin.end(r) } }; const makeAllStream = (e, { all: t }) => { if (!t || !e.stdout && !e.stderr) { return } const r = tr(); if (e.stdout) { r.add(e.stdout) } if (e.stderr) { r.add(e.stderr) } return r }; const getBufferedData = async (e, t) => { if (!e || t === undefined) { return } e.destroy(); try { return await t } catch (e) { return e.bufferedData } }; const getStreamPromise = (e, { encoding: t, buffer: r, maxBuffer: n }) => { if (!e || !r) { return } if (t) { return x(e, { encoding: t, maxBuffer: n }) } return x.buffer(e, { maxBuffer: n }) }; const getSpawnedResult = async ({ stdout: e, stderr: t, all: r }, { encoding: n, buffer: i, maxBuffer: s }, o) => { const a = getStreamPromise(e, { encoding: n, buffer: i, maxBuffer: s }); const u = getStreamPromise(t, { encoding: n, buffer: i, maxBuffer: s }); const l = getStreamPromise(r, { encoding: n, buffer: i, maxBuffer: s * 2 }); try { return await Promise.all([o, a, u, l]) } catch (n) { return Promise.all([{ error: n, signal: n.signal, timedOut: n.timedOut }, getBufferedData(e, a), getBufferedData(t, u), getBufferedData(r, l)]) } }; const rr = (async () => { })().constructor.prototype; const nr = ["then", "catch", "finally"].map((e => [e, Reflect.getOwnPropertyDescriptor(rr, e)])); const mergePromise = (e, t) => { for (const [r, n] of nr) { const i = typeof t === "function" ? (...e) => Reflect.apply(n.value, t(), e) : n.value.bind(t); Reflect.defineProperty(e, r, { ...n, value: i }) } }; const getSpawnedPromise = e => new Promise(((t, r) => { e.on("exit", ((e, r) => { t({ exitCode: e, signal: r }) })); e.on("error", (e => { r(e) })); if (e.stdin) { e.stdin.on("error", (e => { r(e) })) } })); const normalizeArgs = (e, t = []) => { if (!Array.isArray(t)) { return [e] } return [e, ...t] }; const ir = /^[\w.-]+$/; const sr = /"/g; const escapeArg = e => { if (typeof e !== "string" || ir.test(e)) { return e } return `"${e.replace(sr, '\\"')}"` }; const joinCommand = (e, t) => normalizeArgs(e, t).join(" "); const getEscapedCommand = (e, t) => normalizeArgs(e, t).map((e => escapeArg(e))).join(" "); const or = / +/g; const command_parseCommand = e => { const t = []; for (const r of e.trim().split(or)) { const e = t[t.length - 1]; if (e && e.endsWith("\\")) { t[t.length - 1] = `${e.slice(0, -1)} ${r}` } else { t.push(r) } } return t }; const parseExpression = e => { const t = typeof e; if (t === "string") { return e } if (t === "number") { return String(e) } if (t === "object" && e !== null && !(e instanceof Ht.ChildProcess) && "stdout" in e) { const t = typeof e.stdout; if (t === "string") { return e.stdout } if (h.Buffer.isBuffer(e.stdout)) { return e.stdout.toString() } throw new TypeError(`Unexpected "${t}" stdout in template expression`) } throw new TypeError(`Unexpected "${t}" in template expression`) }; const concatTokens = (e, t, r) => r || e.length === 0 || t.length === 0 ? [...e, ...t] : [...e.slice(0, -1), `${e[e.length - 1]}${t[0]}`, ...t.slice(1)]; const parseTemplate = ({ templates: e, expressions: t, tokens: r, index: n, template: i }) => { const s = i ?? e.raw[n]; const o = s.split(or).filter(Boolean); const a = concatTokens(r, o, s.startsWith(" ")); if (n === t.length) { return a } const u = t[n]; const l = Array.isArray(u) ? u.map((e => parseExpression(e))) : [parseExpression(u)]; return concatTokens(a, l, s.endsWith(" ")) }; const parseTemplates = (e, t) => { let r = []; for (const [n, i] of e.entries()) { r = parseTemplate({ templates: e, expressions: t, tokens: r, index: n, template: i }) } return r }; const ar = (0, X.debuglog)("execa").enabled; const padField = (e, t) => String(e).padStart(t, "0"); const getTimestamp = () => { const e = new Date; return `${padField(e.getHours(), 2)}:${padField(e.getMinutes(), 2)}:${padField(e.getSeconds(), 2)}.${padField(e.getMilliseconds(), 3)}` }; const logCommand = (e, { verbose: t }) => { if (!t) { return } p.stderr.write(`[${getTimestamp()}] ${e}\n`) }; const ur = 1e3 * 1e3 * 100; const getEnv = ({ env: e, extendEnv: t, preferLocal: r, localDir: n, execPath: i }) => { const s = t ? { ...p.env, ...e } : e; if (r) { return npmRunPathEnv({ env: s, cwd: n, execPath: i }) } return s }; const handleArguments = (e, t, r = {}) => { const n = qt._parse(e, t, r); e = n.command; t = n.args; r = n.options; r = { maxBuffer: ur, buffer: true, stripFinalNewline: true, extendEnv: true, preferLocal: false, localDir: r.cwd || p.cwd(), execPath: p.execPath, encoding: "utf8", reject: true, cleanup: true, all: false, windowsHide: true, verbose: ar, ...r }; r.env = getEnv(r); r.stdio = normalizeStdio(r); if (p.platform === "win32" && Ne.basename(e, ".exe") === "cmd") { t.unshift("/q") } return { file: e, args: t, options: r, parsed: n } }; const handleOutput = (e, t, r) => { if (typeof t !== "string" && !h.Buffer.isBuffer(t)) { return r === undefined ? undefined : "" } if (e.stripFinalNewline) { return stripFinalNewline(t) } return t }; function execa_execa(e, t, r) { const n = handleArguments(e, t, r); const i = joinCommand(e, t); const s = getEscapedCommand(e, t); logCommand(s, n.options); validateTimeout(n.options); let o; try { o = Ht.spawn(n.file, n.args, n.options) } catch (e) { const t = new Ht.ChildProcess; const r = Promise.reject(makeError({ error: e, stdout: "", stderr: "", all: "", command: i, escapedCommand: s, parsed: n, timedOut: false, isCanceled: false, killed: false })); mergePromise(t, r); return t } const a = getSpawnedPromise(o); const u = setupTimeout(o, n.options, a); const l = setExitHandler(o, n.options, u); const f = { isCanceled: false }; o.kill = spawnedKill.bind(null, o.kill.bind(o)); o.cancel = spawnedCancel.bind(null, o, f); const handlePromise = async () => { const [{ error: e, exitCode: t, signal: r, timedOut: a }, u, d, p] = await getSpawnedResult(o, n.options, l); const h = handleOutput(n.options, u); const m = handleOutput(n.options, d); const g = handleOutput(n.options, p); if (e || t !== 0 || r !== null) { const u = makeError({ error: e, exitCode: t, signal: r, stdout: h, stderr: m, all: g, command: i, escapedCommand: s, parsed: n, timedOut: a, isCanceled: f.isCanceled || (n.options.signal ? n.options.signal.aborted : false), killed: o.killed }); if (!n.options.reject) { return u } throw u } return { command: i, escapedCommand: s, exitCode: 0, stdout: h, stderr: m, all: g, failed: false, timedOut: false, isCanceled: false, killed: false } }; const d = zt(handlePromise); handleInput(o, n.options); o.all = makeAllStream(o, n.options); addPipeMethods(o); mergePromise(o, d); return o } function execaSync(e, t, r) { const n = handleArguments(e, t, r); const i = joinCommand(e, t); const s = getEscapedCommand(e, t); logCommand(s, n.options); const o = handleInputSync(n.options); let a; try { a = Ht.spawnSync(n.file, n.args, { ...n.options, input: o }) } catch (e) { throw makeError({ error: e, stdout: "", stderr: "", all: "", command: i, escapedCommand: s, parsed: n, timedOut: false, isCanceled: false, killed: false }) } const u = handleOutput(n.options, a.stdout, a.error); const l = handleOutput(n.options, a.stderr, a.error); if (a.error || a.status !== 0 || a.signal !== null) { const e = makeError({ stdout: u, stderr: l, error: a.error, signal: a.signal, exitCode: a.status, command: i, escapedCommand: s, parsed: n, timedOut: a.error && a.error.code === "ETIMEDOUT", isCanceled: false, killed: a.signal !== null }); if (!n.options.reject) { return e } throw e } return { command: i, escapedCommand: s, exitCode: 0, stdout: u, stderr: l, failed: false, timedOut: false, isCanceled: false, killed: false } } const normalizeScriptStdin = ({ input: e, inputFile: t, stdio: r }) => e === undefined && t === undefined && r === undefined ? { stdin: "inherit" } : {}; const normalizeScriptOptions = (e = {}) => ({ preferLocal: true, ...normalizeScriptStdin(e), ...e }); function create$(e) { function $(t, ...r) { if (!Array.isArray(t)) { return create$({ ...e, ...t }) } const [n, ...i] = parseTemplates(t, r); return execa_execa(n, i, normalizeScriptOptions(e)) } $.sync = (t, ...r) => { if (!Array.isArray(t)) { throw new TypeError("Please use $(options).sync`command` instead of $.sync(options)`command`.") } const [n, ...i] = parseTemplates(t, r); return execaSync(n, i, normalizeScriptOptions(e)) }; return $ } const cr = create$(); function execaCommand(e, t) { const [r, ...n] = parseCommand(e); return execa_execa(r, n, t) } function execaCommandSync(e, t) { const [r, ...n] = parseCommand(e); return execaSync(r, n, t) } function execaNode(e, t, r = {}) { if (t && !Array.isArray(t) && typeof t === "object") { r = t; t = [] } const n = normalizeStdioNode(r); const i = process.execArgv.filter((e => !e.startsWith("--inspect"))); const { nodePath: s = process.execPath, nodeOptions: o = i } = r; return execa_execa(s, [...o, e, ...Array.isArray(t) ? t : []], { ...r, stdin: undefined, stdout: undefined, stderr: undefined, stdio: n, shell: false }) } const lr = t("repo"); const fr = /.*[/:](.*)\/(.*)\.git|^([^/]*)\/([^/]*)$/; const dr = "package.json"; const repo_getShorthandString = e => `${e.user}/${e.name}`; const repo_hasGitInstalled = async () => new Promise((e => { $t("git", e) })); function repo_parseRepository(e) { if (!e) { return null } const t = fr.exec(e); if (!t) { return null } const r = Boolean(t[3]); return { user: r ? t[3] : t[1], name: r ? t[4] : t[2] } } async function getRepositoryFromPackage(e) { let t; if (e) { t = await findUp(dr) } else if (await Me.pathExists(dr)) { t = dr } if (!t) { lr("No package.json found"); return null } try { const e = await Me.readJson(t); const r = repo_parseRepository(e.repository?.url || e.repository); lr(r ? "Repository found in package.json:" : "No repository found in package.json", r ? repo_getShorthandString(r) : ""); return r } catch (e) { lr("Error while reading package.json:", String(e)); return null } } async function getRepositoryFromGit() { if (!await repo_hasGitInstalled()) { lr("Git binary not found"); return null } try { const { stdout: e } = await execa_execa("git", ["remote", "get-url", "origin"]); const t = repo_parseRepository(e); lr(t ? "Repository found in git origin:" : "No repository found in git origin", t ? repo_getShorthandString(t) : ""); return t } catch (e) { lr(`Git error: ${String(e)}`); return null } } function getRepositoryFromStringOrEnv(e) { return repo_parseRepository(e) ?? repo_parseRepository(p.env.DEVTO_REPO) } async function repo_getRepository(e, t = true) { return getRepositoryFromStringOrEnv(e) ?? await getRepositoryFromGit() ?? getRepositoryFromPackage(t) } async function repo_isGitRepository() { return await repo_hasGitInstalled() && fs.pathExists(".git") } async function repo_initGitRepository(e) { e = e?.trim() || "main"; try { await execa("git", ["init"]); lr("Git repository initialized"); const t = await getCurrentBranchFromGit(); if (t !== e) { await execa("git", ["commit", "--allow-empty", "-m", "feat: initial commit"]); await execa("git", ["branch", "-M", e]); lr(`Git: renamed branch to "${e}"`) } } catch (e) { lr(`Git error: ${String(e)}`) } } async function getCurrentBranchFromGit() { if (!await repo_hasGitInstalled()) { lr("Git binary not found"); return null } try { const { stdout: e } = await execa_execa("git", ["rev-parse", "--abbrev-ref", "HEAD"]); return e.trim() } catch (e) { lr(`Git error: ${String(e)}`); return null } } function getBranchFromStringOrEnv(e) { const t = e || p.env.DEVTO_BRANCH; return t?.trim() || null } async function repo_getBranch(e) { return getBranchFromStringOrEnv(e) ?? getCurrentBranchFromGit() } var pr = __nccwpck_require__(4536); const hr = pr((() => { Zt((() => { p.stderr.write("[?25h") }), { alwaysLast: true }) })); const mr = hr; let gr = false; const yr = {}; yr.show = (e = p.stderr) => { if (!e.isTTY) { return } gr = false; e.write("[?25h") }; yr.hide = (e = p.stderr) => { if (!e.isTTY) { return } mr(); gr = true; e.write("[?25l") }; yr.toggle = (e, t) => { if (e !== undefined) { gr = e } if (gr) { yr.show(t) } else { yr.hide(t) } }; const br = yr; var _r = __nccwpck_require__(2031); function isUnicodeSupported() { if (p.platform !== "win32") { return p.env.TERM !== "linux" } return Boolean(p.env.CI) || Boolean(p.env.WT_SESSION) || Boolean(p.env.TERMINUS_SUBLIME) || p.env.ConEmuTask === "{cmd::Cmder}" || p.env.TERM_PROGRAM === "Terminus-Sublime" || p.env.TERM_PROGRAM === "vscode" || p.env.TERM === "xterm-256color" || p.env.TERM === "alacritty" || p.env.TERMINAL_EMULATOR === "JetBrains-JediTerm" } const vr = { info: Bt.blue("ℹ"), success: Bt.green("✔"), warning: Bt.yellow("⚠"), error: Bt.red("✖") }; const wr = { info: Bt.blue("i"), success: Bt.green("√"), warning: Bt.yellow("‼"), error: Bt.red("×") }; const Dr = isUnicodeSupported() ? vr : wr; const Er = Dr; function ansiRegex({ onlyFirst: e = false } = {}) { const t = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|"); return new RegExp(t, e ? undefined : "g") } function stripAnsi(e) { if (typeof e !== "string") { throw new TypeError(`Expected a \`string\`, got \`${typeof e}\``) } return e.replace(ansiRegex(), "") } var Sr = __nccwpck_require__(5917); function isInteractive({ stream: e = process.stdout } = {}) { return Boolean(e && e.isTTY && process.env.TERM !== "dumb" && !("CI" in process.env)) } var Cr = __nccwpck_require__(336); const xr = 3; class StdinDiscarder { #i = 0; #s = new Cr.BufferListStream; #o; #a; constructor() { this.#s.pipe(p.stdout); const e = this; this.#o = function (t, r, ...n) { const { stdin: i } = p; if (e.#i > 0 || i.emit === e.#o) { if (t === "keypress") { return } if (t === "data" && r.includes(xr)) { p.emit("SIGINT") } Reflect.apply(e.#o, this, [t, r, ...n]) } else { Reflect.apply(p.stdin.emit, this, [t, r, ...n]) } } } start() { this.#i++; if (this.#i === 1) { this._realStart() } } stop() { if (this.#i <= 0) { throw new Error("`stop` called more times than `start`") } this.#i--; if (this.#i === 0) { this._realStop() } } _realStart() { if (p.platform === "win32") { return } this.#a = st.createInterface({ input: p.stdin, output: this.#s }); this.#a.on("SIGINT", (() => { if (p.listenerCount("SIGINT") === 0) { p.emit("SIGINT") } else { this.#a.close(); p.kill(p.pid, "SIGINT") } })) } _realStop() { if (p.platform === "win32") { return } this.#a.close(); this.#a = undefined } } const Ar = new StdinDiscarder; const Pr = Ar; class Ora { #u = 0; #c = false; #l = 0; #f = 0; #d; #p; #h; #m; #g; #y; #b; #_; #v; #w; #D; color; constructor(e) { if (typeof e === "string") { e = { text: e } } this.#d = { color: "cyan", stream: p.stderr, discardStdin: true, hideCursor: true, ...e }; this.color = this.#d.color; this.spinner = this.#d.spinner; this.#g = this.#d.interval; this.#h = this.#d.stream; this.#y = typeof this.#d.isEnabled === "boolean" ? this.#d.isEnabled : isInteractive({ stream: this.#h }); this.#b = typeof this.#d.isSilent === "boolean" ? this.#d.isSilent : false; this.text = this.#d.text; this.prefixText = this.#d.prefixText; this.suffixText = this.#d.suffixText; this.indent = this.#d.indent; if (p.env.NODE_ENV === "test") { this._stream = this.#h; this._isEnabled = this.#y; Object.defineProperty(this, "_linesToClear", { get() { return this.#u }, set(e) { this.#u = e } }); Object.defineProperty(this, "_frameIndex", { get() { return this.#f } }); Object.defineProperty(this, "_lineCount", { get() { return this.#l } }) } } get indent() { return this.#_ } set indent(e = 0) { if (!(e >= 0 && Number.isInteger(e))) { throw new Error("The `indent` option must be an integer from 0 and up") } this.#_ = e; this.updateLineCount() } get interval() { return this.#g || this.#p.interval || 100 } get spinner() { return this.#p } set spinner(e) { this.#f = 0; this.#g = undefined; if (typeof e === "object") { if (e.frames === undefined) { throw new Error("The given spinner must have a `frames` property") } this.#p = e } else if (!isUnicodeSupported()) { this.#p = _r.line } else if (e === undefined) { this.#p = _r.dots } else if (e !== "default" && _r[e]) { this.#p = _r[e] } else { throw new Error(`There is no built-in spinner named '${e}'. See https://github.com/sindresorhus/cli-spinners/blob/main/spinners.json for a full list.`) } } get text() { return this.#v } set text(e) { this.#v = e || ""; this.updateLineCount() } get prefixText() { return this.#w } set prefixText(e) { this.#w = e || ""; this.updateLineCount() } get suffixText() { return this.#D } set suffixText(e) { this.#D = e || ""; this.updateLineCount() } get isSpinning() { return this.#m !== undefined } getFullPrefixText(e = this.#w, t = " ") { if (typeof e === "string" && e !== "") { return e + t } if (typeof e === "function") { return e() + t } return "" } getFullSuffixText(e = this.#D, t = " ") { if (typeof e === "string" && e !== "") { return t + e } if (typeof e === "function") { return t + e() } return "" } updateLineCount() { const e = this.#h.columns || 80; const t = this.getFullPrefixText(this.#w, "-"); const r = this.getFullSuffixText(this.#D, "-"); const n = " ".repeat(this.#_) + t + "--" + this.#v + "--" + r; this.#l = 0; for (const t of stripAnsi(n).split("\n")) { this.#l += Math.max(1, Math.ceil(Sr(t) / e)) } } get isEnabled() { return this.#y && !this.#b } set isEnabled(e) { if (typeof e !== "boolean") { throw new TypeError("The `isEnabled` option must be a boolean") } this.#y = e } get isSilent() { return this.#b } set isSilent(e) { if (typeof e !== "boolean") { throw new TypeError("The `isSilent` option must be a boolean") } this.#b = e } frame() { const { frames: e } = this.#p; let t = e[this.#f]; if (this.color) { t = Bt[this.color](t) } this.#f = ++this.#f % e.length; const r = typeof this.#w === "string" && this.#w !== "" ? this.#w + " " : ""; const n = typeof this.text === "string" ? " " + this.text : ""; const i = typeof this.#D === "string" && this.#D !== "" ? " " + this.#D : ""; return r + t + n + i } clear() { if (!this.#y || !this.#h.isTTY) { return this } this.#h.cursorTo(0); for (let e = 0; e < this.#u; e++) { if (e > 0) { this.#h.moveCursor(0, -1) } this.#h.clearLine(1) } if (this.#_ || this.lastIndent !== this.#_) { this.#h.cursorTo(this.#_) } this.lastIndent = this.#_; this.#u = 0; return this } render() { if (this.#b) { return this } this.clear(); this.#h.write(this.frame()); this.#u = this.#l; return this } start(e) { if (e) { this.text = e } if (this.#b) { return this } if (!this.#y) { if (this.text) { this.#h.write(`- ${this.text}\n`) } return this } if (this.isSpinning) { return this } if (this.#d.hideCursor) { br.hide(this.#h) } if (this.#d.discardStdin && p.stdin.isTTY) { this.#c = true; Pr.start() } this.render(); this.#m = setInterval(this.render.bind(this), this.interval); return this } stop() { if (!this.#y) { return this } clearInterval(this.#m); this.#m = undefined; this.#f = 0; this.clear(); if (this.#d.hideCursor) { br.show(this.#h) } if (this.#d.discardStdin && p.stdin.isTTY && this.#c) { Pr.stop(); this.#c = false } return this } succeed(e) { return this.stopAndPersist({ symbol: Er.success, text: e }) } fail(e) { return this.stopAndPersist({ symbol: Er.error, text: e }) } warn(e) { return this.stopAndPersist({ symbol: Er.warning, text: e }) } info(e) { return this.stopAndPersist({ symbol: Er.info, text: e }) } stopAndPersist(e = {}) { if (this.#b) { return this } const t = e.prefixText ?? this.#w; const r = this.getFullPrefixText(t, " "); const n = e.symbol ?? " "; const i = e.text ?? this.text; const s = typeof i === "string" ? " " + i : ""; const o = e.suffixText ?? this.#D; const a = this.getFullSuffixText(o, " "); const u = r + n + s + a + "\n"; this.stop(); this.#h.write(u); return this } } function ora(e) { return new Ora(e) } async function oraPromise(e, t) { const r = typeof e === "function"; const n = typeof e.then === "function"; if (!r && !n) { throw new TypeError("Parameter `action` must be a Function or a Promise") } const { successText: i, failText: s } = typeof t === "object" ? t : { successText: undefined, failText: undefined }; const o = ora(t).start(); try { const t = r ? e(o) : e; const n = await t; o.succeed(i === undefined ? undefined : typeof i === "string" ? i : i(n)); return n } catch (e) { o.fail(s === undefined ? undefined : typeof s === "string" ? s : s(e)); throw e } } const Rr = t("spinner"); function spinner_createSpinner(e) { if (Rr.enabled) { const noop = () => { }; return { get text() { return "" }, set text(t) { e(t) }, start: noop, stop: noop } } const t = ora({ color: "green", spinner: "point" }); return t } const kr = t("init"); const Or = (0, Ne.dirname)((0, g.fileURLToPath)(import.meta.url)); async function createGitHubAction(e, t) { let r = await getRepository(e, false); while (!r) { const e = await prompt(`${chalk.green(`>`)} Enter your GitHub repository: ${chalk.grey(`(username/repository)`)} `); r = parseRepository(e) } let n = await getBranch(t); if (!n) { const e = await prompt(`${chalk.green(`>`)} Enter the target branch: ${chalk.grey(`(main)`)} `); n = e?.trim() || "main" } await fs.copy(path.join(Or, "../../template/.github"), ".github"); await replaceInFile(".github/workflows/publish.yml", "USERNAME/REPO", getShorthandString(r)); await replaceInFile(".github/workflows/publish.yml", "BRANCH", n) } async function importArticlesFromDevTo(e) { const t = await getAllArticles(e); console.info(`Retrieving articles from dev.to…`); const r = getArticlesFromRemoteData(t); console.info(`Found ${chalk.green(r.length)} article(s) to import.`); const processArticle = async e => { const t = generateArticleFilename(e); await saveArticleToFile(t) }; await Promise.all(r.map(processArticle)) } async function init_init(e) { e = e ?? {}; e.pull = e.pull ?? false; kr("options: %O", e); if (e.pull && !e.devtoKey) { process.exitCode = -1; console.error(`${chalk.red(`No dev.to API key provided.`)}\nUse ${chalk.bold(`--token`)} option or ${chalk.bold(`.env`)} file to provide one.`); return } const t = createSpinner(kr); try { await createGitHubAction(e.repo, e.branch); if (e.pull) { t.text = "Retrieving articles from dev.to…"; t.start(); await importArticlesFromDevTo(e.devtoKey); t.stop() } const r = await fs.pathExists(defaultArticlesFolder); if (!r) { await createNewArticle(path.join(defaultArticlesFolder, "article.md")); console.info(`Created your first article draft in ${chalk.green(`posts/article.md`)}!`) } if (!e.skipGit) { if (await hasGitInstalled()) { if (await isGitRepository()) { console.warn(chalk.yellow(`Git repository already initialized.`)) } else { await initGitRepository(e.branch) } } else { console.warn(chalk.yellow(`Cannot init git repository, git binary not found.`)) } } console.info("Init done."); console.info(`Take a look at ${chalk.green(`.github/workflows/publish.yml`)} for next steps.`) } catch (e) { t.stop(); process.exitCode = -1; console.error(chalk.red(`Error: ${e.message}`)); console.error("Init failed.") } } async function new_createNew(e) { if (!e) { process.exitCode = -1; console.error(chalk.red(`red No file name provided.`)); return } const t = path.extname(e).toLowerCase() === ".md" ? e : e + ".md"; if (await fs.pathExists(t)) { process.exitCode = -1; console.error(chalk.red(`File "${t}" already exists.`)); return } try { await createNewArticle(t); console.info(`Created ${chalk.green(t)}.`) } catch (e) { process.exitCode = -1; console.error(chalk.red(`Error: ${e.message}`)); console.error("New article creation failed.") } } var Tr = __nccwpck_require__(3756); const Fr = { upToDate: Bt.grey(`[UP-TO-DATE]`), created: Bt.green(`[CREATED]`), updated: Bt.green(`[UPDATED]`), reconciled: Bt.cyan(`[RECONCILED]`), failed: Bt.red(`[FAILED]`), outOfSync: Bt.yellow(`[OUT-OF-SYNC]`), imageOffline: Bt.red(`[IMG OFFLINE]`) }; const jr = { draft: Bt.grey(`[DRAFT]`), published: Bt.cyan(`[PUBLISHED]`) }; const Lr = t("push"); function formatErrors(e) { const t = e.filter((e => e.errors)); let r = ""; for (const e of t) { r += Bt.red(`${Bt.bold(e.article.file)} has error(s):\n`); for (const t of e.errors) { r += Bt.red(`- ${t}\n`) } } return r } function formatResultsTable(e) { const t = e.map((e => [e.status, e.publishedStatus, e.article.data.title])); const r = 27; const n = p.stdout.columns || 80; const i = Math.max(n - r, 8); return (0, Tr.table)(t, { drawHorizontalLine: () => false, border: (0, Tr.getBorderCharacters)("void"), columnDefault: { paddingLeft: 0, paddingRight: 1 }, columns: { 2: { truncate: i, width: i } } }).slice(0, -1) } async function getRemoteArticles(e) { const t = await api_getAllArticles(e); const r = article_getArticlesFromRemoteData(t); Lr("Retrieved %s article(s)", r.length); return r } async function processArticles(e, t, r, n, i) { const processArticle = async e => { let s = prepareArticleForDevto(e, r, n); const o = checkIfArticleNeedsUpdate(t, s); let a = s.hasChanged ? Fr.reconciled : Fr.upToDate; let u = null; const l = []; if (o) { try { const t = i.checkImages && await checkArticleForOfflineImages(s); if (!i.dryRun && !t) { u = await updateRemoteArticle(s, i.devtoKey); s = await updateLocalArticle(e, u) } if (t) { a = Fr.imageOffline; l.push(`Image ${t} is offline`) } else { a = s.data.id ? Fr.updated : Fr.created } } catch (e) { Lr("Article update failed: %s", String(e)); a = Fr.failed; l.push(`Update failed: ${String(e)}`) } } if (u || s.hasChanged) { try { Lr('Article "%s" has pending changes', s.data.title); if (!i.dryRun) { await article_saveArticleToFile(s) } } catch (e) { Lr('Cannot save article "%s": %s', s.data.title, String(e)); a = Fr.outOfSync } } return { article: s, status: a, publishedStatus: s.data.published ? jr.published : jr.draft, errors: l.length > 0 ? l : undefined } }; return pMap(e, processArticle, { concurrency: 5 }) } async function push_push(e, t) { t = t ?? {}; e = e.length > 0 ? e : ["posts/**/*.md"]; Lr("files: %O", e); Lr("options: %O", t); if (!t.devtoKey) { p.exitCode = -1; console.error(`${Bt.red(`No dev.to API key provided.`)}\nUse ${Bt.bold(`--token`)} option or ${Bt.bold(`.env`)} file to provide one.`); return null } if (t.dryRun) { console.warn(Bt.yellow(`Running in dry run mode, local and remote changes will be skipped`)) } const r = spinner_createSpinner(Lr); try { const n = await repo_getRepository(t.repo); if (!n) { p.exitCode = -1; console.error(`${Bt.red(`No GitHub repository provided.`)}\nUse ${Bt.bold(`--repo`)} option or ${Bt.bold(`.env`)} file to provide one.`); return null } Lr("repository: %O", n); const i = await repo_getBranch(t.branch); if (!i) { p.exitCode = -1; console.error(`${Bt.red(`No GitHub branch provided.`)}\nUse ${Bt.bold(`--branch`)} option or ${Bt.bold(`.env`)} file to provide one.`); return null } Lr("branch: %s", i); let s = await getArticlesFromFiles(e); console.info(`Found ${Bt.green(s.length)} article(s)`); if (s.length === 0) { console.warn(`No articles to push.`); return [] } r.text = "Retrieving articles from dev.to…"; r.start(); const o = await getRemoteArticles(t.devtoKey); if (t.reconcile) { r.text = "Reconciling articles…"; s = reconcileLocalArticles(o, s) } r.text = "Pushing articles to dev.to…"; const a = await processArticles(s, o, n, i, t); r.stop(); console.error(formatErrors(a)); console.info(formatResultsTable(a)); const u = a.some((e => e.status === Fr.outOfSync)); if (u) { console.info(Bt.yellow(`Some local files are out of sync. Retry pushing with ${Bt.bold(`--reconcile`)} option.`)) } const l = a.some((e => e.status === Fr.failed || e.status === Fr.imageOffline)); if (l) { p.exitCode = -1 } return a } catch (e) { r.stop(); p.exitCode = -1; console.error(Bt.red(`Error: ${e.message}`)); console.error("Push failed"); return null } } const Ir = t("init"); async function stats_showStats(e) { e = e ?? {}; e.number = e.number || 10; Ir("options: %O", e); if (!e.devtoKey) { process.exitCode = -1; console.error(`${chalk.red(`No dev.to API key provided.`)}\nUse ${chalk.bold(`--token`)} option or ${chalk.bold(`.env`)} file to provide one.`); return } const t = createSpinner(Ir); try { t.text = "Retrieving articles from dev.to…"; t.start(); const r = await getLastArticlesStats(e.devtoKey, e.number); t.stop(); if (r.length === 0) { console.info(`No published articles found.`); return } if (e.json) { console.info(r); return } const n = 42; const i = process.stdout.columns || 80; const s = Math.max(i - n, 8); const o = r.map((e => [new Date(e.date).toLocaleDateString(), e.title, scaleNumber(e.views), scaleNumber(e.reactions), scaleNumber(e.comments)])); o.unshift(["Date", "Title", "Views", "Likes", "Comm."]); console.info(table(o, { drawHorizontalLine: (e, t) => e === 0 || e === 1 || e === t, columns: { 1: { truncate: s, width: s } } })) } catch (e) { t.stop(); process.exitCode = -1; console.error(chalk.red(`Error while showing stats: ${e.message}`)) } } const Br = (0, Ne.dirname)((0, g.fileURLToPath)(import.meta.url)); const Nr = null && `Usage: dev <init|new|push|stats> [options]\n\nCommands:\n  i, init               Init current dir as an article repository\n    -p, --pull          Pull your articles from dev.to\n    -s, --skip-git      Skip git repository init\n  n, new <file>         Create new article\n  p, push [files]       Push articles to dev.to [default: posts/**/*.md]\n    -d, --dry-run       Do not make actual changes on dev.to\n    -e, --reconcile     Reconcile articles without id using their title\n  s, stats              Display stats for your latest published articles\n    -n, --number <n>    Number of articles to list stats for [default: 10]\n    -j, --json          Format result as JSON\n\nGeneral options:\n  -t, --token <token>   Use this dev.to API token\n  -r, --repo <repo>     GitHub repository (in "user/repo" form)\n  -b, --branch <branch> GitHub branch [default: master]\n  -v, --version         Show version\n  --verbose             Show detailed logs\n  --help                Show this help\n`; async function run(e) { const t = minimist(e, { string: ["token", "repo", "branch"], boolean: ["help", "version", "reconcile", "dry-run", "json", "pull", "skip-git", "skip-check-images", "verbose"], alias: { v: "version", e: "reconcile", d: "dry-run", n: "number", t: "token", j: "json", p: "pull", r: "repo", b: "branch", s: "skip-git" } }); if (t.version) { const e = await fs.readJSON(path.join(Br, "../package.json")); console.info(e.version); return } if (t.help) { console.info(Nr); return } if (t.verbose) { debug.enable("*") } if (!t.token) { dotenv.config(); t.token = process.env.DEVTO_TOKEN } const [r, ...n] = t._; switch (r) { case "i": case "init": { return init({ devtoKey: t.token, repo: t.repo, branch: t.branch, pull: t.pull, skipGit: t["skip-git"] }) } case "n": case "new": { return createNew(n[0]) } case "p": case "push": { return push(n, { devtoKey: t.token, repo: t.repo, branch: t.branch, dryRun: t["dry-run"], reconcile: t.reconcile, checkImages: !t["skip-check-images"] }) } case "s": case "stats": { return showStats({ devtoKey: t.token, number: t.number, json: t.json }) } default: { console.log(Nr) } } } async function publishArticles(e) { const t = p.env.GITHUB_REPOSITORY; const r = await push_push([e.filesGlob], { devtoKey: e.devtoKey || p.env.DEVTO_TOKEN, repo: t, branch: e.branch, checkImages: true, dryRun: e.dryRun }); if (!r || r.length === 0) { return [] } return r } async function index_run() { try { const t = e.getInput("devto_key"); const r = e.getInput("github_token"); const n = e.getInput("files"); const i = e.getInput("branch"); const s = e.getBooleanInput("dry_run"); e.setSecret(t); e.setSecret(r); e.debug(JSON.stringify({ devtoKey: t, githubToken: r, filesGlob: n, branch: i, dryRun: s })); const o = await publishArticles({ filesGlob: n, devtoKey: t, githubToken: r, branch: i, dryRun: s }); const a = o.map((e => ({ id: e.article.data.id, title: e.article.data.title, status: e.status, publishedStatus: e.publishedStatus, errors: e.errors }))); const u = JSON.stringify(a, null, 2); e.debug("Output result_json:\n" + u); e.setOutput("result_json", u); let l = `Found ${o.length} article(s)\n`; const f = formatErrors(o); if (f) { l += f + "\n" } if (o.length > 0) { l += formatResultsTable(o) } e.debug("Output result_summary:\n" + l); e.setOutput("result_summary", l) } catch (t) { e.setFailed(t.toString()) } } index_run() })();